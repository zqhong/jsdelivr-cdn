{"version":3,"sources":["webpack:///./public/app/plugins/datasource/grafana/types.ts","webpack:///./public/app/plugins/datasource/grafana/components/AnnotationQueryEditor.tsx","webpack:///./public/app/plugins/datasource/grafana/datasource.ts","webpack:///./public/app/plugins/datasource/grafana/components/QueryEditor.tsx","webpack:///./public/app/plugins/datasource/grafana/module.ts"],"names":["GrafanaQueryType","defaultQuery","refId","queryType","RandomWalk","GrafanaAnnotationType","tagsTooltipContent","annotationTypes","label","value","Dashboard","description","Tags","limitOptions","map","limit","String","AnnotationQueryEditor","query","onChange","annotationQuery","matchAny","tags","type","styles","getStyles","className","container","menuShouldPortal","inputId","options","newValue","width","id","target","checked","TagFilter","allowCustomValue","formatCreateLabel","input","tagOptions","getAnnotationTags","css","counter","GrafanaDatasource","DataSourceApi","constructor","instanceSettings","super","this","annotations","QueryEditor","prepareAnnotation","json","prepareQuery","anno","name","Annotations","request","queries","templateSrv","getTemplateSrv","targets","from","getAnnotations","range","rangeRaw","raw","annotation","dashboard","getDashboardSrv","getCurrent","hide","LiveMeasurements","channel","replace","scopedVars","filter","startsWith","addr","parseLiveChannelAddress","isValidLiveChannelAddress","buffer","maxLength","maxDataPoints","maxDelta","to","valueOf","push","getGrafanaLiveSrv","getDataStream","key","requestId","getRandomWalk","length","merge","of","metricFindQuery","Promise","resolve","params","data","dashboardId","Array","isArray","delimiter","t","renderedValues","join","tt","split","getBackendSrv","get","toDataFrame","testDatasource","intervalMs","fetch","url","method","pipe","rsp","toDataQueryResponse","catchError","err","PureComponent","channels","channelFields","sel","onRunQuery","props","loadChannelInfo","item","fields","v","tf","state","find","f","txt","rangeUtil","intervalToSeconds","console","warn","e","checkAndUpdateBuffer","subscribe","next","channelInfo","c","distinctFields","Set","frame","dataFrameFromJSON","add","n","minute_rate","setState","componentDidMount","renderMeasurementsQuery","currentChannel","has","formattedTime","secondsToHms","grow","labelWidth","onChannelChange","backspaceRemovesValue","placeholder","isClearable","noOptionsMessage","onFieldNamesChange","isSearchable","isMulti","defaultValue","onKeyDown","handleEnterKey","onBlur","handleBlur","spellCheck","title","severity","render","queryTypes","onQueryTypeChange","plugin","DataSourcePlugin","setQueryEditor"],"mappings":"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","file":"grafanaPlugin.807b3f41627421e0a149.js","sourcesContent":["import { DataQuery } from '@grafana/data';\nimport { LiveDataFilter } from '@grafana/runtime';\n\n//----------------------------------------------\n// Query\n//----------------------------------------------\n\nexport enum GrafanaQueryType {\n  RandomWalk = 'randomWalk',\n  LiveMeasurements = 'measurements',\n  Annotations = 'annotations',\n}\n\nexport interface GrafanaQuery extends DataQuery {\n  queryType: GrafanaQueryType; // RandomWalk by default\n  channel?: string;\n  filter?: LiveDataFilter;\n  buffer?: number;\n}\n\nexport const defaultQuery: GrafanaQuery = {\n  refId: 'A',\n  queryType: GrafanaQueryType.RandomWalk,\n};\n\n//----------------------------------------------\n// Annotations\n//----------------------------------------------\n\nexport enum GrafanaAnnotationType {\n  Dashboard = 'dashboard',\n  Tags = 'tags',\n}\n\nexport interface GrafanaAnnotationQuery extends GrafanaQuery {\n  type: GrafanaAnnotationType; // tags\n  limit: number; // 100\n  tags?: string[];\n  matchAny?: boolean; // By default Grafana only shows annotations that match all tags in the query. Enabling this returns annotations that match any of the tags in the query.\n}\n","import React from 'react';\nimport { SelectableValue } from '@grafana/data';\nimport { Field, FieldSet, Select, Switch } from '@grafana/ui';\nimport { css } from '@emotion/css';\n\nimport { TagFilter } from 'app/core/components/TagFilter/TagFilter';\nimport { GrafanaAnnotationQuery, GrafanaAnnotationType, GrafanaQuery } from '../types';\nimport { getAnnotationTags } from 'app/features/annotations/api';\n\nconst matchTooltipContent = 'Enabling this returns annotations that match any of the tags specified below';\n\nconst tagsTooltipContent = (\n  <div>Specify a list of tags to match. To specify a key and value tag use `key:value` syntax.</div>\n);\n\nconst annotationTypes = [\n  {\n    label: 'Dashboard',\n    value: GrafanaAnnotationType.Dashboard,\n    description: 'Query for events created on this dashboard and show them in the panels where they where created',\n  },\n  {\n    label: 'Tags',\n    value: GrafanaAnnotationType.Tags,\n    description: 'This will fetch any annotation events that match the tags filter',\n  },\n];\n\nconst limitOptions = [10, 50, 100, 200, 300, 500, 1000, 2000].map((limit) => ({\n  label: String(limit),\n  value: limit,\n}));\n\ninterface Props {\n  query: GrafanaQuery;\n  onChange: (newValue: GrafanaAnnotationQuery) => void;\n}\n\nexport default function AnnotationQueryEditor({ query, onChange }: Props) {\n  const annotationQuery = query as GrafanaAnnotationQuery;\n  const { limit, matchAny, tags, type } = annotationQuery;\n  const styles = getStyles();\n\n  const onFilterByChange = (newValue: SelectableValue<GrafanaAnnotationType>) =>\n    onChange({\n      ...annotationQuery,\n      type: newValue.value!,\n    });\n\n  const onMaxLimitChange = (newValue: SelectableValue<number>) =>\n    onChange({\n      ...annotationQuery,\n      limit: newValue.value!,\n    });\n\n  const onMatchAnyChange = (newValue: React.ChangeEvent<HTMLInputElement>) =>\n    onChange({\n      ...annotationQuery,\n      matchAny: newValue.target.checked,\n    });\n\n  const onTagsChange = (tags: string[]) =>\n    onChange({\n      ...annotationQuery,\n      tags,\n    });\n\n  const onFormatCreateLabel = (input: string) => `Use custom value: ${input}`;\n\n  return (\n    <FieldSet className={styles.container}>\n      <Field label=\"Filter by\">\n        <Select\n          menuShouldPortal\n          inputId=\"grafana-annotations__filter-by\"\n          options={annotationTypes}\n          value={type}\n          onChange={onFilterByChange}\n        />\n      </Field>\n      <Field label=\"Max limit\">\n        <Select\n          menuShouldPortal\n          inputId=\"grafana-annotations__limit\"\n          width={16}\n          options={limitOptions}\n          value={limit}\n          onChange={onMaxLimitChange}\n        />\n      </Field>\n      {type === GrafanaAnnotationType.Tags && tags && (\n        <>\n          <Field label=\"Match any\" description={matchTooltipContent}>\n            <Switch id=\"grafana-annotations__match-any\" value={matchAny} onChange={onMatchAnyChange} />\n          </Field>\n          <Field label=\"Tags\" description={tagsTooltipContent}>\n            <TagFilter\n              allowCustomValue\n              formatCreateLabel={onFormatCreateLabel}\n              inputId=\"grafana-annotations__tags\"\n              onChange={onTagsChange}\n              tagOptions={getAnnotationTags}\n              tags={tags}\n            />\n          </Field>\n        </>\n      )}\n    </FieldSet>\n  );\n}\n\nconst getStyles = () => {\n  return {\n    container: css`\n      max-width: 600px;\n    `,\n  };\n};\n","import { from, merge, Observable, of } from 'rxjs';\nimport { catchError, map } from 'rxjs/operators';\nimport { getBackendSrv, getGrafanaLiveSrv, getTemplateSrv, toDataQueryResponse } from '@grafana/runtime';\nimport {\n  AnnotationQuery,\n  AnnotationQueryRequest,\n  DataQueryRequest,\n  DataQueryResponse,\n  DataSourceApi,\n  DataSourceInstanceSettings,\n  isValidLiveChannelAddress,\n  parseLiveChannelAddress,\n  StreamingFrameOptions,\n  toDataFrame,\n} from '@grafana/data';\n\nimport { GrafanaAnnotationQuery, GrafanaAnnotationType, GrafanaQuery, GrafanaQueryType } from './types';\nimport AnnotationQueryEditor from './components/AnnotationQueryEditor';\nimport { getDashboardSrv } from '../../../features/dashboard/services/DashboardSrv';\n\nlet counter = 100;\n\nexport class GrafanaDatasource extends DataSourceApi<GrafanaQuery> {\n  constructor(instanceSettings: DataSourceInstanceSettings) {\n    super(instanceSettings);\n    this.annotations = {\n      QueryEditor: AnnotationQueryEditor,\n      prepareAnnotation(json: any): AnnotationQuery<GrafanaAnnotationQuery> {\n        // Previously, these properties lived outside of target\n        // This should handle migrating them\n        json.target = json.target ?? {\n          type: json.type ?? GrafanaAnnotationType.Dashboard,\n          limit: json.limit ?? 100,\n          tags: json.tags ?? [],\n          matchAny: json.matchAny ?? false,\n        }; // using spread syntax caused an infinite loop in StandardAnnotationQueryEditor\n        return json;\n      },\n      prepareQuery(anno: AnnotationQuery<GrafanaAnnotationQuery>): GrafanaQuery {\n        return { ...anno, refId: anno.name, queryType: GrafanaQueryType.Annotations };\n      },\n    };\n  }\n\n  query(request: DataQueryRequest<GrafanaQuery>): Observable<DataQueryResponse> {\n    const queries: Array<Observable<DataQueryResponse>> = [];\n    const templateSrv = getTemplateSrv();\n    for (const target of request.targets) {\n      if (target.queryType === GrafanaQueryType.Annotations) {\n        return from(\n          this.getAnnotations({\n            range: request.range,\n            rangeRaw: request.range.raw,\n            annotation: (target as unknown) as AnnotationQuery<GrafanaAnnotationQuery>,\n            dashboard: getDashboardSrv().getCurrent(),\n          })\n        );\n      }\n      if (target.hide) {\n        continue;\n      }\n      if (target.queryType === GrafanaQueryType.LiveMeasurements) {\n        let channel = templateSrv.replace(target.channel, request.scopedVars);\n        const { filter } = target;\n\n        // Help migrate pre-release channel paths saved in dashboards\n        // NOTE: this should be removed before V8 is released\n        if (channel && channel.startsWith('telegraf/')) {\n          channel = 'stream/' + channel;\n          target.channel = channel; // mutate the current query object so it is saved with `stream/` prefix\n        }\n\n        const addr = parseLiveChannelAddress(channel);\n        if (!isValidLiveChannelAddress(addr)) {\n          continue;\n        }\n        const buffer: StreamingFrameOptions = {\n          maxLength: request.maxDataPoints ?? 500,\n        };\n        if (target.buffer) {\n          buffer.maxDelta = target.buffer;\n          buffer.maxLength = buffer.maxLength! * 2; //??\n        } else if (request.rangeRaw?.to === 'now') {\n          buffer.maxDelta = request.range.to.valueOf() - request.range.from.valueOf();\n        }\n\n        queries.push(\n          getGrafanaLiveSrv().getDataStream({\n            key: `${request.requestId}.${counter++}`,\n            addr: addr!,\n            filter,\n            buffer,\n          })\n        );\n      } else {\n        queries.push(getRandomWalk(request));\n      }\n    }\n    // With a single query just return the results\n    if (queries.length === 1) {\n      return queries[0];\n    }\n    if (queries.length > 1) {\n      return merge(...queries);\n    }\n    return of(); // nothing\n  }\n\n  metricFindQuery(options: any) {\n    return Promise.resolve([]);\n  }\n\n  async getAnnotations(options: AnnotationQueryRequest<GrafanaQuery>): Promise<DataQueryResponse> {\n    const templateSrv = getTemplateSrv();\n    const annotation = (options.annotation as unknown) as AnnotationQuery<GrafanaAnnotationQuery>;\n    const target = annotation.target!;\n    const params: any = {\n      from: options.range.from.valueOf(),\n      to: options.range.to.valueOf(),\n      limit: target.limit,\n      tags: target.tags,\n      matchAny: target.matchAny,\n    };\n\n    if (target.type === GrafanaAnnotationType.Dashboard) {\n      // if no dashboard id yet return\n      if (!options.dashboard.id) {\n        return Promise.resolve({ data: [] });\n      }\n      // filter by dashboard id\n      params.dashboardId = options.dashboard.id;\n      // remove tags filter if any\n      delete params.tags;\n    } else {\n      // require at least one tag\n      if (!Array.isArray(target.tags) || target.tags.length === 0) {\n        return Promise.resolve({ data: [] });\n      }\n      const delimiter = '__delimiter__';\n      const tags = [];\n      for (const t of params.tags) {\n        const renderedValues = templateSrv.replace(t, {}, (value: any) => {\n          if (typeof value === 'string') {\n            return value;\n          }\n\n          return value.join(delimiter);\n        });\n        for (const tt of renderedValues.split(delimiter)) {\n          tags.push(tt);\n        }\n      }\n      params.tags = tags;\n    }\n\n    const annotations = await getBackendSrv().get(\n      '/api/annotations',\n      params,\n      `grafana-data-source-annotations-${annotation.name}-${options.dashboard?.id}`\n    );\n    return { data: [toDataFrame(annotations)] };\n  }\n\n  testDatasource() {\n    return Promise.resolve();\n  }\n}\n\n// Note that the query does not actually matter\nfunction getRandomWalk(request: DataQueryRequest): Observable<DataQueryResponse> {\n  const { intervalMs, maxDataPoints, range, requestId } = request;\n\n  // Yes, this implementation ignores multiple targets!  But that matches existing behavior\n  const params: Record<string, any> = {\n    intervalMs,\n    maxDataPoints,\n    from: range.from.valueOf(),\n    to: range.to.valueOf(),\n  };\n\n  return getBackendSrv()\n    .fetch({\n      url: '/api/tsdb/testdata/random-walk',\n      method: 'GET',\n      params,\n      requestId,\n    })\n    .pipe(\n      map((rsp: any) => {\n        return toDataQueryResponse(rsp);\n      }),\n      catchError((err) => {\n        return of(toDataQueryResponse(err));\n      })\n    );\n}\n","import React, { PureComponent } from 'react';\nimport { InlineField, Select, Alert, Input } from '@grafana/ui';\nimport { QueryEditorProps, SelectableValue, dataFrameFromJSON, rangeUtil } from '@grafana/data';\nimport { GrafanaDatasource } from '../datasource';\nimport { defaultQuery, GrafanaQuery, GrafanaQueryType } from '../types';\nimport { getBackendSrv } from '@grafana/runtime';\n\ntype Props = QueryEditorProps<GrafanaDatasource, GrafanaQuery>;\n\nconst labelWidth = 12;\n\ninterface State {\n  channels: Array<SelectableValue<string>>;\n  channelFields: Record<string, Array<SelectableValue<string>>>;\n}\n\nexport class QueryEditor extends PureComponent<Props, State> {\n  state: State = { channels: [], channelFields: {} };\n\n  queryTypes: Array<SelectableValue<GrafanaQueryType>> = [\n    {\n      label: 'Random Walk',\n      value: GrafanaQueryType.RandomWalk,\n      description: 'Random signal within the selected time range',\n    },\n    {\n      label: 'Live Measurements',\n      value: GrafanaQueryType.LiveMeasurements,\n      description: 'Stream real-time measurements from Grafana',\n    },\n  ];\n\n  loadChannelInfo() {\n    getBackendSrv()\n      .fetch({ url: 'api/live/list' })\n      .subscribe({\n        next: (v: any) => {\n          const channelInfo = v.data?.channels as any[];\n          if (channelInfo?.length) {\n            const channelFields: Record<string, Array<SelectableValue<string>>> = {};\n            const channels: Array<SelectableValue<string>> = channelInfo.map((c) => {\n              if (c.data) {\n                const distinctFields = new Set<string>();\n                const frame = dataFrameFromJSON(c.data);\n                for (const f of frame.fields) {\n                  distinctFields.add(f.name);\n                }\n                channelFields[c.channel] = Array.from(distinctFields).map((n) => ({\n                  value: n,\n                  label: n,\n                }));\n              }\n              return {\n                value: c.channel,\n                label: c.channel + ' [' + c.minute_rate + ' msg/min]',\n              };\n            });\n\n            this.setState({ channelFields, channels });\n          }\n        },\n      });\n  }\n\n  componentDidMount() {\n    this.loadChannelInfo();\n  }\n\n  onQueryTypeChange = (sel: SelectableValue<GrafanaQueryType>) => {\n    const { onChange, query, onRunQuery } = this.props;\n    onChange({ ...query, queryType: sel.value! });\n    onRunQuery();\n\n    // Reload the channel list\n    this.loadChannelInfo();\n  };\n\n  onChannelChange = (sel: SelectableValue<string>) => {\n    const { onChange, query, onRunQuery } = this.props;\n    onChange({ ...query, channel: sel?.value });\n    onRunQuery();\n  };\n\n  onFieldNamesChange = (item: SelectableValue<string>) => {\n    const { onChange, query, onRunQuery } = this.props;\n    let fields: string[] = [];\n    if (Array.isArray(item)) {\n      fields = item.map((v) => v.value);\n    } else if (item.value) {\n      fields = [item.value];\n    }\n\n    // When adding the first field, also add time (if it exists)\n    if (fields.length === 1 && !query.filter?.fields?.length && query.channel) {\n      const names = this.state.channelFields[query.channel] ?? [];\n      const tf = names.find((f) => f.value === 'time' || f.value === 'Time');\n      if (tf && tf.value && tf.value !== fields[0]) {\n        fields = [tf.value, ...fields];\n      }\n    }\n\n    onChange({\n      ...query,\n      filter: {\n        ...query.filter,\n        fields,\n      },\n    });\n    onRunQuery();\n  };\n\n  checkAndUpdateBuffer = (txt: string) => {\n    const { onChange, query, onRunQuery } = this.props;\n    let buffer: number | undefined;\n    if (txt) {\n      try {\n        buffer = rangeUtil.intervalToSeconds(txt) * 1000;\n      } catch (err) {\n        console.warn('ERROR', err);\n      }\n    }\n    onChange({\n      ...query,\n      buffer,\n    });\n    onRunQuery();\n  };\n\n  handleEnterKey = (e: React.KeyboardEvent<HTMLInputElement>) => {\n    if (e.key !== 'Enter') {\n      return;\n    }\n    this.checkAndUpdateBuffer((e.target as any).value);\n  };\n\n  handleBlur = (e: React.FocusEvent<HTMLInputElement>) => {\n    this.checkAndUpdateBuffer(e.target.value);\n  };\n\n  renderMeasurementsQuery() {\n    let { channel, filter, buffer } = this.props.query;\n    let { channels, channelFields } = this.state;\n    let currentChannel = channels.find((c) => c.value === channel);\n    if (channel && !currentChannel) {\n      currentChannel = {\n        value: channel,\n        label: channel,\n        description: `Connected to ${channel}`,\n      };\n      channels = [currentChannel, ...channels];\n    }\n\n    const distinctFields = new Set<string>();\n    const fields: Array<SelectableValue<string>> = channel ? channelFields[channel] ?? [] : [];\n    // if (data && data.series?.length) {\n    //   for (const frame of data.series) {\n    //     for (const field of frame.fields) {\n    //       if (distinctFields.has(field.name) || !field.name) {\n    //         continue;\n    //       }\n    //       fields.push({\n    //         value: field.name,\n    //         label: field.name,\n    //         description: `(${getFrameDisplayName(frame)} / ${field.type})`,\n    //       });\n    //       distinctFields.add(field.name);\n    //     }\n    //   }\n    // }\n    if (filter?.fields) {\n      for (const f of filter.fields) {\n        if (!distinctFields.has(f)) {\n          fields.push({\n            value: f,\n            label: `${f} (not loaded)`,\n            description: `Configured, but not found in the query results`,\n          });\n          distinctFields.add(f);\n        }\n      }\n    }\n\n    let formattedTime = '';\n    if (buffer) {\n      formattedTime = rangeUtil.secondsToHms(buffer / 1000);\n    }\n\n    return (\n      <>\n        <div className=\"gf-form\">\n          <InlineField label=\"Channel\" grow={true} labelWidth={labelWidth}>\n            <Select\n              menuShouldPortal\n              options={channels}\n              value={currentChannel || ''}\n              onChange={this.onChannelChange}\n              allowCustomValue={true}\n              backspaceRemovesValue={true}\n              placeholder=\"Select measurements channel\"\n              isClearable={true}\n              noOptionsMessage=\"Enter channel name\"\n              formatCreateLabel={(input: string) => `Connect to: ${input}`}\n            />\n          </InlineField>\n        </div>\n        {channel && (\n          <div className=\"gf-form\">\n            <InlineField label=\"Fields\" grow={true} labelWidth={labelWidth}>\n              <Select\n                menuShouldPortal\n                options={fields}\n                value={filter?.fields || []}\n                onChange={this.onFieldNamesChange}\n                allowCustomValue={true}\n                backspaceRemovesValue={true}\n                placeholder=\"All fields\"\n                isClearable={true}\n                noOptionsMessage=\"Unable to list all fields\"\n                formatCreateLabel={(input: string) => `Field: ${input}`}\n                isSearchable={true}\n                isMulti={true}\n              />\n            </InlineField>\n            <InlineField label=\"Buffer\">\n              <Input\n                placeholder=\"Auto\"\n                width={12}\n                defaultValue={formattedTime}\n                onKeyDown={this.handleEnterKey}\n                onBlur={this.handleBlur}\n                spellCheck={false}\n              />\n            </InlineField>\n          </div>\n        )}\n\n        <Alert title=\"Grafana Live - Measurements\" severity=\"info\">\n          This supports real-time event streams in Grafana core. This feature is under heavy development. Expect the\n          interfaces and structures to change as this becomes more production ready.\n        </Alert>\n      </>\n    );\n  }\n\n  render() {\n    const query = {\n      ...defaultQuery,\n      ...this.props.query,\n    };\n\n    return (\n      <>\n        <div className=\"gf-form\">\n          <InlineField label=\"Query type\" grow={true} labelWidth={labelWidth}>\n            <Select\n              menuShouldPortal\n              options={this.queryTypes}\n              value={this.queryTypes.find((v) => v.value === query.queryType) || this.queryTypes[0]}\n              onChange={this.onQueryTypeChange}\n            />\n          </InlineField>\n        </div>\n        {query.queryType === GrafanaQueryType.LiveMeasurements && this.renderMeasurementsQuery()}\n      </>\n    );\n  }\n}\n","import { DataSourcePlugin } from '@grafana/data';\nimport { GrafanaDatasource } from './datasource';\nimport { QueryEditor } from './components/QueryEditor';\nimport { GrafanaQuery } from './types';\n\nexport const plugin = new DataSourcePlugin<GrafanaDatasource, GrafanaQuery>(GrafanaDatasource).setQueryEditor(\n  QueryEditor\n);\n"],"sourceRoot":""}