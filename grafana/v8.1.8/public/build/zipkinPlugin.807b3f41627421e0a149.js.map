{"version":3,"sources":["webpack:///./public/app/core/components/TraceToLogsSettings.tsx","webpack:///./public/app/plugins/datasource/zipkin/utils/transforms.ts","webpack:///./public/app/plugins/datasource/zipkin/utils/graphTransform.ts","webpack:///./public/app/plugins/datasource/zipkin/datasource.ts","webpack:///./public/app/plugins/datasource/zipkin/QueryField.tsx","webpack:///./public/app/plugins/datasource/zipkin/module.ts","webpack:///./public/app/plugins/datasource/zipkin/ConfigEditor.tsx","webpack:///./public/app/core/utils/tracing.ts","webpack:///./node_modules/react-use/esm/useMount.js"],"names":["TraceToLogsSettings","options","onOptionsChange","styles","useStyles","getStyles","className","css","width","infoText","tooltip","label","labelWidth","pluginId","current","jsonData","tracesToLogs","datasourceUid","noDefault","onChange","ds","updateDatasourcePluginJsonDataOption","uid","tags","grow","type","placeholder","v","spanStartTimeShift","currentTarget","value","spanEndTimeShift","theme","spacing","md","colors","textSemiWeak","transformResponse","zSpans","spanRows","map","transformSpan","frame","MutableDataFrame","fields","name","FieldType","string","other","number","meta","preferredVisualisationType","span","add","row","traceID","traceId","spanID","id","parentSpanID","parentId","operationName","serviceName","localEndpoint","remoteEndpoint","serviceTags","startTime","timestamp","duration","logs","annotations","transformAnnotation","Object","keys","reduce","acc","key","push","kind","annotation","endpoint","valueToTag","ipv4","ipv6","port","filter","identity","createGraphFrames","data","nodes","edges","spans","traceDuration","traceEndTime","traceStartTime","Infinity","findTraceDuration","spanMap","makeSpanMap","index","length","parentIds","ranges","children","c","childrenDuration","getNonOverlappingDuration","selfDuration","stats","getStats","Fields","title","subTitle","mainStat","main","secondaryStat","secondary","color","target","source","convertTraceToGraph","nodesFrame","edgesFrame","makeFrames","node","edge","ZipkinDatasource","DataSourceApi","constructor","instanceSettings","super","query","targets","this","request","encodeURIComponent","pipe","responseToDataQueryResponse","of","emptyDataQueryResponse","url","params","hideFromInspector","toPromise","metadataRequest","status","message","getQueryDisplayText","apiUrl","serializeParams","req","getBackendSrv","fetch","response","trace","values","noTracesFoundOptions","isLeaf","noTracesOptions","plugin","DataSourcePlugin","setConfigEditor","defaultUrl","dataSourceConfig","showAccessOptions","setExploreQueryField","onRunQuery","datasource","serviceOptions","servicesOptions","useAsyncFn","async","services","sort","service","error","dispatch","notifyApp","createErrorNotification","useMount","useServices","onLoadOptions","allOptions","isMounted","useMountedState","setAllOptions","useState","fetchSpans","state","spanOptions","fromPairs","undefined","fetchTraces","spanName","search","traces","newTraces","rootSpan","find","Math","floor","useCallback","selectedOptions","useLoadOptions","onSelectTrace","cascaderOptions","useMemo","traceName","useMapToCascaderOptions","loadData","aria-label","selectors","components","QueryField","container","style","e","a","b","range","tail","slice","prevStart","prevEnd","start","end","getSpan","toFixedNoTrailingZeros","n","parseFloat","toFixed","config","displayName","mode","fn"],"mappings":"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","file":"zipkinPlugin.807b3f41627421e0a149.js","sourcesContent":["import { css } from '@emotion/css';\nimport {\n  DataSourceJsonData,\n  DataSourcePluginOptionsEditorProps,\n  GrafanaTheme,\n  updateDatasourcePluginJsonDataOption,\n} from '@grafana/data';\nimport { DataSourcePicker } from '@grafana/runtime';\nimport { InlineField, InlineFieldRow, Input, TagsInput, useStyles } from '@grafana/ui';\nimport React from 'react';\n\nexport interface TraceToLogsOptions {\n  datasourceUid?: string;\n  tags?: string[];\n  spanStartTimeShift?: string;\n  spanEndTimeShift?: string;\n}\n\nexport interface TraceToLogsData extends DataSourceJsonData {\n  tracesToLogs?: TraceToLogsOptions;\n}\n\ninterface Props extends DataSourcePluginOptionsEditorProps<TraceToLogsData> {}\n\nexport function TraceToLogsSettings({ options, onOptionsChange }: Props) {\n  const styles = useStyles(getStyles);\n\n  return (\n    <div className={css({ width: '100%' })}>\n      <h3 className=\"page-heading\">Trace to logs</h3>\n\n      <div className={styles.infoText}>\n        Trace to logs let&apos;s you navigate from a trace span to the selected data source&apos;s log.\n      </div>\n\n      <InlineFieldRow>\n        <InlineField tooltip=\"The data source the trace is going to navigate to\" label=\"Data source\" labelWidth={26}>\n          <DataSourcePicker\n            pluginId=\"loki\"\n            current={options.jsonData.tracesToLogs?.datasourceUid}\n            noDefault={true}\n            width={40}\n            onChange={(ds) =>\n              updateDatasourcePluginJsonDataOption({ onOptionsChange, options }, 'tracesToLogs', {\n                datasourceUid: ds.uid,\n                tags: options.jsonData.tracesToLogs?.tags,\n              })\n            }\n          />\n        </InlineField>\n      </InlineFieldRow>\n\n      <InlineFieldRow>\n        <InlineField\n          tooltip=\"Tags that will be used in the Loki query. Default tags: 'cluster', 'hostname', 'namespace', 'pod'\"\n          label=\"Tags\"\n          labelWidth={26}\n        >\n          <TagsInput\n            tags={options.jsonData.tracesToLogs?.tags}\n            width={40}\n            onChange={(tags) =>\n              updateDatasourcePluginJsonDataOption({ onOptionsChange, options }, 'tracesToLogs', {\n                datasourceUid: options.jsonData.tracesToLogs?.datasourceUid,\n                tags: tags,\n              })\n            }\n          />\n        </InlineField>\n      </InlineFieldRow>\n\n      <InlineFieldRow>\n        <InlineField\n          label=\"Span start time shift\"\n          labelWidth={26}\n          grow\n          tooltip=\"Shifts the start time of the span. Default 0 (Time units can be used here, for example: 5s, 1m, 3h)\"\n        >\n          <Input\n            type=\"text\"\n            placeholder=\"1h\"\n            width={40}\n            onChange={(v) =>\n              updateDatasourcePluginJsonDataOption({ onOptionsChange, options }, 'tracesToLogs', {\n                ...options.jsonData.tracesToLogs,\n                spanStartTimeShift: v.currentTarget.value,\n              })\n            }\n            value={options.jsonData.tracesToLogs?.spanStartTimeShift || ''}\n          />\n        </InlineField>\n      </InlineFieldRow>\n\n      <InlineFieldRow>\n        <InlineField\n          label=\"Span end time shift\"\n          labelWidth={26}\n          grow\n          tooltip=\"Shifts the end time of the span. Default 0 Time units can be used here, for example: 5s, 1m, 3h\"\n        >\n          <Input\n            type=\"text\"\n            placeholder=\"1h\"\n            width={40}\n            onChange={(v) =>\n              updateDatasourcePluginJsonDataOption({ onOptionsChange, options }, 'tracesToLogs', {\n                ...options.jsonData.tracesToLogs,\n                spanEndTimeShift: v.currentTarget.value,\n              })\n            }\n            value={options.jsonData.tracesToLogs?.spanEndTimeShift || ''}\n          />\n        </InlineField>\n      </InlineFieldRow>\n    </div>\n  );\n}\n\nconst getStyles = (theme: GrafanaTheme) => ({\n  infoText: css`\n    padding-bottom: ${theme.spacing.md};\n    color: ${theme.colors.textSemiWeak};\n  `,\n});\n","import { identity } from 'lodash';\nimport { ZipkinAnnotation, ZipkinSpan } from '../types';\nimport { DataFrame, FieldType, MutableDataFrame, TraceKeyValuePair, TraceLog, TraceSpanRow } from '@grafana/data';\n\n/**\n * Transforms response to Grafana trace data frame.\n */\nexport function transformResponse(zSpans: ZipkinSpan[]): DataFrame {\n  const spanRows = zSpans.map(transformSpan);\n  const frame = new MutableDataFrame({\n    fields: [\n      { name: 'traceID', type: FieldType.string },\n      { name: 'spanID', type: FieldType.string },\n      { name: 'parentSpanID', type: FieldType.string },\n      { name: 'operationName', type: FieldType.string },\n      { name: 'serviceName', type: FieldType.string },\n      { name: 'serviceTags', type: FieldType.other },\n      { name: 'startTime', type: FieldType.number },\n      { name: 'duration', type: FieldType.number },\n      { name: 'logs', type: FieldType.other },\n      { name: 'tags', type: FieldType.other },\n    ],\n    meta: {\n      preferredVisualisationType: 'trace',\n    },\n  });\n\n  for (const span of spanRows) {\n    frame.add(span);\n  }\n\n  return frame;\n}\n\nfunction transformSpan(span: ZipkinSpan): TraceSpanRow {\n  const row = {\n    traceID: span.traceId,\n    spanID: span.id,\n    parentSpanID: span.parentId,\n    operationName: span.name,\n    serviceName: span.localEndpoint?.serviceName || span.remoteEndpoint?.serviceName || 'unknown',\n    serviceTags: serviceTags(span),\n    startTime: span.timestamp / 1000,\n    duration: span.duration / 1000,\n    logs: span.annotations?.map(transformAnnotation) ?? [],\n    tags: Object.keys(span.tags || {}).reduce<TraceKeyValuePair[]>((acc, key) => {\n      // If tag is error we remap it to simple boolean so that the trace ui will show an error icon.\n      if (key === 'error') {\n        acc.push({\n          key: 'error',\n          value: true,\n        });\n\n        acc.push({\n          key: 'errorValue',\n          value: span.tags!['error'],\n        });\n        return acc;\n      }\n      acc.push({ key, value: span.tags![key] });\n      return acc;\n    }, []),\n  };\n\n  if (span.kind) {\n    row.tags = [\n      {\n        key: 'kind',\n        value: span.kind,\n      },\n      ...(row.tags ?? []),\n    ];\n  }\n\n  return row;\n}\n\n/**\n * Maps annotations as a log as that seems to be the closest thing.\n * See https://zipkin.io/zipkin-api/#/default/get_trace__traceId_\n */\nfunction transformAnnotation(annotation: ZipkinAnnotation): TraceLog {\n  return {\n    timestamp: annotation.timestamp,\n    fields: [\n      {\n        key: 'annotation',\n        value: annotation.value,\n      },\n    ],\n  };\n}\n\nfunction serviceTags(span: ZipkinSpan): TraceKeyValuePair[] {\n  const endpoint = span.localEndpoint || span.remoteEndpoint;\n  if (!endpoint) {\n    return [];\n  }\n  return [\n    valueToTag('ipv4', endpoint.ipv4),\n    valueToTag('ipv6', endpoint.ipv6),\n    valueToTag('port', endpoint.port),\n  ].filter(identity) as TraceKeyValuePair[];\n}\n\nfunction valueToTag<T>(key: string, value: T): TraceKeyValuePair<T> | undefined {\n  if (!value) {\n    return undefined;\n  }\n  return {\n    key,\n    value,\n  };\n}\n","import { DataFrame, NodeGraphDataFrameFieldNames as Fields } from '@grafana/data';\nimport { ZipkinSpan } from '../types';\nimport { getNonOverlappingDuration, getStats, makeFrames, makeSpanMap } from '../../../../core/utils/tracing';\n\ninterface Node {\n  [Fields.id]: string;\n  [Fields.title]: string;\n  [Fields.subTitle]: string;\n  [Fields.mainStat]: string;\n  [Fields.secondaryStat]: string;\n  [Fields.color]: number;\n}\n\ninterface Edge {\n  [Fields.id]: string;\n  [Fields.target]: string;\n  [Fields.source]: string;\n}\n\nexport function createGraphFrames(data: ZipkinSpan[]): DataFrame[] {\n  const { nodes, edges } = convertTraceToGraph(data);\n  const [nodesFrame, edgesFrame] = makeFrames();\n\n  for (const node of nodes) {\n    nodesFrame.add(node);\n  }\n\n  for (const edge of edges) {\n    edgesFrame.add(edge);\n  }\n\n  return [nodesFrame, edgesFrame];\n}\n\nfunction convertTraceToGraph(spans: ZipkinSpan[]): { nodes: Node[]; edges: Edge[] } {\n  const nodes: Node[] = [];\n  const edges: Edge[] = [];\n\n  const traceDuration = findTraceDuration(spans);\n  const spanMap = makeSpanMap((index) => {\n    if (index >= spans.length) {\n      return undefined;\n    }\n    return {\n      span: spans[index],\n      id: spans[index].id,\n      parentIds: spans[index].parentId ? [spans[index].parentId!] : [],\n    };\n  });\n\n  for (const span of spans) {\n    const ranges: Array<[number, number]> = spanMap[span.id].children.map((c) => {\n      const span = spanMap[c].span;\n      return [span.timestamp, span.timestamp + span.duration];\n    });\n    const childrenDuration = getNonOverlappingDuration(ranges);\n    const selfDuration = span.duration - childrenDuration;\n    const stats = getStats(span.duration / 1000, traceDuration / 1000, selfDuration / 1000);\n\n    nodes.push({\n      [Fields.id]: span.id,\n      [Fields.title]: span.localEndpoint?.serviceName || span.remoteEndpoint?.serviceName || 'unknown',\n      [Fields.subTitle]: span.name,\n      [Fields.mainStat]: stats.main,\n      [Fields.secondaryStat]: stats.secondary,\n      [Fields.color]: selfDuration / traceDuration,\n    });\n\n    if (span.parentId && spanMap[span.parentId].span) {\n      edges.push({\n        [Fields.id]: span.parentId + '--' + span.id,\n        [Fields.target]: span.id,\n        [Fields.source]: span.parentId,\n      });\n    }\n  }\n\n  return { nodes, edges };\n}\n\n/**\n * Get the duration of the whole trace as it isn't a part of the response data.\n * Note: Seems like this should be the same as just longest span, but this is probably safer.\n */\nfunction findTraceDuration(spans: ZipkinSpan[]): number {\n  let traceEndTime = 0;\n  let traceStartTime = Infinity;\n\n  for (const span of spans) {\n    if (span.timestamp < traceStartTime) {\n      traceStartTime = span.timestamp;\n    }\n\n    if (span.timestamp + span.duration > traceEndTime) {\n      traceEndTime = span.timestamp + span.duration;\n    }\n  }\n  return traceEndTime - traceStartTime;\n}\n","import {\n  DataQuery,\n  DataQueryRequest,\n  DataQueryResponse,\n  DataSourceApi,\n  DataSourceInstanceSettings,\n  FieldType,\n  MutableDataFrame,\n} from '@grafana/data';\nimport { BackendSrvRequest, FetchResponse, getBackendSrv } from '@grafana/runtime';\nimport { Observable, of } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport { serializeParams } from '../../../core/utils/fetch';\nimport { apiPrefix } from './constants';\nimport { ZipkinSpan } from './types';\nimport { transformResponse } from './utils/transforms';\nimport { createGraphFrames } from './utils/graphTransform';\n\nexport interface ZipkinQuery extends DataQuery {\n  query: string;\n}\n\nexport class ZipkinDatasource extends DataSourceApi<ZipkinQuery> {\n  constructor(private instanceSettings: DataSourceInstanceSettings) {\n    super(instanceSettings);\n  }\n\n  query(options: DataQueryRequest<ZipkinQuery>): Observable<DataQueryResponse> {\n    const traceId = options.targets[0]?.query;\n    if (traceId) {\n      return this.request<ZipkinSpan[]>(`${apiPrefix}/trace/${encodeURIComponent(traceId)}`).pipe(\n        map(responseToDataQueryResponse)\n      );\n    } else {\n      return of(emptyDataQueryResponse);\n    }\n  }\n\n  async metadataRequest(url: string, params?: Record<string, any>): Promise<any> {\n    const res = await this.request(url, params, { hideFromInspector: true }).toPromise();\n    return res.data;\n  }\n\n  async testDatasource(): Promise<{ status: string; message: string }> {\n    await this.metadataRequest(`${apiPrefix}/services`);\n    return { status: 'success', message: 'Data source is working' };\n  }\n\n  getQueryDisplayText(query: ZipkinQuery): string {\n    return query.query;\n  }\n\n  private request<T = any>(\n    apiUrl: string,\n    data?: any,\n    options?: Partial<BackendSrvRequest>\n  ): Observable<FetchResponse<T>> {\n    const params = data ? serializeParams(data) : '';\n    const url = `${this.instanceSettings.url}${apiUrl}${params.length ? `?${params}` : ''}`;\n    const req = {\n      ...options,\n      url,\n    };\n\n    return getBackendSrv().fetch<T>(req);\n  }\n}\n\nfunction responseToDataQueryResponse(response: { data: ZipkinSpan[] }): DataQueryResponse {\n  return {\n    data: response?.data ? [transformResponse(response?.data), ...createGraphFrames(response?.data)] : [],\n  };\n}\n\nconst emptyDataQueryResponse = {\n  data: [\n    new MutableDataFrame({\n      fields: [\n        {\n          name: 'trace',\n          type: FieldType.trace,\n          values: [],\n        },\n      ],\n      meta: {\n        preferredVisualisationType: 'trace',\n      },\n    }),\n  ],\n};\n","import { ExploreQueryFieldProps } from '@grafana/data';\nimport { selectors } from '@grafana/e2e-selectors';\nimport { ButtonCascader, CascaderOption } from '@grafana/ui';\nimport { fromPairs } from 'lodash';\nimport React, { useCallback, useMemo, useState } from 'react';\nimport { useAsyncFn, useMount, useMountedState } from 'react-use';\nimport { AsyncState } from 'react-use/lib/useAsyncFn';\nimport { apiPrefix } from './constants';\nimport { ZipkinDatasource, ZipkinQuery } from './datasource';\nimport { ZipkinSpan } from './types';\nimport { dispatch } from 'app/store/store';\nimport { notifyApp } from 'app/core/actions';\nimport { createErrorNotification } from 'app/core/copy/appNotification';\n\ntype Props = ExploreQueryFieldProps<ZipkinDatasource, ZipkinQuery>;\n\nexport const QueryField = ({ query, onChange, onRunQuery, datasource }: Props) => {\n  const serviceOptions = useServices(datasource);\n  const { onLoadOptions, allOptions } = useLoadOptions(datasource);\n\n  const onSelectTrace = useCallback(\n    (values: string[], selectedOptions: CascaderOption[]) => {\n      if (selectedOptions.length === 3) {\n        const traceID = selectedOptions[2].value;\n        onChange({ ...query, query: traceID });\n        onRunQuery();\n      }\n    },\n    [onChange, onRunQuery, query]\n  );\n\n  let cascaderOptions = useMapToCascaderOptions(serviceOptions, allOptions);\n\n  return (\n    <>\n      <div className=\"gf-form-inline gf-form-inline--nowrap\">\n        <div className=\"gf-form flex-shrink-0\">\n          <ButtonCascader options={cascaderOptions} onChange={onSelectTrace} loadData={onLoadOptions}>\n            Traces\n          </ButtonCascader>\n        </div>\n        <div className=\"gf-form gf-form--grow flex-shrink-1\">\n          <div className=\"slate-query-field__wrapper\">\n            <div className=\"slate-query-field\" aria-label={selectors.components.QueryField.container}>\n              <input\n                style={{ width: '100%' }}\n                value={query.query || ''}\n                onChange={(e) =>\n                  onChange({\n                    ...query,\n                    query: e.currentTarget.value,\n                  })\n                }\n              />\n            </div>\n          </div>\n        </div>\n      </div>\n    </>\n  );\n};\n\n// Exported for tests\nexport function useServices(datasource: ZipkinDatasource): AsyncState<CascaderOption[]> {\n  const url = `${apiPrefix}/services`;\n\n  const [servicesOptions, fetch] = useAsyncFn(async (): Promise<CascaderOption[]> => {\n    try {\n      const services: string[] | null = await datasource.metadataRequest(url);\n      if (services) {\n        return services.sort().map((service) => ({\n          label: service,\n          value: service,\n          isLeaf: false,\n        }));\n      }\n      return [];\n    } catch (error) {\n      dispatch(notifyApp(createErrorNotification('Failed to load services from Zipkin', error)));\n      throw error;\n    }\n  }, [datasource]);\n\n  useMount(() => {\n    // We should probably call this periodically to get new services after mount.\n    fetch();\n  });\n\n  return servicesOptions;\n}\n\ntype OptionsState = {\n  [serviceName: string]: {\n    [spanName: string]: {\n      [traceId: string]: string;\n    };\n  };\n};\n\n// Exported for tests\nexport function useLoadOptions(datasource: ZipkinDatasource) {\n  const isMounted = useMountedState();\n  const [allOptions, setAllOptions] = useState({} as OptionsState);\n\n  const [, fetchSpans] = useAsyncFn(\n    async function findSpans(service: string): Promise<void> {\n      const url = `${apiPrefix}/spans`;\n      try {\n        // The response of this should have been full ZipkinSpan objects based on API docs but is just list\n        // of span names.\n        // TODO: check if this is some issue of version used or something else\n        const response: string[] = await datasource.metadataRequest(url, { serviceName: service });\n        if (isMounted()) {\n          setAllOptions((state) => {\n            const spanOptions = fromPairs(response.map((span: string) => [span, undefined]));\n            return {\n              ...state,\n              [service]: spanOptions as any,\n            };\n          });\n        }\n      } catch (error) {\n        dispatch(notifyApp(createErrorNotification('Failed to load spans from Zipkin', error)));\n        throw error;\n      }\n    },\n    [datasource, allOptions]\n  );\n\n  const [, fetchTraces] = useAsyncFn(\n    async function findTraces(serviceName: string, spanName: string): Promise<void> {\n      const url = `${apiPrefix}/traces`;\n      const search = {\n        serviceName,\n        spanName,\n        // See other params and default here https://zipkin.io/zipkin-api/#/default/get_traces\n      };\n      try {\n        // This should return just root traces as there isn't any nesting\n        const traces: ZipkinSpan[][] = await datasource.metadataRequest(url, search);\n        if (isMounted()) {\n          const newTraces = traces.length\n            ? fromPairs(\n                traces.map((trace) => {\n                  const rootSpan = trace.find((span) => !span.parentId)!;\n\n                  return [`${rootSpan.name} [${Math.floor(rootSpan.duration / 1000)} ms]`, rootSpan.traceId];\n                })\n              )\n            : noTracesOptions;\n\n          setAllOptions((state) => {\n            const spans = state[serviceName];\n            return {\n              ...state,\n              [serviceName]: {\n                ...spans,\n                [spanName]: newTraces,\n              },\n            };\n          });\n        }\n      } catch (error) {\n        dispatch(notifyApp(createErrorNotification('Failed to load spans from Zipkin', error)));\n        throw error;\n      }\n    },\n    [datasource]\n  );\n\n  const onLoadOptions = useCallback(\n    (selectedOptions: CascaderOption[]) => {\n      const service = selectedOptions[0].value;\n      if (selectedOptions.length === 1) {\n        fetchSpans(service);\n      } else if (selectedOptions.length === 2) {\n        const spanName = selectedOptions[1].value;\n        fetchTraces(service, spanName);\n      }\n    },\n    [fetchSpans, fetchTraces]\n  );\n\n  return {\n    onLoadOptions,\n    allOptions,\n  };\n}\n\nfunction useMapToCascaderOptions(services: AsyncState<CascaderOption[]>, allOptions: OptionsState) {\n  return useMemo(() => {\n    let cascaderOptions: CascaderOption[] = [];\n\n    if (services.value && services.value.length) {\n      cascaderOptions = services.value.map((services) => {\n        return {\n          ...services,\n          children:\n            allOptions[services.value] &&\n            Object.keys(allOptions[services.value]).map((spanName) => {\n              return {\n                label: spanName,\n                value: spanName,\n                isLeaf: false,\n                children:\n                  allOptions[services.value][spanName] &&\n                  Object.keys(allOptions[services.value][spanName]).map((traceName) => {\n                    return {\n                      label: traceName,\n                      value: allOptions[services.value][spanName][traceName],\n                    };\n                  }),\n              };\n            }),\n        };\n      });\n    } else if (services.value && !services.value.length) {\n      cascaderOptions = noTracesFoundOptions;\n    }\n\n    return cascaderOptions;\n  }, [services, allOptions]);\n}\n\nconst NO_TRACES_KEY = '__NO_TRACES__';\nconst noTracesFoundOptions = [\n  {\n    label: 'No traces found',\n    value: 'no_traces',\n    isLeaf: true,\n\n    // Cannot be disabled because then cascader shows 'loading' for some reason.\n    // disabled: true,\n  },\n];\n\nconst noTracesOptions = {\n  '[No traces in time range]': NO_TRACES_KEY,\n};\n","import { DataSourcePlugin } from '@grafana/data';\nimport { ZipkinDatasource } from './datasource';\nimport { QueryField } from './QueryField';\nimport { ConfigEditor } from './ConfigEditor';\n\nexport const plugin = new DataSourcePlugin(ZipkinDatasource)\n  .setConfigEditor(ConfigEditor)\n  .setExploreQueryField(QueryField);\n","import { DataSourcePluginOptionsEditorProps } from '@grafana/data';\nimport { DataSourceHttpSettings } from '@grafana/ui';\nimport { TraceToLogsSettings } from 'app/core/components/TraceToLogsSettings';\nimport React from 'react';\n\nexport type Props = DataSourcePluginOptionsEditorProps;\n\nexport const ConfigEditor: React.FC<Props> = ({ options, onOptionsChange }) => {\n  return (\n    <>\n      <DataSourceHttpSettings\n        defaultUrl=\"http://localhost:9411\"\n        dataSourceConfig={options}\n        showAccessOptions={false}\n        onChange={onOptionsChange}\n      />\n\n      <TraceToLogsSettings options={options} onOptionsChange={onOptionsChange} />\n    </>\n  );\n};\n","/**\n * Get non overlapping duration of the ranges as they can overlap or have gaps.\n */\nimport { FieldType, MutableDataFrame, NodeGraphDataFrameFieldNames as Fields } from '@grafana/data';\n\nexport function getNonOverlappingDuration(ranges: Array<[number, number]>): number {\n  ranges.sort((a, b) => a[0] - b[0]);\n  const mergedRanges = ranges.reduce((acc, range) => {\n    if (!acc.length) {\n      return [range];\n    }\n    const tail = acc.slice(-1)[0];\n    const [prevStart, prevEnd] = tail;\n    const [start, end] = range;\n    if (end < prevEnd) {\n      // In this case the range is completely inside the prev range so we can just ignore it.\n      return acc;\n    }\n\n    if (start > prevEnd) {\n      // There is no overlap so we can just add it to stack\n      return [...acc, range];\n    }\n\n    // We know there is overlap and current range ends later than previous so we can just extend the range\n    return [...acc.slice(0, -1), [prevStart, end]] as Array<[number, number]>;\n  }, [] as Array<[number, number]>);\n\n  return mergedRanges.reduce((acc, range) => {\n    return acc + (range[1] - range[0]);\n  }, 0);\n}\n\n/**\n * Returns a map of the spans with children array for easier processing. It will also contain empty spans in case\n * span is missing but other spans are it's children. This is more generic because it needs to allow iterating over\n * both arrays and dataframe views.\n */\nexport function makeSpanMap<T>(\n  getSpan: (index: number) => { span: T; id: string; parentIds: string[] } | undefined\n): { [id: string]: { span: T; children: string[] } } {\n  const spanMap: { [id: string]: { span?: T; children: string[] } } = {};\n\n  let span;\n  for (let index = 0; (span = getSpan(index)), !!span; index++) {\n    if (!spanMap[span.id]) {\n      spanMap[span.id] = {\n        span: span.span,\n        children: [],\n      };\n    } else {\n      spanMap[span.id].span = span.span;\n    }\n\n    for (const parentId of span.parentIds) {\n      if (parentId) {\n        if (!spanMap[parentId]) {\n          spanMap[parentId] = {\n            span: undefined,\n            children: [span.id],\n          };\n        } else {\n          spanMap[parentId].children.push(span.id);\n        }\n      }\n    }\n  }\n  return spanMap as { [id: string]: { span: T; children: string[] } };\n}\n\nexport function getStats(duration: number, traceDuration: number, selfDuration: number) {\n  return {\n    main: `${toFixedNoTrailingZeros(duration)}ms (${toFixedNoTrailingZeros((duration / traceDuration) * 100)}%)`,\n    secondary: `${toFixedNoTrailingZeros(selfDuration)}ms (${toFixedNoTrailingZeros(\n      (selfDuration / duration) * 100\n    )}%)`,\n  };\n}\n\nfunction toFixedNoTrailingZeros(n: number) {\n  return parseFloat(n.toFixed(2));\n}\n\n/**\n * Create default frames used when returning data for node graph.\n */\nexport function makeFrames() {\n  const nodesFrame = new MutableDataFrame({\n    fields: [\n      { name: Fields.id, type: FieldType.string },\n      { name: Fields.title, type: FieldType.string },\n      { name: Fields.subTitle, type: FieldType.string },\n      { name: Fields.mainStat, type: FieldType.string, config: { displayName: 'Total time (% of trace)' } },\n      { name: Fields.secondaryStat, type: FieldType.string, config: { displayName: 'Self time (% of total)' } },\n      {\n        name: Fields.color,\n        type: FieldType.number,\n        config: { color: { mode: 'continuous-GrYlRd' }, displayName: 'Self time / Trace duration' },\n      },\n    ],\n    meta: {\n      preferredVisualisationType: 'nodeGraph',\n    },\n  });\n\n  const edgesFrame = new MutableDataFrame({\n    fields: [\n      { name: Fields.id, type: FieldType.string },\n      { name: Fields.target, type: FieldType.string },\n      { name: Fields.source, type: FieldType.string },\n    ],\n    meta: {\n      preferredVisualisationType: 'nodeGraph',\n    },\n  });\n\n  return [nodesFrame, edgesFrame];\n}\n","import useEffectOnce from './useEffectOnce';\nvar useMount = function (fn) {\n    useEffectOnce(function () {\n        fn();\n    });\n};\nexport default useMount;\n"],"sourceRoot":""}