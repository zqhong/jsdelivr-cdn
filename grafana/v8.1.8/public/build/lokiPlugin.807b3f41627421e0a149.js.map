{"version":3,"sources":["webpack:///./node_modules/uuid/dist/esm-browser/parse.js","webpack:///./node_modules/uuid/dist/esm-browser/sha1.js","webpack:///./node_modules/uuid/dist/esm-browser/v5.js","webpack:///./node_modules/uuid/dist/esm-browser/v35.js","webpack:///./public/app/plugins/datasource/loki/query_utils.ts","webpack:///./public/app/plugins/datasource/loki/types.ts","webpack:///./public/app/plugins/datasource/loki/result_transformer.ts","webpack:///./node_modules/rxjs/_esm5/internal/observable/dom/WebSocketSubject.js","webpack:///./public/app/plugins/datasource/loki/live_streams.ts","webpack:///./node_modules/rxjs/_esm5/internal/observable/dom/webSocket.js","webpack:///./public/app/plugins/datasource/loki/importing/fromGraphite.ts","webpack:///./public/app/plugins/datasource/loki/language_provider.ts","webpack:///./public/app/plugins/datasource/loki/datasource.ts","webpack:///./public/app/plugins/datasource/loki/components/LokiCheatSheet.tsx","webpack:///./public/app/plugins/datasource/loki/components/LokiExploreQueryEditor.tsx","webpack:///./public/app/plugins/datasource/loki/components/LokiQueryEditor.tsx","webpack:///./public/app/plugins/datasource/loki/components/LokiQueryEditorForAlerting.tsx","webpack:///./public/app/plugins/datasource/loki/components/LokiQueryEditorByApp.tsx","webpack:///./public/app/plugins/datasource/loki/LokiAnnotationsQueryCtrl.tsx","webpack:///./public/app/plugins/datasource/loki/configuration/MaxLinesField.tsx","webpack:///./public/app/plugins/datasource/loki/configuration/DerivedField.tsx","webpack:///./public/app/plugins/datasource/loki/configuration/DebugSection.tsx","webpack:///./public/app/plugins/datasource/loki/configuration/DerivedFields.tsx","webpack:///./public/app/plugins/datasource/loki/configuration/ConfigEditor.tsx","webpack:///./public/app/plugins/datasource/loki/module.ts","webpack:///./public/app/plugins/datasource/loki/syntax.ts","webpack:///./node_modules/react-use/esm/usePrevious.js"],"names":["uuid","validate","TypeError","v","arr","Uint8Array","parseInt","slice","s","x","y","z","ROTL","n","generateUUID","value","namespace","buf","offset","str","unescape","encodeURIComponent","bytes","i","length","push","charCodeAt","stringToBytes","set","hashfunc","version","stringify","name","err","DNS","URL","v35","K","H","msg","Array","isArray","prototype","call","l","N","Math","ceil","M","_i","Uint32Array","j","pow","floor","_i2","W","t","_t","a","b","c","d","e","_t2","T","getHighlighterExpressionsFromQuery","input","expression","results","filterStart","search","filterOperator","substr","skip","filterEnd","filterTerm","trim","quotedTerm","match","backtickedTerm","term","unwrappedFilterTerm","replace","escapeRegExp","LokiResultType","lokiStreamResultToDataFrame","stream","reverse","refId","labels","labelsString","Object","entries","map","key","val","sort","join","times","ArrayVector","timesNs","lines","uids","usedUids","ts","line","values","add","Date","toISOString","createUid","dataFrame","fields","type","FieldType","time","config","displayName","string","mutableDataFrame","MutableDataFrame","constructDataFrame","id","uuidv5","newCount","lokiMatrixToTimeSeries","matrixResult","options","labelData","label","undefined","isEmpty","legendFormat","metricName","__name__","labelPart","getOriginalMetricName","aliasPattern","getTemplateSrv","scopedVars","aliasData","_","g1","query","createMetricLabel","metric","target","title","datapoints","lokiPointsToTimeseriesPoints","tags","meta","data","stepMs","step","baseTimestampMs","start","datapointValue","parseFloat","isNaN","timestamp","endTimestamp","end","lokiResultsToTableModel","lokiResults","resultCount","valueWithRefId","TableModel","sortedLabels","Set","reduce","acc","cur","concat","keys","table","columns","text","filterable","number","forEach","series","newSeries","rows","lokiStreamsToDataFrames","response","limit","result","stats","section","unit","test","capitalize","m","toLowerCase","lokiStatsToMetaStat","searchWords","selector","expr","custom","lokiQueryStatKey","preferredVisualisationType","enhanceDataFrame","some","f","error","derivedFields","derivedFieldsGrouped","groupBy","newFields","fieldFromDerivedFieldConfig","DataFrameView","row","field","logMatch","matcherRegex","derivedFieldConfigs","dataSourceSrv","getDataSourceSrv","dataLinks","derivedFieldConfig","datasourceUid","dsSettings","getInstanceSettings","url","internal","datasourceName","links","rangeQueryResponseToTimeSeries","responseListLength","transformerOptions","format","resultType","Vector","vecResult","Matrix","DEFAULT_WEBSOCKET_CONFIG","deserializer","JSON","parse","serializer","_super","WebSocketSubject","urlConfigOrSource","destination","_this","this","Observable","source","_config","_output","Subject","hasOwnProperty","WebSocketCtor","WebSocket","Error","ReplaySubject","lift","operator","sock","_resetState","_socket","multiplex","subMsg","unsubMsg","messageFilter","self","observer","next","subscription","subscribe","complete","unsubscribe","_connectSocket","_a","protocol","binaryType","socket","Subscription","readyState","close","onopen","openObserver","queue","Subscriber","create","send","closingObserver","code","reason","onerror","onclose","closeObserver","wasClean","onmessage","_subscribe","subscriber","observers","LiveStreams","getStream","retryInterval","streams","CircularDataFrame","capacity","size","addField","parseLabels","other","pipe","baseLabels","tsField","tsNsField","lineField","labelsField","idField","unique","findUniqueLabels","allLabelsString","appendResponseToBufferedData","retryWhen","attempts","mergeMap","retryAttempt","console","warn","timer","throwError","finalize","GRAPHITE_TO_LOKI_OPERATOR","fromGraphite","graphiteQuery","matchingFound","seriesByTagUsed","tag","targetNodes","segments","segment","mappings","filter","mapping","matchers","every","matcher","index","labelName","converted","includes","pairs","DEFAULT_KEYS","RATE_RANGES","sortValue","wrapLabel","filterText","LokiLanguageProvider","LanguageProvider","constructor","datasource","initialValues","super","LRU","async","params","metadataRequest","startTask","fetchLabels","then","started","context","suggestions","getEmptyCompletionItems","getTermCompletionItems","prefixMatch","items","FUNCTIONS","suggestion","kind","PIPE_OPERATORS","PIPE_PARSERS","getTimeRangeParams","cacheKey","generateCacheKey","seriesCache","get","request","processLabels","labelKeys","labelFetchTs","assign","getSyntax","syntax","getLabelKeys","wrapperClasses","prefix","emptyResult","empty","document","selectedLines","getTextsAtRange","selection","currentLine","first","getText","nextCharacter","anchor","tokenRecognized","prefixUnrecognized","noSuffix","safePrefix","isNextOperand","getRangeCompletionItems","getLabelCompletionItems","getPipeCompletionItem","getBeginningCompletionItems","history","historyItems","chain","h","uniq","take","item","cutoffTs","now","historyForItem","hint","recent","dateTime","fromNow","documentation","addHistoryMetadata","skipSort","labelKey","anchorBlock","cursorOffset","isValueStart","parsedSelector","parseSelector","existingKeys","labelValues","getLabelValues","getSeriesLabels","possibleKeys","difference","newSuggestion","queries","originDataSource","datasourceType","Promise","all","importPrometheusQuery","rest","graphiteDataSource","model","GraphiteQueryModel","textEditor","parseTarget","getImportQueryConfiguration","loki","selectorMatch","selectorRegexp","labelRegexp","labelsToKeep","lookupsDisabled","fetchSeriesLabels","timeRange","valueOf","res","forceRefresh","param","roundTime","nanos","fetchLabelValues","rangeParams","labelsCache","DEFAULT_QUERY_PARAMS","direction","LokiDatasource","DataSourceApi","instanceSettings","templateSrv","timeSrv","getTimeSrv","timeNs","getTime","range","to","queryLimit","isMetricsQuery","maxDataPoints","maxLines","min","Infinity","_request","Stream","jsonData","catchError","throwUnless","status","liveStreaming","runLiveQuery","createRangeQuery","switchMap","of","processRangeQueryResponse","liveTarget","createLiveTarget","state","LoadingState","Streaming","prepareLogRowContextQueryTarget","message","statusText","toPromise","commonTargetOptions","nsTimestamp","FieldCache","getFieldByName","rowIndex","timeEpochMs","languageProvider","settingsData","apiUrl","baseUrl","serializeParams","withCredentials","basicAuth","headers","Authorization","req","getBackendSrv","fetch","subQueries","getRangeScopedVars","filteredTargets","targets","hide","addAdHocFilters","interpolateQueryExpr","instant","runInstantQuery","runRangeQuery","Done","merge","startNs","from","endNs","rangeMs","adjustedInterval","adjustInterval","intervalMs","convertToWebSocketUrl","msRange","diff","sRange","round","__range_ms","__range_s","__range","interpolateVariablesInQueries","expandedQueries","getQueryDisplayText","importQueries","hideFromInspector","resolve","interpolated","processMetricFindQuery","labelNamesQuery","labelValuesSeriesQuery","labelValuesQuery","variable","multi","includeAll","lokiRegularEscape","lokiSpecialRegexEscape","lodashMap","modifyQuery","action","addLabelToQuery","getHighlighterExpression","date","roundUp","dateMath","testDatasource","tagKeys","titleFormat","textFormat","annotation","interpolatedExpr","annotations","splitKeys","split","frame","String","apply","renderTemplate","showContextToggle","condition","processError","cloneDeep","interval","max","queryExpr","getAdhocFilters","parsers","parser","RegExp","queryHasPipeParser","toString","addParsedLabelToQuery","_match","Prism","tokenize","DEFAULT_EXAMPLES","PREFERRED_LABELS","LOGQL_EXAMPLES","LokiCheatSheet","PureComponent","userExamples","provider","props","preferredLabel","find","shuffle","setState","scheduleUserLabelChecking","componentDidMount","componentWillUnmount","clearTimeout","userLabelTimer","setTimeout","checkUserLabels","renderExpression","onClickExample","className","onClick","render","example","href","LokiExploreQueryEditor","onChange","onRunQuery","LokiQueryField","onBlur","ExtraFieldElement","LokiOptionFields","queryType","lineLimitValue","memo","LokiQueryEditor","legendField","width","tooltip","placeholder","nextQuery","currentTarget","data-testid","testIds","editor","runOnBlur","LokiQueryEditorForAlerting","LokiQueryEditorByApp","app","CoreApp","CloudAlerting","LokiAnnotationsQueryCtrl","$scope","ctrl","onQueryChange","bind","FormField","LegacyForms","MaxLinesField","labelWidth","inputWidth","inputEl","event","spellCheck","Switch","getStyles","stylesFactory","css","nameField","regexField","DerivedField","onDelete","styles","showInternalLink","setShowInternalLink","useState","previousUid","usePrevious","useEffect","handleChange","variant","icon","preventDefault","newValue","checked","tracing","ds","uid","current","DebugSection","debugText","setDebugText","debugFields","testMatch","link","getFieldLinksForExplore","makeDebugFields","cx","DebugFields","DerivedFields","theme","infoText","spacing","colors","secondary","derivedField","useTheme2","showDebug","setShowDebug","newField","newDerivedFields","splice","DataLinkBuiltInVars","valueRaw","origin","VariableOrigin","Value","makeJsonUpdater","setMaxLines","setDerivedFields","plugin","DataSourcePlugin","Datasource","setQueryEditor","setConfigEditor","onOptionsChange","defaultUrl","dataSourceConfig","showAccessOptions","setExploreQueryField","setQueryEditorHelp","setAnnotationQueryCtrl","insertText","move","detail","tokenizer","comment","pattern","lookbehind","inside","alias","punctuation","greedy","function","ref"],"mappings":"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","file":"lokiPlugin.807b3f41627421e0a149.js","sourcesContent":["import validate from './validate.js';\n\nfunction parse(uuid) {\n  if (!validate(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  var v;\n  var arr = new Uint8Array(16); // Parse ########-....-....-....-............\n\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff; // Parse ........-####-....-....-............\n\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff; // Parse ........-....-####-....-............\n\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff; // Parse ........-....-....-####-............\n\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff; // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n\nexport default parse;","// Adapted from Chris Veness' SHA1 code at\n// http://www.movable-type.co.uk/scripts/sha1.html\nfunction f(s, x, y, z) {\n  switch (s) {\n    case 0:\n      return x & y ^ ~x & z;\n\n    case 1:\n      return x ^ y ^ z;\n\n    case 2:\n      return x & y ^ x & z ^ y & z;\n\n    case 3:\n      return x ^ y ^ z;\n  }\n}\n\nfunction ROTL(x, n) {\n  return x << n | x >>> 32 - n;\n}\n\nfunction sha1(bytes) {\n  var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];\n  var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n\n  if (typeof bytes === 'string') {\n    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = [];\n\n    for (var i = 0; i < msg.length; ++i) {\n      bytes.push(msg.charCodeAt(i));\n    }\n  } else if (!Array.isArray(bytes)) {\n    // Convert Array-like to Array\n    bytes = Array.prototype.slice.call(bytes);\n  }\n\n  bytes.push(0x80);\n  var l = bytes.length / 4 + 2;\n  var N = Math.ceil(l / 16);\n  var M = new Array(N);\n\n  for (var _i = 0; _i < N; ++_i) {\n    var arr = new Uint32Array(16);\n\n    for (var j = 0; j < 16; ++j) {\n      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];\n    }\n\n    M[_i] = arr;\n  }\n\n  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);\n  M[N - 1][14] = Math.floor(M[N - 1][14]);\n  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;\n\n  for (var _i2 = 0; _i2 < N; ++_i2) {\n    var W = new Uint32Array(80);\n\n    for (var t = 0; t < 16; ++t) {\n      W[t] = M[_i2][t];\n    }\n\n    for (var _t = 16; _t < 80; ++_t) {\n      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);\n    }\n\n    var a = H[0];\n    var b = H[1];\n    var c = H[2];\n    var d = H[3];\n    var e = H[4];\n\n    for (var _t2 = 0; _t2 < 80; ++_t2) {\n      var s = Math.floor(_t2 / 20);\n      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;\n      e = d;\n      d = c;\n      c = ROTL(b, 30) >>> 0;\n      b = a;\n      a = T;\n    }\n\n    H[0] = H[0] + a >>> 0;\n    H[1] = H[1] + b >>> 0;\n    H[2] = H[2] + c >>> 0;\n    H[3] = H[3] + d >>> 0;\n    H[4] = H[4] + e >>> 0;\n  }\n\n  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];\n}\n\nexport default sha1;","import v35 from './v35.js';\nimport sha1 from './sha1.js';\nvar v5 = v35('v5', 0x50, sha1);\nexport default v5;","import stringify from './stringify.js';\nimport parse from './parse.js';\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  var bytes = [];\n\n  for (var i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n\n  return bytes;\n}\n\nexport var DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nexport var URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nexport default function (name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n\n    if (typeof namespace === 'string') {\n      namespace = parse(namespace);\n    }\n\n    if (namespace.length !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    } // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n\n\n    var bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      offset = offset || 0;\n\n      for (var i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n\n      return buf;\n    }\n\n    return stringify(bytes);\n  } // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name; // eslint-disable-next-line no-empty\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}","import { escapeRegExp } from 'lodash';\nimport { PIPE_PARSERS } from './syntax';\n\nexport function formatQuery(selector: string | undefined): string {\n  return `${selector || ''}`.trim();\n}\n\n/**\n * Returns search terms from a LogQL query.\n * E.g., `{} |= foo |=bar != baz` returns `['foo', 'bar']`.\n */\nexport function getHighlighterExpressionsFromQuery(input: string): string[] {\n  let expression = input;\n  const results = [];\n\n  // Consume filter expression from left to right\n  while (expression) {\n    const filterStart = expression.search(/\\|=|\\|~|!=|!~/);\n    // Nothing more to search\n    if (filterStart === -1) {\n      break;\n    }\n    // Drop terms for negative filters\n    const filterOperator = expression.substr(filterStart, 2);\n    const skip = expression.substr(filterStart).search(/!=|!~/) === 0;\n    expression = expression.substr(filterStart + 2);\n    if (skip) {\n      continue;\n    }\n    // Check if there is more chained\n    const filterEnd = expression.search(/\\|=|\\|~|!=|!~/);\n    let filterTerm;\n    if (filterEnd === -1) {\n      filterTerm = expression.trim();\n    } else {\n      filterTerm = expression.substr(0, filterEnd).trim();\n      expression = expression.substr(filterEnd);\n    }\n\n    const quotedTerm = filterTerm.match(/\"(.*?)\"/);\n    const backtickedTerm = filterTerm.match(/`(.*?)`/);\n    const term = quotedTerm || backtickedTerm;\n\n    if (term) {\n      const unwrappedFilterTerm = term[1];\n      const regexOperator = filterOperator === '|~';\n\n      // Only filter expressions with |~ operator are treated as regular expressions\n      if (regexOperator) {\n        // When using backticks, Loki doesn't require to escape special characters and we can just push regular expression to highlights array\n        // When using quotes, we have extra backslash escaping and we need to replace \\\\ with \\\n        results.push(backtickedTerm ? unwrappedFilterTerm : unwrappedFilterTerm.replace(/\\\\\\\\/g, '\\\\'));\n      } else {\n        // We need to escape this string so it is not matched as regular expression\n        results.push(escapeRegExp(unwrappedFilterTerm));\n      }\n    } else {\n      return results;\n    }\n  }\n\n  return results;\n}\n\nexport function queryHasPipeParser(expr: string): boolean {\n  const parsers = PIPE_PARSERS.map((parser) => `${parser.label}`).join('|');\n  const regexp = new RegExp(`\\\\\\|\\\\\\s?(${parsers})`);\n  return regexp.test(expr);\n}\n\nexport function addParsedLabelToQuery(expr: string, key: string, value: string | number, operator: string) {\n  return expr + ` | ${key}${operator}\"${value.toString()}\"`;\n}\n","import { DataQuery, DataSourceJsonData, QueryResultMeta, ScopedVars } from '@grafana/data';\n\nexport interface LokiInstantQueryRequest {\n  query: string;\n  limit?: number;\n  time?: string;\n  direction?: 'BACKWARD' | 'FORWARD';\n}\n\nexport interface LokiRangeQueryRequest {\n  query: string;\n  limit?: number;\n  start?: number;\n  end?: number;\n  step?: number;\n  direction?: 'BACKWARD' | 'FORWARD';\n}\n\nexport enum LokiResultType {\n  Stream = 'streams',\n  Vector = 'vector',\n  Matrix = 'matrix',\n}\n\nexport interface LokiQuery extends DataQuery {\n  expr: string;\n  query?: string;\n  format?: string;\n  reverse?: boolean;\n  legendFormat?: string;\n  valueWithRefId?: boolean;\n  maxLines?: number;\n  range?: boolean;\n  instant?: boolean;\n}\n\nexport interface LokiOptions extends DataSourceJsonData {\n  maxLines?: string;\n  derivedFields?: DerivedFieldConfig[];\n}\n\nexport interface LokiStats {\n  [component: string]: {\n    [label: string]: number;\n  };\n}\n\nexport interface LokiVectorResult {\n  metric: { [label: string]: string };\n  value: [number, string];\n}\n\nexport interface LokiVectorResponse {\n  status: string;\n  data: {\n    resultType: LokiResultType.Vector;\n    result: LokiVectorResult[];\n    stats?: LokiStats;\n  };\n}\n\nexport interface LokiMatrixResult {\n  metric: Record<string, string>;\n  values: Array<[number, string]>;\n}\n\nexport interface LokiMatrixResponse {\n  status: string;\n  data: {\n    resultType: LokiResultType.Matrix;\n    result: LokiMatrixResult[];\n    stats?: LokiStats;\n  };\n}\n\nexport interface LokiStreamResult {\n  stream: Record<string, string>;\n  values: Array<[string, string]>;\n}\n\nexport interface LokiStreamResponse {\n  status: string;\n  data: {\n    resultType: LokiResultType.Stream;\n    result: LokiStreamResult[];\n    stats?: LokiStats;\n  };\n}\n\nexport interface LokiTailResponse {\n  streams: LokiStreamResult[];\n  dropped_entries?: Array<{\n    labels: Record<string, string>;\n    timestamp: string;\n  }> | null;\n}\n\nexport type LokiResult = LokiVectorResult | LokiMatrixResult | LokiStreamResult;\nexport type LokiResponse = LokiVectorResponse | LokiMatrixResponse | LokiStreamResponse;\n\nexport interface LokiLogsStreamEntry {\n  line: string;\n  ts: string;\n}\n\nexport interface LokiExpression {\n  regexp: string;\n  query: string;\n}\n\nexport type DerivedFieldConfig = {\n  matcherRegex: string;\n  name: string;\n  url?: string;\n  datasourceUid?: string;\n};\n\nexport interface TransformerOptions {\n  format?: string;\n  legendFormat?: string;\n  step: number;\n  start: number;\n  end: number;\n  query: string;\n  responseListLength: number;\n  refId: string;\n  scopedVars: ScopedVars;\n  meta?: QueryResultMeta;\n  valueWithRefId?: boolean;\n}\n","import { capitalize, groupBy, isEmpty } from 'lodash';\nimport { v5 as uuidv5 } from 'uuid';\nimport { of } from 'rxjs';\n\nimport {\n  FieldType,\n  TimeSeries,\n  Labels,\n  DataFrame,\n  ArrayVector,\n  MutableDataFrame,\n  findUniqueLabels,\n  DataFrameView,\n  DataLink,\n  Field,\n  QueryResultMetaStat,\n  QueryResultMeta,\n  TimeSeriesValue,\n  ScopedVars,\n} from '@grafana/data';\n\nimport { getTemplateSrv, getDataSourceSrv } from '@grafana/runtime';\nimport TableModel from 'app/core/table_model';\nimport { formatQuery, getHighlighterExpressionsFromQuery } from './query_utils';\nimport {\n  LokiRangeQueryRequest,\n  LokiResponse,\n  LokiMatrixResult,\n  LokiVectorResult,\n  TransformerOptions,\n  LokiResultType,\n  LokiStreamResult,\n  LokiTailResponse,\n  LokiQuery,\n  LokiOptions,\n  DerivedFieldConfig,\n  LokiStreamResponse,\n  LokiStats,\n} from './types';\n\nconst UUID_NAMESPACE = '6ec946da-0f49-47a8-983a-1d76d17e7c92';\n\n/**\n * Transforms LokiStreamResult structure into a dataFrame. Used when doing standard queries and newer version of Loki.\n */\nexport function lokiStreamResultToDataFrame(stream: LokiStreamResult, reverse?: boolean, refId?: string): DataFrame {\n  const labels: Labels = stream.stream;\n  const labelsString = Object.entries(labels)\n    .map(([key, val]) => `${key}=\"${val}\"`)\n    .sort()\n    .join('');\n\n  const times = new ArrayVector<string>([]);\n  const timesNs = new ArrayVector<string>([]);\n  const lines = new ArrayVector<string>([]);\n  const uids = new ArrayVector<string>([]);\n\n  // We need to store and track all used uids to ensure that uids are unique\n  const usedUids: { string?: number } = {};\n\n  for (const [ts, line] of stream.values) {\n    // num ns epoch in string, we convert it to iso string here so it matches old format\n    times.add(new Date(parseInt(ts.substr(0, ts.length - 6), 10)).toISOString());\n    timesNs.add(ts);\n    lines.add(line);\n    uids.add(createUid(ts, labelsString, line, usedUids, refId));\n  }\n\n  return constructDataFrame(times, timesNs, lines, uids, labels, reverse, refId);\n}\n\n/**\n * Constructs dataFrame with supplied fields and other data. Also makes sure it is properly reversed if needed.\n */\nfunction constructDataFrame(\n  times: ArrayVector<string>,\n  timesNs: ArrayVector<string>,\n  lines: ArrayVector<string>,\n  uids: ArrayVector<string>,\n  labels: Labels,\n  reverse?: boolean,\n  refId?: string\n) {\n  const dataFrame = {\n    refId,\n    fields: [\n      { name: 'ts', type: FieldType.time, config: { displayName: 'Time' }, values: times }, // Time\n      { name: 'line', type: FieldType.string, config: {}, values: lines, labels }, // Line - needs to be the first field with string type\n      { name: 'id', type: FieldType.string, config: {}, values: uids },\n      { name: 'tsNs', type: FieldType.time, config: { displayName: 'Time ns' }, values: timesNs }, // Time\n    ],\n    length: times.length,\n  };\n\n  if (reverse) {\n    const mutableDataFrame = new MutableDataFrame(dataFrame);\n    mutableDataFrame.reverse();\n    return mutableDataFrame;\n  }\n\n  return dataFrame;\n}\n\n/**\n * Transform LokiResponse data and appends it to MutableDataFrame. Used for streaming where the dataFrame can be\n * a CircularDataFrame creating a fixed size rolling buffer.\n * TODO: Probably could be unified with the logStreamToDataFrame function.\n * @param response\n * @param data Needs to have ts, line, labels, id as fields\n */\nexport function appendResponseToBufferedData(response: LokiTailResponse, data: MutableDataFrame) {\n  // Should we do anything with: response.dropped_entries?\n\n  const streams: LokiStreamResult[] = response.streams;\n  if (!streams || !streams.length) {\n    return;\n  }\n\n  let baseLabels: Labels = {};\n  for (const f of data.fields) {\n    if (f.type === FieldType.string) {\n      if (f.labels) {\n        baseLabels = f.labels;\n      }\n      break;\n    }\n  }\n\n  const tsField = data.fields[0];\n  const tsNsField = data.fields[1];\n  const lineField = data.fields[2];\n  const labelsField = data.fields[3];\n  const idField = data.fields[4];\n\n  // We are comparing used ids only within the received stream. This could be a problem if the same line + labels + nanosecond timestamp came in 2 separate batches.\n  // As this is very unlikely, and the result would only affect live-tailing css animation we have decided to not compare all received uids from data param as this would slow down processing.\n  const usedUids: { string?: number } = {};\n\n  for (const stream of streams) {\n    // Find unique labels\n    const unique = findUniqueLabels(stream.stream, baseLabels);\n    const allLabelsString = Object.entries(stream.stream)\n      .map(([key, val]) => `${key}=\"${val}\"`)\n      .sort()\n      .join('');\n\n    // Add each line\n    for (const [ts, line] of stream.values) {\n      tsField.values.add(new Date(parseInt(ts.substr(0, ts.length - 6), 10)).toISOString());\n      tsNsField.values.add(ts);\n      lineField.values.add(line);\n      labelsField.values.add(unique);\n      idField.values.add(createUid(ts, allLabelsString, line, usedUids, data.refId));\n    }\n  }\n}\n\nfunction createUid(ts: string, labelsString: string, line: string, usedUids: any, refId?: string): string {\n  // Generate id as hashed nanosecond timestamp, labels and line (this does not have to be unique)\n  let id = uuidv5(`${ts}_${labelsString}_${line}`, UUID_NAMESPACE);\n\n  // Check if generated id is unique\n  // If not and we've already used it, append it's count after it\n  if (id in usedUids) {\n    // Increase the count\n    const newCount = usedUids[id] + 1;\n    usedUids[id] = newCount;\n    // Append count to generated id to make it unique\n    id = `${id}_${newCount}`;\n  } else {\n    // If id is unique and wasn't used, add it to usedUids and start count at 0\n    usedUids[id] = 0;\n  }\n  // Return unique id\n  if (refId) {\n    return `${id}_${refId}`;\n  }\n  return id;\n}\n\nfunction lokiMatrixToTimeSeries(matrixResult: LokiMatrixResult, options: TransformerOptions): TimeSeries {\n  const name = createMetricLabel(matrixResult.metric, options);\n  return {\n    target: name,\n    title: name,\n    datapoints: lokiPointsToTimeseriesPoints(matrixResult.values, options),\n    tags: matrixResult.metric,\n    meta: options.meta,\n    refId: options.refId,\n  };\n}\n\nexport function lokiPointsToTimeseriesPoints(\n  data: Array<[number, string]>,\n  options: TransformerOptions\n): TimeSeriesValue[][] {\n  const stepMs = options.step * 1000;\n  const datapoints: TimeSeriesValue[][] = [];\n\n  let baseTimestampMs = options.start / 1e6;\n  for (const [time, value] of data) {\n    let datapointValue: TimeSeriesValue = parseFloat(value);\n\n    if (isNaN(datapointValue)) {\n      datapointValue = null;\n    }\n\n    const timestamp = time * 1000;\n    for (let t = baseTimestampMs; t < timestamp; t += stepMs) {\n      datapoints.push([null, t]);\n    }\n\n    baseTimestampMs = timestamp + stepMs;\n    datapoints.push([datapointValue, timestamp]);\n  }\n\n  const endTimestamp = options.end / 1e6;\n  for (let t = baseTimestampMs; t <= endTimestamp; t += stepMs) {\n    datapoints.push([null, t]);\n  }\n\n  return datapoints;\n}\n\nexport function lokiResultsToTableModel(\n  lokiResults: Array<LokiMatrixResult | LokiVectorResult>,\n  resultCount: number,\n  refId: string,\n  meta: QueryResultMeta,\n  valueWithRefId?: boolean\n): TableModel {\n  if (!lokiResults || lokiResults.length === 0) {\n    return new TableModel();\n  }\n\n  // Collect all labels across all metrics\n  const metricLabels: Set<string> = new Set<string>(\n    lokiResults.reduce((acc, cur) => acc.concat(Object.keys(cur.metric)), [] as string[])\n  );\n\n  // Sort metric labels, create columns for them and record their index\n  const sortedLabels = [...metricLabels.values()].sort();\n  const table = new TableModel();\n  table.refId = refId;\n  table.meta = meta;\n  table.columns = [\n    { text: 'Time', type: FieldType.time },\n    ...sortedLabels.map((label) => ({ text: label, filterable: true, type: FieldType.string })),\n    { text: resultCount > 1 || valueWithRefId ? `Value #${refId}` : 'Value', type: FieldType.number },\n  ];\n\n  // Populate rows, set value to empty string when label not present.\n  lokiResults.forEach((series) => {\n    const newSeries: LokiMatrixResult = {\n      metric: series.metric,\n      values: (series as LokiVectorResult).value\n        ? [(series as LokiVectorResult).value]\n        : (series as LokiMatrixResult).values,\n    };\n\n    if (!newSeries.values) {\n      return;\n    }\n\n    if (!newSeries.metric) {\n      table.rows.concat(newSeries.values.map(([a, b]) => [a * 1000, parseFloat(b)]));\n    } else {\n      table.rows.push(\n        ...newSeries.values.map(([a, b]) => [\n          a * 1000,\n          ...sortedLabels.map((label) => newSeries.metric[label] || ''),\n          parseFloat(b),\n        ])\n      );\n    }\n  });\n\n  return table;\n}\n\nexport function createMetricLabel(labelData: { [key: string]: string }, options?: TransformerOptions) {\n  let label =\n    options === undefined || isEmpty(options.legendFormat)\n      ? getOriginalMetricName(labelData)\n      : renderTemplate(getTemplateSrv().replace(options.legendFormat ?? '', options.scopedVars), labelData);\n\n  if (!label && options) {\n    label = options.query;\n  }\n  return label;\n}\n\nfunction renderTemplate(aliasPattern: string, aliasData: { [key: string]: string }) {\n  const aliasRegex = /\\{\\{\\s*(.+?)\\s*\\}\\}/g;\n  return aliasPattern.replace(aliasRegex, (_, g1) => (aliasData[g1] ? aliasData[g1] : g1));\n}\n\nfunction getOriginalMetricName(labelData: { [key: string]: string }) {\n  const metricName = labelData.__name__ || '';\n  delete labelData.__name__;\n  const labelPart = Object.entries(labelData)\n    .map((label) => `${label[0]}=\"${label[1]}\"`)\n    .join(',');\n  return `${metricName}{${labelPart}}`;\n}\n\nexport function decamelize(s: string): string {\n  return s.replace(/[A-Z]/g, (m) => ` ${m.toLowerCase()}`);\n}\n\n// Turn loki stats { metric: value } into meta stat { title: metric, value: value }\nfunction lokiStatsToMetaStat(stats: LokiStats | undefined): QueryResultMetaStat[] {\n  const result: QueryResultMetaStat[] = [];\n\n  if (!stats) {\n    return result;\n  }\n\n  for (const section in stats) {\n    const values = stats[section];\n    for (const label in values) {\n      const value = values[label];\n      let unit;\n      if (/time/i.test(label) && value) {\n        unit = 's';\n      } else if (/bytes.*persecond/i.test(label)) {\n        unit = 'Bps';\n      } else if (/bytes/i.test(label)) {\n        unit = 'decbytes';\n      }\n      const title = `${capitalize(section)}: ${decamelize(label)}`;\n      result.push({ displayName: title, value, unit });\n    }\n  }\n\n  return result;\n}\n\nexport function lokiStreamsToDataFrames(\n  response: LokiStreamResponse,\n  target: { refId: string; expr?: string },\n  limit: number,\n  config: LokiOptions,\n  reverse = false\n): DataFrame[] {\n  const data = limit > 0 ? response.data.result : [];\n  const stats: QueryResultMetaStat[] = lokiStatsToMetaStat(response.data.stats);\n  // Use custom mechanism to identify which stat we want to promote to label\n  const custom = {\n    lokiQueryStatKey: 'Summary: total bytes processed',\n  };\n\n  const meta: QueryResultMeta = {\n    searchWords: getHighlighterExpressionsFromQuery(formatQuery(target.expr)),\n    limit,\n    stats,\n    custom,\n    preferredVisualisationType: 'logs',\n  };\n\n  const series: DataFrame[] = data.map((stream) => {\n    const dataFrame = lokiStreamResultToDataFrame(stream, reverse, target.refId);\n    enhanceDataFrame(dataFrame, config);\n\n    if (meta.custom && dataFrame.fields.some((f) => f.labels && Object.keys(f.labels).some((l) => l === '__error__'))) {\n      meta.custom.error = 'Error when parsing some of the logs';\n    }\n\n    return {\n      ...dataFrame,\n      refId: target.refId,\n      meta,\n    };\n  });\n\n  if (stats.length && !data.length) {\n    return [\n      {\n        fields: [],\n        length: 0,\n        refId: target.refId,\n        meta,\n      },\n    ];\n  }\n\n  return series;\n}\n\n/**\n * Adds new fields and DataLinks to DataFrame based on DataSource instance config.\n */\nexport const enhanceDataFrame = (dataFrame: DataFrame, config: LokiOptions | null): void => {\n  if (!config) {\n    return;\n  }\n\n  const derivedFields = config.derivedFields ?? [];\n  if (!derivedFields.length) {\n    return;\n  }\n  const derivedFieldsGrouped = groupBy(derivedFields, 'name');\n\n  const newFields = Object.values(derivedFieldsGrouped).map(fieldFromDerivedFieldConfig);\n\n  const view = new DataFrameView(dataFrame);\n  view.forEach((row: { line: string }) => {\n    for (const field of newFields) {\n      const logMatch = row.line.match(derivedFieldsGrouped[field.name][0].matcherRegex);\n      field.values.add(logMatch && logMatch[1]);\n    }\n  });\n\n  dataFrame.fields = [...dataFrame.fields, ...newFields];\n};\n\n/**\n * Transform derivedField config into dataframe field with config that contains link.\n */\nfunction fieldFromDerivedFieldConfig(derivedFieldConfigs: DerivedFieldConfig[]): Field<any, ArrayVector> {\n  const dataSourceSrv = getDataSourceSrv();\n\n  const dataLinks = derivedFieldConfigs.reduce((acc, derivedFieldConfig) => {\n    // Having field.datasourceUid means it is an internal link.\n    if (derivedFieldConfig.datasourceUid) {\n      const dsSettings = dataSourceSrv.getInstanceSettings(derivedFieldConfig.datasourceUid);\n\n      acc.push({\n        // Will be filled out later\n        title: '',\n        url: '',\n        // This is hardcoded for Jaeger or Zipkin not way right now to specify datasource specific query object\n        internal: {\n          query: { query: derivedFieldConfig.url },\n          datasourceUid: derivedFieldConfig.datasourceUid,\n          datasourceName: dsSettings?.name ?? 'Data source not found',\n        },\n      });\n    } else if (derivedFieldConfig.url) {\n      acc.push({\n        // We do not know what title to give here so we count on presentation layer to create a title from metadata.\n        title: '',\n        // This is hardcoded for Jaeger or Zipkin not way right now to specify datasource specific query object\n        url: derivedFieldConfig.url,\n      });\n    }\n    return acc;\n  }, [] as DataLink[]);\n\n  return {\n    name: derivedFieldConfigs[0].name,\n    type: FieldType.string,\n    config: {\n      links: dataLinks,\n    },\n    // We are adding values later on\n    values: new ArrayVector<string>([]),\n  };\n}\n\nexport function rangeQueryResponseToTimeSeries(\n  response: LokiResponse,\n  query: LokiRangeQueryRequest,\n  target: LokiQuery,\n  responseListLength: number,\n  scopedVars: ScopedVars\n): TimeSeries[] {\n  /** Show results of Loki metric queries only in graph */\n  const meta: QueryResultMeta = {\n    preferredVisualisationType: 'graph',\n  };\n  const transformerOptions: TransformerOptions = {\n    format: target.format,\n    legendFormat: target.legendFormat ?? '',\n    start: query.start!,\n    end: query.end!,\n    step: query.step!,\n    query: query.query,\n    responseListLength,\n    refId: target.refId,\n    meta,\n    valueWithRefId: target.valueWithRefId,\n    scopedVars,\n  };\n\n  switch (response.data.resultType) {\n    case LokiResultType.Vector:\n      return response.data.result.map((vecResult) =>\n        lokiMatrixToTimeSeries({ metric: vecResult.metric, values: [vecResult.value] }, transformerOptions)\n      );\n    case LokiResultType.Matrix:\n      return response.data.result.map((matrixResult) => lokiMatrixToTimeSeries(matrixResult, transformerOptions));\n    default:\n      return [];\n  }\n}\n\nexport function processRangeQueryResponse(\n  response: LokiResponse,\n  target: LokiQuery,\n  query: LokiRangeQueryRequest,\n  responseListLength: number,\n  limit: number,\n  config: LokiOptions,\n  scopedVars: ScopedVars,\n  reverse = false\n) {\n  switch (response.data.resultType) {\n    case LokiResultType.Stream:\n      return of({\n        data: lokiStreamsToDataFrames(response as LokiStreamResponse, target, limit, config, reverse),\n        key: `${target.refId}_log`,\n      });\n\n    case LokiResultType.Vector:\n    case LokiResultType.Matrix:\n      return of({\n        data: rangeQueryResponseToTimeSeries(\n          response,\n          query,\n          {\n            ...target,\n            format: 'time_series',\n          },\n          responseListLength,\n          scopedVars\n        ),\n        key: target.refId,\n      });\n    default:\n      throw new Error(`Unknown result type \"${(response.data as any).resultType}\".`);\n  }\n}\n","/** PURE_IMPORTS_START tslib,_.._Subject,_.._Subscriber,_.._Observable,_.._Subscription,_.._ReplaySubject PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subject, AnonymousSubject } from '../../Subject';\nimport { Subscriber } from '../../Subscriber';\nimport { Observable } from '../../Observable';\nimport { Subscription } from '../../Subscription';\nimport { ReplaySubject } from '../../ReplaySubject';\nvar DEFAULT_WEBSOCKET_CONFIG = {\n    url: '',\n    deserializer: function (e) { return JSON.parse(e.data); },\n    serializer: function (value) { return JSON.stringify(value); },\n};\nvar WEBSOCKETSUBJECT_INVALID_ERROR_OBJECT = 'WebSocketSubject.error must be called with an object with an error code, and an optional reason: { code: number, reason: string }';\nvar WebSocketSubject = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(WebSocketSubject, _super);\n    function WebSocketSubject(urlConfigOrSource, destination) {\n        var _this = _super.call(this) || this;\n        if (urlConfigOrSource instanceof Observable) {\n            _this.destination = destination;\n            _this.source = urlConfigOrSource;\n        }\n        else {\n            var config = _this._config = tslib_1.__assign({}, DEFAULT_WEBSOCKET_CONFIG);\n            _this._output = new Subject();\n            if (typeof urlConfigOrSource === 'string') {\n                config.url = urlConfigOrSource;\n            }\n            else {\n                for (var key in urlConfigOrSource) {\n                    if (urlConfigOrSource.hasOwnProperty(key)) {\n                        config[key] = urlConfigOrSource[key];\n                    }\n                }\n            }\n            if (!config.WebSocketCtor && WebSocket) {\n                config.WebSocketCtor = WebSocket;\n            }\n            else if (!config.WebSocketCtor) {\n                throw new Error('no WebSocket constructor can be found');\n            }\n            _this.destination = new ReplaySubject();\n        }\n        return _this;\n    }\n    WebSocketSubject.prototype.lift = function (operator) {\n        var sock = new WebSocketSubject(this._config, this.destination);\n        sock.operator = operator;\n        sock.source = this;\n        return sock;\n    };\n    WebSocketSubject.prototype._resetState = function () {\n        this._socket = null;\n        if (!this.source) {\n            this.destination = new ReplaySubject();\n        }\n        this._output = new Subject();\n    };\n    WebSocketSubject.prototype.multiplex = function (subMsg, unsubMsg, messageFilter) {\n        var self = this;\n        return new Observable(function (observer) {\n            try {\n                self.next(subMsg());\n            }\n            catch (err) {\n                observer.error(err);\n            }\n            var subscription = self.subscribe(function (x) {\n                try {\n                    if (messageFilter(x)) {\n                        observer.next(x);\n                    }\n                }\n                catch (err) {\n                    observer.error(err);\n                }\n            }, function (err) { return observer.error(err); }, function () { return observer.complete(); });\n            return function () {\n                try {\n                    self.next(unsubMsg());\n                }\n                catch (err) {\n                    observer.error(err);\n                }\n                subscription.unsubscribe();\n            };\n        });\n    };\n    WebSocketSubject.prototype._connectSocket = function () {\n        var _this = this;\n        var _a = this._config, WebSocketCtor = _a.WebSocketCtor, protocol = _a.protocol, url = _a.url, binaryType = _a.binaryType;\n        var observer = this._output;\n        var socket = null;\n        try {\n            socket = protocol ?\n                new WebSocketCtor(url, protocol) :\n                new WebSocketCtor(url);\n            this._socket = socket;\n            if (binaryType) {\n                this._socket.binaryType = binaryType;\n            }\n        }\n        catch (e) {\n            observer.error(e);\n            return;\n        }\n        var subscription = new Subscription(function () {\n            _this._socket = null;\n            if (socket && socket.readyState === 1) {\n                socket.close();\n            }\n        });\n        socket.onopen = function (e) {\n            var _socket = _this._socket;\n            if (!_socket) {\n                socket.close();\n                _this._resetState();\n                return;\n            }\n            var openObserver = _this._config.openObserver;\n            if (openObserver) {\n                openObserver.next(e);\n            }\n            var queue = _this.destination;\n            _this.destination = Subscriber.create(function (x) {\n                if (socket.readyState === 1) {\n                    try {\n                        var serializer = _this._config.serializer;\n                        socket.send(serializer(x));\n                    }\n                    catch (e) {\n                        _this.destination.error(e);\n                    }\n                }\n            }, function (e) {\n                var closingObserver = _this._config.closingObserver;\n                if (closingObserver) {\n                    closingObserver.next(undefined);\n                }\n                if (e && e.code) {\n                    socket.close(e.code, e.reason);\n                }\n                else {\n                    observer.error(new TypeError(WEBSOCKETSUBJECT_INVALID_ERROR_OBJECT));\n                }\n                _this._resetState();\n            }, function () {\n                var closingObserver = _this._config.closingObserver;\n                if (closingObserver) {\n                    closingObserver.next(undefined);\n                }\n                socket.close();\n                _this._resetState();\n            });\n            if (queue && queue instanceof ReplaySubject) {\n                subscription.add(queue.subscribe(_this.destination));\n            }\n        };\n        socket.onerror = function (e) {\n            _this._resetState();\n            observer.error(e);\n        };\n        socket.onclose = function (e) {\n            _this._resetState();\n            var closeObserver = _this._config.closeObserver;\n            if (closeObserver) {\n                closeObserver.next(e);\n            }\n            if (e.wasClean) {\n                observer.complete();\n            }\n            else {\n                observer.error(e);\n            }\n        };\n        socket.onmessage = function (e) {\n            try {\n                var deserializer = _this._config.deserializer;\n                observer.next(deserializer(e));\n            }\n            catch (err) {\n                observer.error(err);\n            }\n        };\n    };\n    WebSocketSubject.prototype._subscribe = function (subscriber) {\n        var _this = this;\n        var source = this.source;\n        if (source) {\n            return source.subscribe(subscriber);\n        }\n        if (!this._socket) {\n            this._connectSocket();\n        }\n        this._output.subscribe(subscriber);\n        subscriber.add(function () {\n            var _socket = _this._socket;\n            if (_this._output.observers.length === 0) {\n                if (_socket && _socket.readyState === 1) {\n                    _socket.close();\n                }\n                _this._resetState();\n            }\n        });\n        return subscriber;\n    };\n    WebSocketSubject.prototype.unsubscribe = function () {\n        var _socket = this._socket;\n        if (_socket && _socket.readyState === 1) {\n            _socket.close();\n        }\n        this._resetState();\n        _super.prototype.unsubscribe.call(this);\n    };\n    return WebSocketSubject;\n}(AnonymousSubject));\nexport { WebSocketSubject };\n//# sourceMappingURL=WebSocketSubject.js.map\n","import { DataFrame, FieldType, parseLabels, KeyValue, CircularDataFrame } from '@grafana/data';\nimport { Observable, throwError, timer } from 'rxjs';\nimport { webSocket } from 'rxjs/webSocket';\nimport { LokiTailResponse } from './types';\nimport { finalize, map, retryWhen, mergeMap } from 'rxjs/operators';\nimport { appendResponseToBufferedData } from './result_transformer';\n\n/**\n * Maps directly to a query in the UI (refId is key)\n */\nexport interface LokiLiveTarget {\n  query: string;\n  url: string;\n  refId: string;\n  size: number;\n}\n\n/**\n * Cache of websocket streams that can be returned as observable. In case there already is a stream for particular\n * target it is returned and on subscription returns the latest dataFrame.\n */\nexport class LiveStreams {\n  private streams: KeyValue<Observable<DataFrame[]>> = {};\n\n  getStream(target: LokiLiveTarget, retryInterval = 5000): Observable<DataFrame[]> {\n    let stream = this.streams[target.url];\n\n    if (stream) {\n      return stream;\n    }\n\n    const data = new CircularDataFrame({ capacity: target.size });\n    data.addField({ name: 'ts', type: FieldType.time, config: { displayName: 'Time' } });\n    data.addField({ name: 'tsNs', type: FieldType.time, config: { displayName: 'Time ns' } });\n    data.addField({ name: 'line', type: FieldType.string }).labels = parseLabels(target.query);\n    data.addField({ name: 'labels', type: FieldType.other }); // The labels for each line\n    data.addField({ name: 'id', type: FieldType.string });\n    data.meta = { ...data.meta, preferredVisualisationType: 'logs' };\n    data.refId = target.refId;\n\n    stream = webSocket(target.url).pipe(\n      map((response: LokiTailResponse) => {\n        appendResponseToBufferedData(response, data);\n        return [data];\n      }),\n      retryWhen((attempts: Observable<any>) =>\n        attempts.pipe(\n          mergeMap((error, i) => {\n            const retryAttempt = i + 1;\n            // Code 1006 is used to indicate that a connection was closed abnormally.\n            // Added hard limit of 30 on number of retries.\n            // If connection was closed abnormally, and we wish to retry, otherwise throw error.\n            if (error.code === 1006 && retryAttempt < 30) {\n              if (retryAttempt > 10) {\n                // If more than 10 times retried, consol.warn, but keep reconnecting\n                console.warn(\n                  `Websocket connection is being disrupted. We keep reconnecting but consider starting new live tailing again. Error: ${error.reason}`\n                );\n              }\n              // Retry every 5s\n              return timer(retryInterval);\n            }\n            return throwError(error);\n          })\n        )\n      ),\n      finalize(() => {\n        delete this.streams[target.url];\n      })\n    );\n    this.streams[target.url] = stream;\n\n    return stream;\n  }\n}\n","/** PURE_IMPORTS_START _WebSocketSubject PURE_IMPORTS_END */\nimport { WebSocketSubject } from './WebSocketSubject';\nexport function webSocket(urlConfigOrSource) {\n    return new WebSocketSubject(urlConfigOrSource);\n}\n//# sourceMappingURL=webSocket.js.map\n","import { default as GraphiteQueryModel } from '../../graphite/graphite_query';\nimport { map } from 'lodash';\nimport { LokiQuery } from '../types';\nimport { GraphiteDatasource } from '../../graphite/datasource';\nimport { getTemplateSrv } from '../../../../features/templating/template_srv';\nimport { GraphiteMetricLokiMatcher, GraphiteQuery, GraphiteToLokiQueryImportConfiguration } from '../../graphite/types';\n\nconst GRAPHITE_TO_LOKI_OPERATOR = {\n  '=': '=',\n  '!=': '!=',\n  '=~': '=~',\n  '!=~': '!~',\n};\n\n/**\n * Converts Graphite glob-like pattern to a regular expression\n */\nfunction convertGlobToRegEx(text: string): string {\n  if (text.includes('*') || text.includes('{')) {\n    return '^' + text.replace(/\\*/g, '.*').replace(/\\{/g, '(').replace(/}/g, ')').replace(/,/g, '|');\n  } else {\n    return text;\n  }\n}\n\nexport default function fromGraphiteQueries(\n  graphiteQueries: GraphiteQuery[],\n  graphiteDataSource: GraphiteDatasource\n): LokiQuery[] {\n  return graphiteQueries.map((query) => {\n    const model: GraphiteQueryModel = new GraphiteQueryModel(\n      graphiteDataSource,\n      {\n        ...query,\n        target: query.target || '',\n        textEditor: false,\n      },\n      getTemplateSrv()\n    );\n    model.parseTarget();\n\n    return {\n      refId: query.refId,\n      expr: fromGraphite(model, graphiteDataSource.getImportQueryConfiguration().loki),\n    };\n  });\n}\n\nfunction fromGraphite(graphiteQuery: GraphiteQueryModel, config: GraphiteToLokiQueryImportConfiguration): string {\n  let matchingFound = false;\n  let labels: any = {};\n\n  if (graphiteQuery.seriesByTagUsed) {\n    matchingFound = true;\n    graphiteQuery.tags.forEach((tag) => {\n      labels[tag.key] = {\n        value: tag.value,\n        operator: GRAPHITE_TO_LOKI_OPERATOR[tag.operator],\n      };\n    });\n  } else {\n    const targetNodes = graphiteQuery.segments.map((segment) => segment.value);\n    let mappings = config.mappings.filter((mapping) => mapping.matchers.length <= targetNodes.length);\n\n    for (let mapping of mappings) {\n      const matchers = mapping.matchers.concat();\n\n      matchingFound = matchers.every((matcher: GraphiteMetricLokiMatcher, index: number) => {\n        if (matcher.labelName) {\n          let value = (targetNodes[index] as string)!;\n\n          if (value === '*') {\n            return true;\n          }\n\n          const converted = convertGlobToRegEx(value);\n          labels[matcher.labelName] = {\n            value: converted,\n            operator: converted !== value ? '=~' : '=',\n          };\n\n          return true;\n        }\n        return targetNodes[index] === matcher.value || matcher.value === '*';\n      });\n    }\n  }\n\n  let pairs = map(labels, (value, key) => `${key}${value.operator}\"${value.value}\"`);\n  if (matchingFound && pairs.length) {\n    return `{${pairs.join(', ')}}`;\n  } else {\n    return '';\n  }\n}\n","// Libraries\nimport { chain, difference } from 'lodash';\nimport LRU from 'lru-cache';\n\n// Services & Utils\nimport {\n  parseSelector,\n  labelRegexp,\n  selectorRegexp,\n  processLabels,\n} from 'app/plugins/datasource/prometheus/language_utils';\nimport syntax, { FUNCTIONS, PIPE_PARSERS, PIPE_OPERATORS } from './syntax';\n\n// Types\nimport { LokiQuery } from './types';\nimport { dateTime, AbsoluteTimeRange, LanguageProvider, HistoryItem, DataQuery, DataSourceApi } from '@grafana/data';\nimport { PromQuery } from '../prometheus/types';\n\nimport LokiDatasource from './datasource';\nimport { CompletionItem, TypeaheadInput, TypeaheadOutput, CompletionItemGroup } from '@grafana/ui';\nimport { Grammar } from 'prismjs';\nimport fromGraphite from './importing/fromGraphite';\nimport { GraphiteDatasource } from '../graphite/datasource';\n\nconst DEFAULT_KEYS = ['job', 'namespace'];\nconst EMPTY_SELECTOR = '{}';\nconst HISTORY_ITEM_COUNT = 10;\nconst HISTORY_COUNT_CUTOFF = 1000 * 60 * 60 * 24; // 24h\nconst NS_IN_MS = 1000000;\n\n// When changing RATE_RANGES, check if Prometheus/PromQL ranges should be changed too\n// @see public/app/plugins/datasource/prometheus/promql.ts\nconst RATE_RANGES: CompletionItem[] = [\n  { label: '$__interval', sortValue: '$__interval' },\n  { label: '$__range', sortValue: '$__range' },\n  { label: '1m', sortValue: '00:01:00' },\n  { label: '5m', sortValue: '00:05:00' },\n  { label: '10m', sortValue: '00:10:00' },\n  { label: '30m', sortValue: '00:30:00' },\n  { label: '1h', sortValue: '01:00:00' },\n  { label: '1d', sortValue: '24:00:00' },\n];\n\nexport const LABEL_REFRESH_INTERVAL = 1000 * 30; // 30sec\n\nconst wrapLabel = (label: string) => ({ label, filterText: `\\\"${label}\\\"` });\n\nexport type LokiHistoryItem = HistoryItem<LokiQuery>;\n\ntype TypeaheadContext = {\n  history?: LokiHistoryItem[];\n  absoluteRange?: AbsoluteTimeRange;\n};\n\nexport function addHistoryMetadata(item: CompletionItem, history: LokiHistoryItem[]): CompletionItem {\n  const cutoffTs = Date.now() - HISTORY_COUNT_CUTOFF;\n  const historyForItem = history.filter((h) => h.ts > cutoffTs && h.query.expr === item.label);\n  let hint = `Queried ${historyForItem.length} times in the last 24h.`;\n  const recent = historyForItem[0];\n\n  if (recent) {\n    const lastQueried = dateTime(recent.ts).fromNow();\n    hint = `${hint} Last queried ${lastQueried}.`;\n  }\n\n  return {\n    ...item,\n    documentation: hint,\n  };\n}\n\nexport default class LokiLanguageProvider extends LanguageProvider {\n  labelKeys: string[];\n  labelFetchTs: number;\n  started = false;\n  datasource: LokiDatasource;\n  lookupsDisabled = false; // Dynamically set to true for big/slow instances\n\n  /**\n   *  Cache for labels of series. This is bit simplistic in the sense that it just counts responses each as a 1 and does\n   *  not account for different size of a response. If that is needed a `length` function can be added in the options.\n   *  10 as a max size is totally arbitrary right now.\n   */\n  private seriesCache = new LRU<string, Record<string, string[]>>(10);\n  private labelsCache = new LRU<string, string[]>(10);\n\n  constructor(datasource: LokiDatasource, initialValues?: any) {\n    super();\n\n    this.datasource = datasource;\n    this.labelKeys = [];\n    this.labelFetchTs = 0;\n\n    Object.assign(this, initialValues);\n  }\n\n  // Strip syntax chars\n  cleanText = (s: string) => s.replace(/[{}[\\]=\"(),!~+\\-*/^%\\|]/g, '').trim();\n\n  getSyntax(): Grammar {\n    return syntax;\n  }\n\n  request = async (url: string, params?: any): Promise<any> => {\n    try {\n      return await this.datasource.metadataRequest(url, params);\n    } catch (error) {\n      console.error(error);\n    }\n\n    return undefined;\n  };\n\n  /**\n   * Initialise the language provider by fetching set of labels. Without this initialisation the provider would return\n   * just a set of hardcoded default labels on provideCompletionItems or a recent queries from history.\n   */\n  start = () => {\n    if (!this.startTask) {\n      this.startTask = this.fetchLabels().then(() => {\n        this.started = true;\n        return [];\n      });\n    }\n\n    return this.startTask;\n  };\n\n  getLabelKeys(): string[] {\n    return this.labelKeys;\n  }\n\n  /**\n   * Return suggestions based on input that can be then plugged into a typeahead dropdown.\n   * Keep this DOM-free for testing\n   * @param input\n   * @param context Is optional in types but is required in case we are doing getLabelCompletionItems\n   * @param context.absoluteRange Required in case we are doing getLabelCompletionItems\n   * @param context.history Optional used only in getEmptyCompletionItems\n   */\n  async provideCompletionItems(input: TypeaheadInput, context?: TypeaheadContext): Promise<TypeaheadOutput> {\n    const { wrapperClasses, value, prefix, text } = input;\n    const emptyResult: TypeaheadOutput = { suggestions: [] };\n\n    if (!value) {\n      return emptyResult;\n    }\n\n    // Local text properties\n    const empty = value?.document.text.length === 0;\n    const selectedLines = value.document.getTextsAtRange(value.selection);\n    const currentLine = selectedLines.size === 1 ? selectedLines.first().getText() : null;\n\n    const nextCharacter = currentLine ? currentLine[value.selection.anchor.offset] : null;\n\n    // Syntax spans have 3 classes by default. More indicate a recognized token\n    const tokenRecognized = wrapperClasses.length > 3;\n\n    // Non-empty prefix, but not inside known token\n    const prefixUnrecognized = prefix && !tokenRecognized;\n\n    // Prevent suggestions in `function(|suffix)`\n    const noSuffix = !nextCharacter || nextCharacter === ')';\n\n    // Prefix is safe if it does not immediately follow a complete expression and has no text after it\n    const safePrefix = prefix && !text.match(/^['\"~=\\]})\\s]+$/) && noSuffix;\n\n    // About to type next operand if preceded by binary operator\n    const operatorsPattern = /[+\\-*/^%]/;\n    const isNextOperand = text.match(operatorsPattern);\n\n    // Determine candidates by CSS context\n    if (wrapperClasses.includes('context-range')) {\n      // Suggestions for metric[|]\n      return this.getRangeCompletionItems();\n    } else if (wrapperClasses.includes('context-labels')) {\n      // Suggestions for {|} and {foo=|}\n      return await this.getLabelCompletionItems(input);\n    } else if (wrapperClasses.includes('context-pipe')) {\n      return this.getPipeCompletionItem();\n    } else if (empty) {\n      // Suggestions for empty query field\n      return this.getEmptyCompletionItems(context);\n    } else if (prefixUnrecognized && noSuffix && !isNextOperand) {\n      // Show term suggestions in a couple of scenarios\n      return this.getBeginningCompletionItems(context);\n    } else if (prefixUnrecognized && safePrefix) {\n      // Show term suggestions in a couple of scenarios\n      return this.getTermCompletionItems();\n    }\n\n    return emptyResult;\n  }\n\n  getBeginningCompletionItems = (context?: TypeaheadContext): TypeaheadOutput => {\n    return {\n      suggestions: [...this.getEmptyCompletionItems(context).suggestions, ...this.getTermCompletionItems().suggestions],\n    };\n  };\n\n  getEmptyCompletionItems(context?: TypeaheadContext): TypeaheadOutput {\n    const history = context?.history;\n    const suggestions = [];\n\n    if (history?.length) {\n      const historyItems = chain(history)\n        .map((h) => h.query.expr)\n        .filter()\n        .uniq()\n        .take(HISTORY_ITEM_COUNT)\n        .map(wrapLabel)\n        .map((item) => addHistoryMetadata(item, history))\n        .value();\n\n      suggestions.push({\n        prefixMatch: true,\n        skipSort: true,\n        label: 'History',\n        items: historyItems,\n      });\n    }\n\n    return { suggestions };\n  }\n\n  getTermCompletionItems = (): TypeaheadOutput => {\n    const suggestions = [];\n\n    suggestions.push({\n      prefixMatch: true,\n      label: 'Functions',\n      items: FUNCTIONS.map((suggestion) => ({ ...suggestion, kind: 'function' })),\n    });\n\n    return { suggestions };\n  };\n\n  getPipeCompletionItem = (): TypeaheadOutput => {\n    const suggestions = [];\n\n    suggestions.push({\n      label: 'Operators',\n      items: PIPE_OPERATORS.map((suggestion) => ({ ...suggestion, kind: 'operators' })),\n    });\n\n    suggestions.push({\n      label: 'Parsers',\n      items: PIPE_PARSERS.map((suggestion) => ({ ...suggestion, kind: 'parsers' })),\n    });\n\n    return { suggestions };\n  };\n\n  getRangeCompletionItems(): TypeaheadOutput {\n    return {\n      context: 'context-range',\n      suggestions: [\n        {\n          label: 'Range vector',\n          items: [...RATE_RANGES],\n        },\n      ],\n    };\n  }\n\n  async getLabelCompletionItems({ text, wrapperClasses, labelKey, value }: TypeaheadInput): Promise<TypeaheadOutput> {\n    let context = 'context-labels';\n    const suggestions: CompletionItemGroup[] = [];\n    if (!value) {\n      return { context, suggestions: [] };\n    }\n    const line = value.anchorBlock.getText();\n    const cursorOffset = value.selection.anchor.offset;\n    const isValueStart = text.match(/^(=|=~|!=|!~)/);\n\n    // Get normalized selector\n    let selector;\n    let parsedSelector;\n    try {\n      parsedSelector = parseSelector(line, cursorOffset);\n      selector = parsedSelector.selector;\n    } catch {\n      selector = EMPTY_SELECTOR;\n    }\n\n    if (!labelKey && selector === EMPTY_SELECTOR) {\n      // start task gets all labels\n      await this.start();\n      const allLabels = this.getLabelKeys();\n      return { context, suggestions: [{ label: `Labels`, items: allLabels.map(wrapLabel) }] };\n    }\n\n    const existingKeys = parsedSelector ? parsedSelector.labelKeys : [];\n\n    let labelValues;\n    // Query labels for selector\n    if (selector) {\n      if (selector === EMPTY_SELECTOR && labelKey) {\n        const labelValuesForKey = await this.getLabelValues(labelKey);\n        labelValues = { [labelKey]: labelValuesForKey };\n      } else {\n        labelValues = await this.getSeriesLabels(selector);\n      }\n    }\n\n    if (!labelValues) {\n      console.warn(`Server did not return any values for selector = ${selector}`);\n      return { context, suggestions };\n    }\n\n    if ((text && isValueStart) || wrapperClasses.includes('attr-value')) {\n      // Label values\n      if (labelKey && labelValues[labelKey]) {\n        context = 'context-label-values';\n        suggestions.push({\n          label: `Label values for \"${labelKey}\"`,\n          // Filter to prevent previously selected values from being repeatedly suggested\n          items: labelValues[labelKey].map(wrapLabel).filter(({ filterText }) => filterText !== text),\n        });\n      }\n    } else {\n      // Label keys\n      const labelKeys = labelValues ? Object.keys(labelValues) : DEFAULT_KEYS;\n      if (labelKeys) {\n        const possibleKeys = difference(labelKeys, existingKeys);\n        if (possibleKeys.length) {\n          const newItems = possibleKeys.map((key) => ({ label: key }));\n          const newSuggestion: CompletionItemGroup = { label: `Labels`, items: newItems };\n          suggestions.push(newSuggestion);\n        }\n      }\n    }\n\n    return { context, suggestions };\n  }\n\n  async importQueries(queries: DataQuery[], originDataSource: DataSourceApi): Promise<LokiQuery[]> {\n    const datasourceType = originDataSource.meta.id;\n    if (datasourceType === 'prometheus') {\n      return Promise.all(\n        queries.map(async (query) => {\n          const expr = await this.importPrometheusQuery((query as PromQuery).expr);\n          const { ...rest } = query as PromQuery;\n          return {\n            ...rest,\n            expr,\n          };\n        })\n      );\n    }\n    if (datasourceType === 'graphite') {\n      return fromGraphite(queries, originDataSource as GraphiteDatasource);\n    }\n    // Return a cleaned LokiQuery\n    return queries.map((query) => ({\n      refId: query.refId,\n      expr: '',\n    }));\n  }\n\n  async importPrometheusQuery(query: string): Promise<string> {\n    if (!query) {\n      return '';\n    }\n\n    // Consider only first selector in query\n    const selectorMatch = query.match(selectorRegexp);\n    if (!selectorMatch) {\n      return '';\n    }\n\n    const selector = selectorMatch[0];\n    const labels: { [key: string]: { value: any; operator: any } } = {};\n    selector.replace(labelRegexp, (_, key, operator, value) => {\n      labels[key] = { value, operator };\n      return '';\n    });\n\n    // Keep only labels that exist on origin and target datasource\n    await this.start(); // fetches all existing label keys\n    const existingKeys = this.labelKeys;\n    let labelsToKeep: { [key: string]: { value: any; operator: any } } = {};\n    if (existingKeys && existingKeys.length) {\n      // Check for common labels\n      for (const key in labels) {\n        if (existingKeys && existingKeys.includes(key)) {\n          // Should we check for label value equality here?\n          labelsToKeep[key] = labels[key];\n        }\n      }\n    } else {\n      // Keep all labels by default\n      labelsToKeep = labels;\n    }\n\n    const labelKeys = Object.keys(labelsToKeep).sort();\n    const cleanSelector = labelKeys\n      .map((key) => `${key}${labelsToKeep[key].operator}${labelsToKeep[key].value}`)\n      .join(',');\n\n    return ['{', cleanSelector, '}'].join('');\n  }\n\n  async getSeriesLabels(selector: string) {\n    if (this.lookupsDisabled) {\n      return undefined;\n    }\n    try {\n      return await this.fetchSeriesLabels(selector);\n    } catch (error) {\n      // TODO: better error handling\n      console.error(error);\n      return undefined;\n    }\n  }\n\n  /**\n   * Fetches all label keys\n   */\n  async fetchLabels(): Promise<string[]> {\n    const url = '/loki/api/v1/label';\n    const timeRange = this.datasource.getTimeRangeParams();\n    this.labelFetchTs = Date.now().valueOf();\n\n    const res = await this.request(url, timeRange);\n    if (Array.isArray(res)) {\n      this.labelKeys = res.slice().sort();\n    }\n\n    return [];\n  }\n\n  async refreshLogLabels(forceRefresh?: boolean) {\n    if ((this.labelKeys && Date.now().valueOf() - this.labelFetchTs > LABEL_REFRESH_INTERVAL) || forceRefresh) {\n      await this.fetchLabels();\n    }\n  }\n\n  /**\n   * Fetch labels for a selector. This is cached by it's args but also by the global timeRange currently selected as\n   * they can change over requested time.\n   * @param name\n   */\n  fetchSeriesLabels = async (match: string): Promise<Record<string, string[]>> => {\n    const url = '/loki/api/v1/series';\n    const { start, end } = this.datasource.getTimeRangeParams();\n\n    const cacheKey = this.generateCacheKey(url, start, end, match);\n    let value = this.seriesCache.get(cacheKey);\n    if (!value) {\n      // Clear value when requesting new one. Empty object being truthy also makes sure we don't request twice.\n      this.seriesCache.set(cacheKey, {});\n      const params = { 'match[]': match, start, end };\n      const data = await this.request(url, params);\n      const { values } = processLabels(data);\n      value = values;\n      this.seriesCache.set(cacheKey, value);\n    }\n    return value;\n  };\n\n  /**\n   * Fetch series for a selector. Use this for raw results. Use fetchSeriesLabels() to get labels.\n   * @param match\n   */\n  fetchSeries = async (match: string): Promise<Array<Record<string, string>>> => {\n    const url = '/loki/api/v1/series';\n    const { start, end } = this.datasource.getTimeRangeParams();\n    const params = { 'match[]': match, start, end };\n    return await this.request(url, params);\n  };\n\n  // Cache key is a bit different here. We round up to a minute the intervals.\n  // The rounding may seem strange but makes relative intervals like now-1h less prone to need separate request every\n  // millisecond while still actually getting all the keys for the correct interval. This still can create problems\n  // when user does not the newest values for a minute if already cached.\n  generateCacheKey(url: string, start: number, end: number, param: string): string {\n    return [url, this.roundTime(start), this.roundTime(end), param].join();\n  }\n\n  // Round nanos epoch to nearest 5 minute interval\n  roundTime(nanos: number): number {\n    return nanos ? Math.floor(nanos / NS_IN_MS / 1000 / 60 / 5) : 0;\n  }\n\n  async getLabelValues(key: string): Promise<string[]> {\n    return await this.fetchLabelValues(key);\n  }\n\n  async fetchLabelValues(key: string): Promise<string[]> {\n    const url = `/loki/api/v1/label/${key}/values`;\n    const rangeParams = this.datasource.getTimeRangeParams();\n    const { start, end } = rangeParams;\n\n    const cacheKey = this.generateCacheKey(url, start, end, key);\n    const params = { start, end };\n\n    let labelValues = this.labelsCache.get(cacheKey);\n    if (!labelValues) {\n      // Clear value when requesting new one. Empty object being truthy also makes sure we don't request twice.\n      this.labelsCache.set(cacheKey, []);\n      const res = await this.request(url, params);\n      if (Array.isArray(res)) {\n        labelValues = res.slice().sort();\n        this.labelsCache.set(cacheKey, labelValues);\n      }\n    }\n\n    return labelValues ?? [];\n  }\n}\n","// Libraries\nimport { cloneDeep, isEmpty, map as lodashMap } from 'lodash';\nimport { merge, Observable, of, throwError } from 'rxjs';\nimport { catchError, map, switchMap } from 'rxjs/operators';\nimport Prism from 'prismjs';\n\n// Types\nimport {\n  AnnotationEvent,\n  AnnotationQueryRequest,\n  DataFrame,\n  DataFrameView,\n  DataQuery,\n  DataQueryError,\n  DataQueryRequest,\n  DataQueryResponse,\n  DataSourceApi,\n  DataSourceInstanceSettings,\n  dateMath,\n  DateTime,\n  FieldCache,\n  LoadingState,\n  LogRowModel,\n  QueryResultMeta,\n  ScopedVars,\n  TimeRange,\n} from '@grafana/data';\nimport { BackendSrvRequest, FetchError, getBackendSrv } from '@grafana/runtime';\nimport { getTemplateSrv, TemplateSrv } from 'app/features/templating/template_srv';\nimport { addLabelToQuery } from 'app/plugins/datasource/prometheus/add_label_to_query';\nimport { getTimeSrv, TimeSrv } from 'app/features/dashboard/services/TimeSrv';\nimport { convertToWebSocketUrl } from 'app/core/utils/explore';\nimport {\n  lokiResultsToTableModel,\n  lokiStreamResultToDataFrame,\n  lokiStreamsToDataFrames,\n  processRangeQueryResponse,\n} from './result_transformer';\nimport { getHighlighterExpressionsFromQuery, queryHasPipeParser, addParsedLabelToQuery } from './query_utils';\n\nimport {\n  LokiOptions,\n  LokiQuery,\n  LokiRangeQueryRequest,\n  LokiResponse,\n  LokiResultType,\n  LokiStreamResponse,\n} from './types';\nimport { LiveStreams, LokiLiveTarget } from './live_streams';\nimport LanguageProvider from './language_provider';\nimport { serializeParams } from '../../../core/utils/fetch';\nimport { RowContextOptions } from '@grafana/ui/src/components/Logs/LogRowContextProvider';\nimport syntax from './syntax';\n\nexport type RangeQueryOptions = DataQueryRequest<LokiQuery> | AnnotationQueryRequest<LokiQuery>;\nexport const DEFAULT_MAX_LINES = 1000;\nexport const LOKI_ENDPOINT = '/loki/api/v1';\nconst NS_IN_MS = 1000000;\n\nconst RANGE_QUERY_ENDPOINT = `${LOKI_ENDPOINT}/query_range`;\nconst INSTANT_QUERY_ENDPOINT = `${LOKI_ENDPOINT}/query`;\n\nconst DEFAULT_QUERY_PARAMS: Partial<LokiRangeQueryRequest> = {\n  direction: 'BACKWARD',\n  limit: DEFAULT_MAX_LINES,\n  query: '',\n};\n\nexport class LokiDatasource extends DataSourceApi<LokiQuery, LokiOptions> {\n  private streams = new LiveStreams();\n  languageProvider: LanguageProvider;\n  maxLines: number;\n\n  constructor(\n    private instanceSettings: DataSourceInstanceSettings<LokiOptions>,\n    private readonly templateSrv: TemplateSrv = getTemplateSrv(),\n    private readonly timeSrv: TimeSrv = getTimeSrv()\n  ) {\n    super(instanceSettings);\n\n    this.languageProvider = new LanguageProvider(this);\n    const settingsData = instanceSettings.jsonData || {};\n    this.maxLines = parseInt(settingsData.maxLines ?? '0', 10) || DEFAULT_MAX_LINES;\n  }\n\n  _request(apiUrl: string, data?: any, options?: Partial<BackendSrvRequest>): Observable<Record<string, any>> {\n    const baseUrl = this.instanceSettings.url;\n    const params = data ? serializeParams(data) : '';\n    const url = `${baseUrl}${apiUrl}${params.length ? `?${params}` : ''}`;\n    if (this.instanceSettings.withCredentials || this.instanceSettings.basicAuth) {\n      options = { ...options, withCredentials: true };\n      if (this.instanceSettings.basicAuth) {\n        options.headers = { ...options.headers, Authorization: this.instanceSettings.basicAuth };\n      }\n    }\n    const req = {\n      ...options,\n      url,\n    };\n\n    return getBackendSrv().fetch<Record<string, any>>(req);\n  }\n\n  query(options: DataQueryRequest<LokiQuery>): Observable<DataQueryResponse> {\n    const subQueries: Array<Observable<DataQueryResponse>> = [];\n    const scopedVars = {\n      ...options.scopedVars,\n      ...this.getRangeScopedVars(options.range),\n    };\n    const filteredTargets = options.targets\n      .filter((target) => target.expr && !target.hide)\n      .map((target) => {\n        const expr = this.addAdHocFilters(target.expr);\n        return {\n          ...target,\n          expr: this.templateSrv.replace(expr, scopedVars, this.interpolateQueryExpr),\n        };\n      });\n\n    for (const target of filteredTargets) {\n      if (target.instant) {\n        subQueries.push(this.runInstantQuery(target, options, filteredTargets.length));\n      } else {\n        subQueries.push(this.runRangeQuery(target, options, filteredTargets.length));\n      }\n    }\n\n    // No valid targets, return the empty result to save a round trip.\n    if (isEmpty(subQueries)) {\n      return of({\n        data: [],\n        state: LoadingState.Done,\n      });\n    }\n\n    return merge(...subQueries);\n  }\n\n  runInstantQuery = (\n    target: LokiQuery,\n    options: DataQueryRequest<LokiQuery>,\n    responseListLength = 1\n  ): Observable<DataQueryResponse> => {\n    const timeNs = this.getTime(options.range.to, true);\n    const queryLimit = isMetricsQuery(target.expr) ? options.maxDataPoints : target.maxLines;\n    const query = {\n      query: target.expr,\n      time: `${timeNs + (1e9 - (timeNs % 1e9))}`,\n      limit: Math.min(queryLimit || Infinity, this.maxLines),\n    };\n\n    /** Used only for results of metrics instant queries */\n    const meta: QueryResultMeta = {\n      preferredVisualisationType: 'table',\n    };\n\n    return this._request(INSTANT_QUERY_ENDPOINT, query).pipe(\n      map((response: { data: LokiResponse }) => {\n        if (response.data.data.resultType === LokiResultType.Stream) {\n          return {\n            data: response.data\n              ? lokiStreamsToDataFrames(\n                  response.data as LokiStreamResponse,\n                  target,\n                  query.limit,\n                  this.instanceSettings.jsonData\n                )\n              : [],\n            key: `${target.refId}_instant`,\n          };\n        }\n\n        return {\n          data: [lokiResultsToTableModel(response.data.data.result, responseListLength, target.refId, meta, true)],\n          key: `${target.refId}_instant`,\n        };\n      }),\n      catchError((err: any) => this.throwUnless(err, err.status === 404, target))\n    );\n  };\n\n  createRangeQuery(target: LokiQuery, options: RangeQueryOptions, limit: number): LokiRangeQueryRequest {\n    const query = target.expr;\n    let range: { start?: number; end?: number; step?: number } = {};\n    if (options.range) {\n      const startNs = this.getTime(options.range.from, false);\n      const endNs = this.getTime(options.range.to, true);\n      const rangeMs = Math.ceil((endNs - startNs) / 1e6);\n      const adjustedInterval =\n        this.adjustInterval((options as DataQueryRequest<LokiQuery>).intervalMs || 1000, rangeMs) / 1000;\n      // We want to ceil to 3 decimal places\n      const step = Math.ceil(adjustedInterval * 1000) / 1000;\n\n      range = {\n        start: startNs,\n        end: endNs,\n        step,\n      };\n    }\n\n    return {\n      ...DEFAULT_QUERY_PARAMS,\n      ...range,\n      query,\n      limit,\n    };\n  }\n\n  /**\n   * Attempts to send a query to /loki/api/v1/query_range\n   */\n  runRangeQuery = (\n    target: LokiQuery,\n    options: RangeQueryOptions,\n    responseListLength = 1\n  ): Observable<DataQueryResponse> => {\n    // For metric query we use maxDataPoints from the request options which should be something like width of the\n    // visualisation in pixels. In case of logs request we either use lines limit defined in the query target or\n    // global limit defined for the data source which ever is lower.\n    let maxDataPoints = isMetricsQuery(target.expr)\n      ? // We fallback to maxLines here because maxDataPoints is defined as possibly undefined. Not sure that can\n        // actually happen both Dashboards and Explore should send some value here. If not maxLines does not make that\n        // much sense but nor any other arbitrary value.\n        (options as DataQueryRequest<LokiQuery>).maxDataPoints || this.maxLines\n      : // If user wants maxLines 0 we still fallback to data source limit. I think that makes sense as why would anyone\n        // want to do a query and not see any results?\n        target.maxLines || this.maxLines;\n\n    if ((options as DataQueryRequest<LokiQuery>).liveStreaming) {\n      return this.runLiveQuery(target, maxDataPoints);\n    }\n    const query = this.createRangeQuery(target, options, maxDataPoints);\n\n    return this._request(RANGE_QUERY_ENDPOINT, query).pipe(\n      catchError((err: any) => this.throwUnless(err, err.status === 404, target)),\n      switchMap((response: { data: LokiResponse; status: number }) =>\n        processRangeQueryResponse(\n          response.data,\n          target,\n          query,\n          responseListLength,\n          maxDataPoints,\n          this.instanceSettings.jsonData,\n          (options as DataQueryRequest<LokiQuery>).scopedVars,\n          (options as DataQueryRequest<LokiQuery>).reverse\n        )\n      )\n    );\n  };\n\n  createLiveTarget(target: LokiQuery, maxDataPoints: number): LokiLiveTarget {\n    const query = target.expr;\n    const baseUrl = this.instanceSettings.url;\n    const params = serializeParams({ query });\n\n    return {\n      query,\n      url: convertToWebSocketUrl(`${baseUrl}/loki/api/v1/tail?${params}`),\n      refId: target.refId,\n      size: maxDataPoints,\n    };\n  }\n\n  /**\n   * Runs live queries which in this case means creating a websocket and listening on it for new logs.\n   * This returns a bit different dataFrame than runQueries as it returns single dataframe even if there are multiple\n   * Loki streams, sets only common labels on dataframe.labels and has additional dataframe.fields.labels for unique\n   * labels per row.\n   */\n  runLiveQuery = (target: LokiQuery, maxDataPoints: number): Observable<DataQueryResponse> => {\n    const liveTarget = this.createLiveTarget(target, maxDataPoints);\n\n    return this.streams.getStream(liveTarget).pipe(\n      map((data) => ({\n        data: data || [],\n        key: `loki-${liveTarget.refId}`,\n        state: LoadingState.Streaming,\n      })),\n      catchError((err: any) => {\n        return throwError(`Live tailing was stopped due to following error: ${err.reason}`);\n      })\n    );\n  };\n\n  getRangeScopedVars(range: TimeRange = this.timeSrv.timeRange()) {\n    const msRange = range.to.diff(range.from);\n    const sRange = Math.round(msRange / 1000);\n    return {\n      __range_ms: { text: msRange, value: msRange },\n      __range_s: { text: sRange, value: sRange },\n      __range: { text: sRange + 's', value: sRange + 's' },\n    };\n  }\n\n  interpolateVariablesInQueries(queries: LokiQuery[], scopedVars: ScopedVars): LokiQuery[] {\n    let expandedQueries = queries;\n    if (queries && queries.length) {\n      expandedQueries = queries.map((query) => ({\n        ...query,\n        datasource: this.name,\n        expr: this.templateSrv.replace(query.expr, scopedVars, this.interpolateQueryExpr),\n      }));\n    }\n\n    return expandedQueries;\n  }\n\n  getQueryDisplayText(query: LokiQuery) {\n    return query.expr;\n  }\n\n  getTimeRangeParams() {\n    const timeRange = this.timeSrv.timeRange();\n    return { start: timeRange.from.valueOf() * NS_IN_MS, end: timeRange.to.valueOf() * NS_IN_MS };\n  }\n\n  async importQueries(queries: DataQuery[], originDataSource: DataSourceApi): Promise<LokiQuery[]> {\n    return this.languageProvider.importQueries(queries, originDataSource);\n  }\n\n  async metadataRequest(url: string, params?: Record<string, string | number>) {\n    const res = await this._request(url, params, { hideFromInspector: true }).toPromise();\n    return res.data.data || res.data.values || [];\n  }\n\n  async metricFindQuery(query: string) {\n    if (!query) {\n      return Promise.resolve([]);\n    }\n\n    const interpolated = this.templateSrv.replace(query, {}, this.interpolateQueryExpr);\n    return await this.processMetricFindQuery(interpolated);\n  }\n\n  async processMetricFindQuery(query: string) {\n    const labelNamesRegex = /^label_names\\(\\)\\s*$/;\n    const labelValuesRegex = /^label_values\\((?:(.+),\\s*)?([a-zA-Z_][a-zA-Z0-9_]*)\\)\\s*$/;\n\n    const labelNames = query.match(labelNamesRegex);\n    if (labelNames) {\n      return await this.labelNamesQuery();\n    }\n\n    const labelValues = query.match(labelValuesRegex);\n    if (labelValues) {\n      // If we have query expr, use /series endpoint\n      if (labelValues[1]) {\n        return await this.labelValuesSeriesQuery(labelValues[1], labelValues[2]);\n      }\n      return await this.labelValuesQuery(labelValues[2]);\n    }\n\n    return Promise.resolve([]);\n  }\n\n  async labelNamesQuery() {\n    const url = `${LOKI_ENDPOINT}/label`;\n    const params = this.getTimeRangeParams();\n    const result = await this.metadataRequest(url, params);\n    return result.map((value: string) => ({ text: value }));\n  }\n\n  async labelValuesQuery(label: string) {\n    const params = this.getTimeRangeParams();\n    const url = `${LOKI_ENDPOINT}/label/${label}/values`;\n    const result = await this.metadataRequest(url, params);\n    return result.map((value: string) => ({ text: value }));\n  }\n\n  async labelValuesSeriesQuery(expr: string, label: string) {\n    const timeParams = this.getTimeRangeParams();\n    const params = {\n      ...timeParams,\n      'match[]': expr,\n    };\n    const url = `${LOKI_ENDPOINT}/series`;\n    const streams = new Set();\n    const result = await this.metadataRequest(url, params);\n    result.forEach((stream: { [key: string]: string }) => {\n      if (stream[label]) {\n        streams.add({ text: stream[label] });\n      }\n    });\n\n    return Array.from(streams);\n  }\n\n  // By implementing getTagKeys and getTagValues we add ad-hoc filtters functionality\n  async getTagKeys() {\n    return await this.labelNamesQuery();\n  }\n\n  async getTagValues(options: any = {}) {\n    return await this.labelValuesQuery(options.key);\n  }\n\n  interpolateQueryExpr(value: any, variable: any) {\n    // if no multi or include all do not regexEscape\n    if (!variable.multi && !variable.includeAll) {\n      return lokiRegularEscape(value);\n    }\n\n    if (typeof value === 'string') {\n      return lokiSpecialRegexEscape(value);\n    }\n\n    const escapedValues = lodashMap(value, lokiSpecialRegexEscape);\n    return escapedValues.join('|');\n  }\n\n  modifyQuery(query: LokiQuery, action: any): LokiQuery {\n    let expression = query.expr ?? '';\n    switch (action.type) {\n      case 'ADD_FILTER': {\n        expression = this.addLabelToQuery(expression, action.key, action.value, '=');\n        break;\n      }\n      case 'ADD_FILTER_OUT': {\n        expression = this.addLabelToQuery(expression, action.key, action.value, '!=');\n        break;\n      }\n      default:\n        break;\n    }\n    return { ...query, expr: expression };\n  }\n\n  getHighlighterExpression(query: LokiQuery): string[] {\n    return getHighlighterExpressionsFromQuery(query.expr);\n  }\n\n  getTime(date: string | DateTime, roundUp: boolean) {\n    if (typeof date === 'string') {\n      date = dateMath.parse(date, roundUp)!;\n    }\n\n    return Math.ceil(date.valueOf() * 1e6);\n  }\n\n  getLogRowContext = (row: LogRowModel, options?: RowContextOptions): Promise<{ data: DataFrame[] }> => {\n    const target = this.prepareLogRowContextQueryTarget(\n      row,\n      (options && options.limit) || 10,\n      (options && options.direction) || 'BACKWARD'\n    );\n\n    const reverse = options && options.direction === 'FORWARD';\n    return this._request(RANGE_QUERY_ENDPOINT, target)\n      .pipe(\n        catchError((err: any) => {\n          if (err.status === 404) {\n            return of(err);\n          }\n\n          const error: DataQueryError = {\n            message: 'Error during context query. Please check JS console logs.',\n            status: err.status,\n            statusText: err.statusText,\n          };\n          throw error;\n        }),\n        switchMap((res: { data: LokiStreamResponse; status: number }) =>\n          of({\n            data: res.data ? res.data.data.result.map((stream) => lokiStreamResultToDataFrame(stream, reverse)) : [],\n          })\n        )\n      )\n      .toPromise();\n  };\n\n  prepareLogRowContextQueryTarget = (row: LogRowModel, limit: number, direction: 'BACKWARD' | 'FORWARD') => {\n    const query = Object.keys(row.labels)\n      .map((label) => `${label}=\"${row.labels[label].replace(/\\\\/g, '\\\\\\\\')}\"`) // escape backslashes in label as users can't escape them by themselves\n      .join(',');\n\n    const contextTimeBuffer = 2 * 60 * 60 * 1000; // 2h buffer\n    const commonTargetOptions = {\n      limit,\n      query: `{${query}}`,\n      expr: `{${query}}`,\n      direction,\n    };\n\n    const fieldCache = new FieldCache(row.dataFrame);\n    const nsField = fieldCache.getFieldByName('tsNs')!;\n    const nsTimestamp = nsField.values.get(row.rowIndex);\n\n    if (direction === 'BACKWARD') {\n      return {\n        ...commonTargetOptions,\n        // convert to ns, we loose some precision here but it is not that important at the far points of the context\n        start: row.timeEpochMs - contextTimeBuffer + '000000',\n        end: nsTimestamp,\n        direction,\n      };\n    } else {\n      return {\n        ...commonTargetOptions,\n        // start param in Loki API is inclusive so we'll have to filter out the row that this request is based from\n        // and any other that were logged in the same ns but before the row. Right now these rows will be lost\n        // because the are before but came it he response that should return only rows after.\n        start: nsTimestamp,\n        // convert to ns, we loose some precision here but it is not that important at the far points of the context\n        end: row.timeEpochMs + contextTimeBuffer + '000000',\n      };\n    }\n  };\n\n  testDatasource() {\n    // Consider only last 10 minutes otherwise request takes too long\n    const startMs = Date.now() - 10 * 60 * 1000;\n    const start = `${startMs}000000`; // API expects nanoseconds\n    return this._request(`${LOKI_ENDPOINT}/label`, { start })\n      .pipe(\n        map((res) => {\n          const values: any[] = res?.data?.data || res?.data?.values || [];\n          const testResult =\n            values.length > 0\n              ? { status: 'success', message: 'Data source connected and labels found.' }\n              : {\n                  status: 'error',\n                  message:\n                    'Data source connected, but no labels received. Verify that Loki and Promtail is configured properly.',\n                };\n          return testResult;\n        }),\n        catchError((err: any) => {\n          let message = 'Loki: ';\n          if (err.statusText) {\n            message += err.statusText;\n          } else {\n            message += 'Cannot connect to Loki';\n          }\n\n          if (err.status) {\n            message += `. ${err.status}`;\n          }\n\n          if (err.data && err.data.message) {\n            message += `. ${err.data.message}`;\n          } else if (err.data) {\n            message += `. ${err.data}`;\n          }\n          return of({ status: 'error', message: message });\n        })\n      )\n      .toPromise();\n  }\n\n  async annotationQuery(options: any): Promise<AnnotationEvent[]> {\n    const { expr, maxLines, instant, tagKeys = '', titleFormat = '', textFormat = '' } = options.annotation;\n\n    if (!expr) {\n      return [];\n    }\n\n    const interpolatedExpr = this.templateSrv.replace(expr, {}, this.interpolateQueryExpr);\n    const query = { refId: `annotation-${options.annotation.name}`, expr: interpolatedExpr, maxLines, instant };\n    const { data } = instant\n      ? await this.runInstantQuery(query, options as any).toPromise()\n      : await this.runRangeQuery(query, options as any).toPromise();\n\n    const annotations: AnnotationEvent[] = [];\n    const splitKeys: string[] = tagKeys.split(',').filter((v: string) => v !== '');\n\n    for (const frame of data) {\n      const labels: { [key: string]: string } = {};\n      for (const field of frame.fields) {\n        if (field.labels) {\n          for (const [key, value] of Object.entries(field.labels)) {\n            labels[key] = String(value).trim();\n          }\n        }\n      }\n\n      const tags: string[] = [\n        ...new Set(\n          Object.entries(labels).reduce((acc: string[], [key, val]) => {\n            if (val === '') {\n              return acc;\n            }\n            if (splitKeys.length && !splitKeys.includes(key)) {\n              return acc;\n            }\n            acc.push.apply(acc, [val]);\n            return acc;\n          }, [])\n        ),\n      ];\n\n      const view = new DataFrameView<{ ts: string; line: string }>(frame);\n\n      view.forEach((row) => {\n        annotations.push({\n          time: new Date(row.ts).valueOf(),\n          title: renderTemplate(titleFormat, labels),\n          text: renderTemplate(textFormat, labels) || row.line,\n          tags,\n        });\n      });\n    }\n\n    return annotations;\n  }\n\n  showContextToggle(row?: LogRowModel): boolean {\n    return (row && row.searchWords && row.searchWords.length > 0) === true;\n  }\n\n  throwUnless(err: FetchError, condition: boolean, target: LokiQuery) {\n    if (condition) {\n      return of(err);\n    }\n\n    const error = this.processError(err, target);\n    throw error;\n  }\n\n  processError(err: FetchError, target: LokiQuery) {\n    let error = cloneDeep(err);\n    if (err.data.message.includes('escape') && target.expr.includes('\\\\')) {\n      error.data.message = `Error: ${err.data.message}. Make sure that all special characters are escaped with \\\\. For more information on escaping of special characters visit LogQL documentation at https://grafana.com/docs/loki/latest/logql/.`;\n    }\n    return error;\n  }\n\n  adjustInterval(interval: number, range: number) {\n    // Loki will drop queries that might return more than 11000 data points.\n    // Calibrate interval if it is too small.\n    if (interval !== 0 && range / interval > 11000) {\n      interval = Math.ceil(range / 11000);\n    }\n    // The min interval is set to 1ms\n    return Math.max(interval, 1);\n  }\n\n  addAdHocFilters(queryExpr: string) {\n    const adhocFilters = this.templateSrv.getAdhocFilters(this.name);\n    let expr = queryExpr;\n\n    expr = adhocFilters.reduce((acc: string, filter: { key?: any; operator?: any; value?: any }) => {\n      const { key, operator } = filter;\n      let { value } = filter;\n      if (operator === '=~' || operator === '!~') {\n        value = lokiRegularEscape(value);\n      }\n\n      return this.addLabelToQuery(acc, key, value, operator);\n    }, expr);\n\n    return expr;\n  }\n\n  addLabelToQuery(queryExpr: string, key: string, value: string | number, operator: string) {\n    if (queryHasPipeParser(queryExpr) && !isMetricsQuery(queryExpr)) {\n      // If query has parser, we treat all labels as parsed and use | key=\"value\" syntax\n      return addParsedLabelToQuery(queryExpr, key, value, operator);\n    } else {\n      return addLabelToQuery(queryExpr, key, value, operator, true);\n    }\n  }\n}\n\nexport function renderTemplate(aliasPattern: string, aliasData: { [key: string]: string }) {\n  const aliasRegex = /\\{\\{\\s*(.+?)\\s*\\}\\}/g;\n  return aliasPattern.replace(aliasRegex, (_match, g1) => {\n    if (aliasData[g1]) {\n      return aliasData[g1];\n    }\n    return '';\n  });\n}\n\nexport function lokiRegularEscape(value: any) {\n  if (typeof value === 'string') {\n    return value.replace(/'/g, \"\\\\\\\\'\");\n  }\n  return value;\n}\n\nexport function lokiSpecialRegexEscape(value: any) {\n  if (typeof value === 'string') {\n    return lokiRegularEscape(value.replace(/\\\\/g, '\\\\\\\\\\\\\\\\').replace(/[$^*{}\\[\\]+?.()|]/g, '\\\\\\\\$&'));\n  }\n  return value;\n}\n\n/**\n * Checks if the query expression uses function and so should return a time series instead of logs.\n * Sometimes important to know that before we actually do the query.\n */\nfunction isMetricsQuery(query: string): boolean {\n  const tokens = Prism.tokenize(query, syntax);\n  return tokens.some((t) => {\n    // Not sure in which cases it can be string maybe if nothing matched which means it should not be a function\n    return typeof t !== 'string' && t.type === 'function';\n  });\n}\n\nexport default LokiDatasource;\n","import React, { PureComponent } from 'react';\nimport { shuffle } from 'lodash';\nimport { QueryEditorHelpProps } from '@grafana/data';\nimport LokiLanguageProvider from '../language_provider';\nimport { LokiQuery } from '../types';\n\nconst DEFAULT_EXAMPLES = ['{job=\"default/prometheus\"}'];\nconst PREFERRED_LABELS = ['job', 'app', 'k8s_app'];\nconst EXAMPLES_LIMIT = 5;\n\nconst LOGQL_EXAMPLES = [\n  {\n    title: 'Log pipeline',\n    expression: '{job=\"mysql\"} |= \"metrics\" | logfmt | duration > 10s',\n    label:\n      'This query targets the MySQL job, filters out logs that don’t contain the word \"metrics\" and parses each log line to extract more labels and filters with them.',\n  },\n  {\n    title: 'Count over time',\n    expression: 'count_over_time({job=\"mysql\"}[5m])',\n    label: 'This query counts all the log lines within the last five minutes for the MySQL job.',\n  },\n  {\n    title: 'Rate',\n    expression: 'rate(({job=\"mysql\"} |= \"error\" != \"timeout\")[10s])',\n    label:\n      'This query gets the per-second rate of all non-timeout errors within the last ten seconds for the MySQL job.',\n  },\n  {\n    title: 'Aggregate, count, and group',\n    expression: 'sum(count_over_time({job=\"mysql\"}[5m])) by (level)',\n    label: 'Get the count of logs during the last five minutes, grouping by level.',\n  },\n];\n\nexport default class LokiCheatSheet extends PureComponent<QueryEditorHelpProps<LokiQuery>, { userExamples: string[] }> {\n  declare userLabelTimer: NodeJS.Timeout;\n  state = {\n    userExamples: DEFAULT_EXAMPLES,\n  };\n\n  componentDidMount() {\n    this.scheduleUserLabelChecking();\n  }\n\n  componentWillUnmount() {\n    clearTimeout(this.userLabelTimer);\n  }\n\n  scheduleUserLabelChecking() {\n    this.userLabelTimer = setTimeout(this.checkUserLabels, 1000);\n  }\n\n  checkUserLabels = async () => {\n    // Set example from user labels\n    const provider: LokiLanguageProvider = this.props.datasource?.languageProvider;\n    if (provider.started) {\n      const labels = provider.getLabelKeys() || [];\n      const preferredLabel = PREFERRED_LABELS.find((l) => labels.includes(l));\n      if (preferredLabel) {\n        const values = await provider.getLabelValues(preferredLabel);\n        const userExamples = shuffle(values)\n          .slice(0, EXAMPLES_LIMIT)\n          .map((value) => `{${preferredLabel}=\"${value}\"}`);\n        this.setState({ userExamples });\n      }\n    } else {\n      this.scheduleUserLabelChecking();\n    }\n  };\n\n  renderExpression(expr: string) {\n    const { onClickExample } = this.props;\n\n    return (\n      <div className=\"cheat-sheet-item__example\" key={expr} onClick={(e) => onClickExample({ refId: 'A', expr })}>\n        <code>{expr}</code>\n      </div>\n    );\n  }\n\n  render() {\n    const { userExamples } = this.state;\n\n    return (\n      <div>\n        <h2>Loki Cheat Sheet</h2>\n        <div className=\"cheat-sheet-item\">\n          <div className=\"cheat-sheet-item__title\">See your logs</div>\n          <div className=\"cheat-sheet-item__label\">Start by selecting a log stream from the Log labels selector.</div>\n          <div className=\"cheat-sheet-item__label\">\n            Alternatively, you can write a stream selector into the query field:\n          </div>\n          {this.renderExpression('{job=\"default/prometheus\"}')}\n          {userExamples !== DEFAULT_EXAMPLES && userExamples.length > 0 ? (\n            <div>\n              <div className=\"cheat-sheet-item__label\">Here are some example streams from your logs:</div>\n              {userExamples.map((example) => this.renderExpression(example))}\n            </div>\n          ) : null}\n        </div>\n        <div className=\"cheat-sheet-item\">\n          <div className=\"cheat-sheet-item__title\">Combine stream selectors</div>\n          {this.renderExpression('{app=\"cassandra\",namespace=\"prod\"}')}\n          <div className=\"cheat-sheet-item__label\">Returns all log lines from streams that have both labels.</div>\n        </div>\n\n        <div className=\"cheat-sheet-item\">\n          <div className=\"cheat-sheet-item__title\">Filtering for search terms.</div>\n          {this.renderExpression('{app=\"cassandra\"} |~ \"(duration|latency)s*(=|is|of)s*[d.]+\"')}\n          {this.renderExpression('{app=\"cassandra\"} |= \"exact match\"')}\n          {this.renderExpression('{app=\"cassandra\"} != \"do not match\"')}\n          <div className=\"cheat-sheet-item__label\">\n            <a href=\"https://grafana.com/docs/loki/latest/logql/#log-pipeline\" target=\"logql\">\n              LogQL\n            </a>{' '}\n            supports exact and regular expression filters.\n          </div>\n        </div>\n        {LOGQL_EXAMPLES.map((item) => (\n          <div className=\"cheat-sheet-item\" key={item.expression}>\n            <div className=\"cheat-sheet-item__title\">{item.title}</div>\n            {this.renderExpression(item.expression)}\n            <div className=\"cheat-sheet-item__label\">{item.label}</div>\n          </div>\n        ))}\n      </div>\n    );\n  }\n}\n","// Libraries\nimport React, { memo } from 'react';\n\n// Types\nimport { ExploreQueryFieldProps } from '@grafana/data';\nimport { LokiDatasource } from '../datasource';\nimport { LokiQuery, LokiOptions } from '../types';\nimport { LokiQueryField } from './LokiQueryField';\nimport { LokiOptionFields } from './LokiOptionFields';\n\ntype Props = ExploreQueryFieldProps<LokiDatasource, LokiQuery, LokiOptions>;\n\nexport function LokiExploreQueryEditor(props: Props) {\n  const { query, data, datasource, history, onChange, onRunQuery, range } = props;\n\n  return (\n    <LokiQueryField\n      datasource={datasource}\n      query={query}\n      onChange={onChange}\n      onBlur={() => {}}\n      onRunQuery={onRunQuery}\n      history={history}\n      data={data}\n      range={range}\n      ExtraFieldElement={\n        <LokiOptionFields\n          queryType={query.instant ? 'instant' : 'range'}\n          lineLimitValue={query?.maxLines?.toString() || ''}\n          query={query}\n          onRunQuery={onRunQuery}\n          onChange={onChange}\n        />\n      }\n    />\n  );\n}\n\nexport default memo(LokiExploreQueryEditor);\n","// Libraries\nimport React from 'react';\n\n// Types\nimport { InlineFormLabel } from '@grafana/ui';\nimport { LokiQueryField } from './LokiQueryField';\nimport { LokiOptionFields } from './LokiOptionFields';\nimport { LokiQueryEditorProps } from './types';\n\nexport function LokiQueryEditor(props: LokiQueryEditorProps) {\n  const { query, data, datasource, onChange, onRunQuery, range } = props;\n\n  const onLegendChange = (e: React.SyntheticEvent<HTMLInputElement>) => {\n    const nextQuery = { ...query, legendFormat: e.currentTarget.value };\n    onChange(nextQuery);\n  };\n\n  const legendField = (\n    <div className=\"gf-form-inline\">\n      <div className=\"gf-form\">\n        <InlineFormLabel\n          width={6}\n          tooltip=\"Controls the name of the time series, using name or pattern. For example\n        {{hostname}} will be replaced with label value for the label hostname. The legend only applies to metric queries.\"\n        >\n          Legend\n        </InlineFormLabel>\n        <input\n          type=\"text\"\n          className=\"gf-form-input\"\n          placeholder=\"legend format\"\n          value={query.legendFormat || ''}\n          onChange={onLegendChange}\n          onBlur={onRunQuery}\n        />\n      </div>\n    </div>\n  );\n\n  return (\n    <LokiQueryField\n      datasource={datasource}\n      query={query}\n      onChange={onChange}\n      onRunQuery={onRunQuery}\n      onBlur={onRunQuery}\n      history={[]}\n      data={data}\n      data-testid={testIds.editor}\n      range={range}\n      ExtraFieldElement={\n        <>\n          <LokiOptionFields\n            queryType={query.instant ? 'instant' : 'range'}\n            lineLimitValue={query?.maxLines?.toString() || ''}\n            query={query}\n            onRunQuery={onRunQuery}\n            onChange={onChange}\n            runOnBlur={true}\n          />\n          {legendField}\n        </>\n      }\n    />\n  );\n}\n\nexport const testIds = {\n  editor: 'loki-editor',\n};\n","import React from 'react';\nimport { LokiQueryField } from './LokiQueryField';\nimport { LokiQueryEditorProps } from './types';\n\nexport function LokiQueryEditorForAlerting(props: LokiQueryEditorProps) {\n  const { query, data, datasource, onChange, onRunQuery } = props;\n\n  return (\n    <LokiQueryField\n      datasource={datasource}\n      query={query}\n      onChange={onChange}\n      onRunQuery={onRunQuery}\n      onBlur={onRunQuery}\n      history={[]}\n      data={data}\n      placeholder=\"Enter a Loki query\"\n      data-testid={testIds.editor}\n    />\n  );\n}\n\nexport const testIds = {\n  editor: 'loki-editor-cloud-alerting',\n};\n","import React, { memo } from 'react';\nimport { CoreApp } from '@grafana/data';\nimport { LokiQueryEditorProps } from './types';\nimport { LokiQueryEditor } from './LokiQueryEditor';\nimport { LokiQueryEditorForAlerting } from './LokiQueryEditorForAlerting';\n\nexport function LokiQueryEditorByApp(props: LokiQueryEditorProps) {\n  const { app } = props;\n\n  switch (app) {\n    case CoreApp.CloudAlerting:\n      return <LokiQueryEditorForAlerting {...props} />;\n    default:\n      return <LokiQueryEditor {...props} />;\n  }\n}\n\nexport default memo(LokiQueryEditorByApp);\n","import { LokiQuery } from './types';\n/**\n * Just a simple wrapper for a react component that is actually implementing the query editor.\n */\nexport class LokiAnnotationsQueryCtrl {\n  static templateUrl = 'partials/annotations.editor.html';\n  declare annotation: any;\n\n  /** @ngInject */\n  constructor($scope: any) {\n    this.annotation = $scope.ctrl.annotation;\n    this.annotation.target = this.annotation.target || {};\n    this.onQueryChange = this.onQueryChange.bind(this);\n  }\n\n  onQueryChange(query: LokiQuery) {\n    this.annotation.expr = query.expr;\n    this.annotation.maxLines = query.maxLines;\n    this.annotation.instant = query.instant;\n  }\n}\n","import React from 'react';\nimport { LegacyForms } from '@grafana/ui';\nconst { FormField } = LegacyForms;\n\ntype Props = {\n  value: string;\n  onChange: (value: string) => void;\n};\n\nexport const MaxLinesField = (props: Props) => {\n  const { value, onChange } = props;\n  return (\n    <FormField\n      label=\"Maximum lines\"\n      labelWidth={11}\n      inputWidth={20}\n      inputEl={\n        <input\n          type=\"number\"\n          className=\"gf-form-input width-8 gf-form-input--has-help-icon\"\n          value={value}\n          onChange={(event) => onChange(event.currentTarget.value)}\n          spellCheck={false}\n          placeholder=\"1000\"\n        />\n      }\n      tooltip={\n        <>\n          Loki queries must contain a limit of the maximum number of lines returned (default: 1000). Increase this limit\n          to have a bigger result set for ad-hoc analysis. Decrease this limit if your browser becomes sluggish when\n          displaying the log results.\n        </>\n      }\n    />\n  );\n};\n","import React, { useEffect, useState } from 'react';\nimport { css } from '@emotion/css';\nimport { Button, DataLinkInput, stylesFactory, LegacyForms } from '@grafana/ui';\nimport { VariableSuggestion } from '@grafana/data';\nimport { DataSourcePicker } from '@grafana/runtime';\nimport { DerivedFieldConfig } from '../types';\nimport { usePrevious } from 'react-use';\n\nconst { Switch, FormField } = LegacyForms;\n\nconst getStyles = stylesFactory(() => ({\n  row: css`\n    display: flex;\n    align-items: baseline;\n  `,\n  nameField: css`\n    flex: 2;\n  `,\n  regexField: css`\n    flex: 3;\n  `,\n}));\n\ntype Props = {\n  value: DerivedFieldConfig;\n  onChange: (value: DerivedFieldConfig) => void;\n  onDelete: () => void;\n  suggestions: VariableSuggestion[];\n  className?: string;\n};\nexport const DerivedField = (props: Props) => {\n  const { value, onChange, onDelete, suggestions, className } = props;\n  const styles = getStyles();\n  const [showInternalLink, setShowInternalLink] = useState(!!value.datasourceUid);\n  const previousUid = usePrevious(value.datasourceUid);\n\n  // Force internal link visibility change if uid changed outside of this component.\n  useEffect(() => {\n    if (!previousUid && value.datasourceUid && !showInternalLink) {\n      setShowInternalLink(true);\n    }\n    if (previousUid && !value.datasourceUid && showInternalLink) {\n      setShowInternalLink(false);\n    }\n  }, [previousUid, value.datasourceUid, showInternalLink]);\n\n  const handleChange = (field: keyof typeof value) => (event: React.ChangeEvent<HTMLInputElement>) => {\n    onChange({\n      ...value,\n      [field]: event.currentTarget.value,\n    });\n  };\n\n  return (\n    <div className={className}>\n      <div className={styles.row}>\n        <FormField\n          className={styles.nameField}\n          labelWidth={5}\n          // A bit of a hack to prevent using default value for the width from FormField\n          inputWidth={null}\n          label=\"Name\"\n          type=\"text\"\n          value={value.name}\n          onChange={handleChange('name')}\n        />\n        <FormField\n          className={styles.regexField}\n          inputWidth={null}\n          label=\"Regex\"\n          type=\"text\"\n          value={value.matcherRegex}\n          onChange={handleChange('matcherRegex')}\n          tooltip={\n            'Use to parse and capture some part of the log message. You can use the captured groups in the template.'\n          }\n        />\n        <Button\n          variant=\"destructive\"\n          title=\"Remove field\"\n          icon=\"times\"\n          onClick={(event) => {\n            event.preventDefault();\n            onDelete();\n          }}\n          className={css`\n            margin-left: 8px;\n          `}\n        />\n      </div>\n\n      <FormField\n        label={showInternalLink ? 'Query' : 'URL'}\n        labelWidth={5}\n        inputEl={\n          <DataLinkInput\n            placeholder={showInternalLink ? '${__value.raw}' : 'http://example.com/${__value.raw}'}\n            value={value.url || ''}\n            onChange={(newValue) =>\n              onChange({\n                ...value,\n                url: newValue,\n              })\n            }\n            suggestions={suggestions}\n          />\n        }\n        className={css`\n          width: 100%;\n        `}\n      />\n\n      <div className={styles.row}>\n        <Switch\n          label=\"Internal link\"\n          checked={showInternalLink}\n          onChange={() => {\n            if (showInternalLink) {\n              onChange({\n                ...value,\n                datasourceUid: undefined,\n              });\n            }\n            setShowInternalLink(!showInternalLink);\n          }}\n        />\n\n        {showInternalLink && (\n          <DataSourcePicker\n            tracing={true}\n            onChange={(ds) =>\n              onChange({\n                ...value,\n                datasourceUid: ds.uid,\n              })\n            }\n            current={value.datasourceUid}\n          />\n        )}\n      </div>\n    </div>\n  );\n};\n","import React, { useState } from 'react';\nimport { css } from '@emotion/css';\nimport cx from 'classnames';\nimport { LegacyForms } from '@grafana/ui';\nconst { FormField } = LegacyForms;\nimport { DerivedFieldConfig } from '../types';\nimport { ArrayVector, Field, FieldType, LinkModel } from '@grafana/data';\nimport { getFieldLinksForExplore } from '../../../../features/explore/utils/links';\n\ntype Props = {\n  derivedFields?: DerivedFieldConfig[];\n  className?: string;\n};\nexport const DebugSection = (props: Props) => {\n  const { derivedFields, className } = props;\n  const [debugText, setDebugText] = useState('');\n\n  let debugFields: DebugField[] = [];\n  if (debugText && derivedFields) {\n    debugFields = makeDebugFields(derivedFields, debugText);\n  }\n\n  return (\n    <div className={className}>\n      <FormField\n        labelWidth={12}\n        label={'Debug log message'}\n        inputEl={\n          <textarea\n            placeholder={'Paste an example log line here to test the regular expressions of your derived fields'}\n            className={cx(\n              'gf-form-input gf-form-textarea',\n              css`\n                width: 100%;\n              `\n            )}\n            value={debugText}\n            onChange={(event) => setDebugText(event.currentTarget.value)}\n          />\n        }\n      />\n      {!!debugFields.length && <DebugFields fields={debugFields} />}\n    </div>\n  );\n};\n\ntype DebugFieldItemProps = {\n  fields: DebugField[];\n};\nconst DebugFields = ({ fields }: DebugFieldItemProps) => {\n  return (\n    <table className={'filter-table'}>\n      <thead>\n        <tr>\n          <th>Name</th>\n          <th>Value</th>\n          <th>Url</th>\n        </tr>\n      </thead>\n      <tbody>\n        {fields.map((field) => {\n          let value: any = field.value;\n          if (field.error) {\n            value = field.error.message;\n          } else if (field.href) {\n            value = <a href={field.href}>{value}</a>;\n          }\n          return (\n            <tr key={`${field.name}=${field.value}`}>\n              <td>{field.name}</td>\n              <td>{value}</td>\n              <td>{field.href ? <a href={field.href}>{field.href}</a> : ''}</td>\n            </tr>\n          );\n        })}\n      </tbody>\n    </table>\n  );\n};\n\ntype DebugField = {\n  name: string;\n  error?: any;\n  value?: string;\n  href?: string;\n};\n\nfunction makeDebugFields(derivedFields: DerivedFieldConfig[], debugText: string): DebugField[] {\n  return derivedFields\n    .filter((field) => field.name && field.matcherRegex)\n    .map((field) => {\n      try {\n        const testMatch = debugText.match(field.matcherRegex);\n        const value = testMatch && testMatch[1];\n        let link: LinkModel<Field> | null = null;\n\n        if (field.url && value) {\n          link = getFieldLinksForExplore({\n            field: {\n              name: '',\n              type: FieldType.string,\n              values: new ArrayVector([value]),\n              config: {\n                links: [{ title: '', url: field.url }],\n              },\n            },\n            rowIndex: 0,\n            range: {} as any,\n          })[0];\n        }\n\n        return {\n          name: field.name,\n          value: value || '<no match>',\n          href: link && link.href,\n        } as DebugField;\n      } catch (error) {\n        return {\n          name: field.name,\n          error,\n        } as DebugField;\n      }\n    });\n}\n","import React, { useState } from 'react';\nimport { css } from '@emotion/css';\nimport { Button, useTheme2 } from '@grafana/ui';\nimport { GrafanaTheme2, VariableOrigin, DataLinkBuiltInVars } from '@grafana/data';\nimport { DerivedFieldConfig } from '../types';\nimport { DerivedField } from './DerivedField';\nimport { DebugSection } from './DebugSection';\n\nconst getStyles = (theme: GrafanaTheme2) => ({\n  infoText: css`\n    padding-bottom: ${theme.spacing(2)};\n    color: ${theme.colors.text.secondary};\n  `,\n  derivedField: css`\n    margin-bottom: ${theme.spacing(1)};\n  `,\n});\n\ntype Props = {\n  value?: DerivedFieldConfig[];\n  onChange: (value: DerivedFieldConfig[]) => void;\n};\n\nexport const DerivedFields = (props: Props) => {\n  const { value, onChange } = props;\n  const theme = useTheme2();\n  const styles = getStyles(theme);\n\n  const [showDebug, setShowDebug] = useState(false);\n\n  return (\n    <>\n      <h3 className=\"page-heading\">Derived fields</h3>\n\n      <div className={styles.infoText}>\n        Derived fields can be used to extract new fields from a log message and create a link from its value.\n      </div>\n\n      <div className=\"gf-form-group\">\n        {value &&\n          value.map((field, index) => {\n            return (\n              <DerivedField\n                className={styles.derivedField}\n                key={index}\n                value={field}\n                onChange={(newField) => {\n                  const newDerivedFields = [...value];\n                  newDerivedFields.splice(index, 1, newField);\n                  onChange(newDerivedFields);\n                }}\n                onDelete={() => {\n                  const newDerivedFields = [...value];\n                  newDerivedFields.splice(index, 1);\n                  onChange(newDerivedFields);\n                }}\n                suggestions={[\n                  {\n                    value: DataLinkBuiltInVars.valueRaw,\n                    label: 'Raw value',\n                    documentation: 'Exact string captured by the regular expression',\n                    origin: VariableOrigin.Value,\n                  },\n                ]}\n              />\n            );\n          })}\n        <div>\n          <Button\n            variant=\"secondary\"\n            className={css`\n              margin-right: 10px;\n            `}\n            icon=\"plus\"\n            onClick={(event) => {\n              event.preventDefault();\n              const newDerivedFields = [...(value || []), { name: '', matcherRegex: '' }];\n              onChange(newDerivedFields);\n            }}\n          >\n            Add\n          </Button>\n\n          {value && value.length > 0 && (\n            <Button variant=\"secondary\" type=\"button\" onClick={() => setShowDebug(!showDebug)}>\n              {showDebug ? 'Hide example log message' : 'Show example log message'}\n            </Button>\n          )}\n        </div>\n      </div>\n\n      {showDebug && (\n        <div className=\"gf-form-group\">\n          <DebugSection\n            className={css`\n              margin-bottom: 10px;\n            `}\n            derivedFields={value}\n          />\n        </div>\n      )}\n    </>\n  );\n};\n","import React from 'react';\nimport { DataSourcePluginOptionsEditorProps, DataSourceSettings } from '@grafana/data';\nimport { AlertingSettings, DataSourceHttpSettings } from '@grafana/ui';\nimport { LokiOptions } from '../types';\nimport { MaxLinesField } from './MaxLinesField';\nimport { DerivedFields } from './DerivedFields';\n\nexport type Props = DataSourcePluginOptionsEditorProps<LokiOptions>;\n\nconst makeJsonUpdater = <T extends any>(field: keyof LokiOptions) => (\n  options: DataSourceSettings<LokiOptions>,\n  value: T\n): DataSourceSettings<LokiOptions> => {\n  return {\n    ...options,\n    jsonData: {\n      ...options.jsonData,\n      [field]: value,\n    },\n  };\n};\n\nconst setMaxLines = makeJsonUpdater('maxLines');\nconst setDerivedFields = makeJsonUpdater('derivedFields');\n\nexport const ConfigEditor = (props: Props) => {\n  const { options, onOptionsChange } = props;\n\n  return (\n    <>\n      <DataSourceHttpSettings\n        defaultUrl={'http://localhost:3100'}\n        dataSourceConfig={options}\n        showAccessOptions={false}\n        onChange={onOptionsChange}\n      />\n\n      <AlertingSettings<LokiOptions> options={options} onOptionsChange={onOptionsChange} />\n\n      <div className=\"gf-form-group\">\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <MaxLinesField\n              value={options.jsonData.maxLines || ''}\n              onChange={(value) => onOptionsChange(setMaxLines(options, value))}\n            />\n          </div>\n        </div>\n      </div>\n\n      <DerivedFields\n        value={options.jsonData.derivedFields}\n        onChange={(value) => onOptionsChange(setDerivedFields(options, value))}\n      />\n    </>\n  );\n};\n","import { DataSourcePlugin } from '@grafana/data';\nimport Datasource from './datasource';\n\nimport LokiCheatSheet from './components/LokiCheatSheet';\nimport LokiExploreQueryEditor from './components/LokiExploreQueryEditor';\nimport LokiQueryEditorByApp from './components/LokiQueryEditorByApp';\nimport { LokiAnnotationsQueryCtrl } from './LokiAnnotationsQueryCtrl';\nimport { ConfigEditor } from './configuration/ConfigEditor';\n\nexport const plugin = new DataSourcePlugin(Datasource)\n  .setQueryEditor(LokiQueryEditorByApp)\n  .setConfigEditor(ConfigEditor)\n  .setExploreQueryField(LokiExploreQueryEditor)\n  .setQueryEditorHelp(LokiCheatSheet)\n  .setAnnotationQueryCtrl(LokiAnnotationsQueryCtrl);\n","import { Grammar } from 'prismjs';\nimport { CompletionItem } from '@grafana/ui';\n\nconst AGGREGATION_OPERATORS: CompletionItem[] = [\n  {\n    label: 'sum',\n    insertText: 'sum',\n    documentation: 'Calculate sum over dimensions',\n  },\n  {\n    label: 'min',\n    insertText: 'min',\n    documentation: 'Select minimum over dimensions',\n  },\n  {\n    label: 'max',\n    insertText: 'max',\n    documentation: 'Select maximum over dimensions',\n  },\n  {\n    label: 'avg',\n    insertText: 'avg',\n    documentation: 'Calculate the average over dimensions',\n  },\n  {\n    label: 'stddev',\n    insertText: 'stddev',\n    documentation: 'Calculate population standard deviation over dimensions',\n  },\n  {\n    label: 'stdvar',\n    insertText: 'stdvar',\n    documentation: 'Calculate population standard variance over dimensions',\n  },\n  {\n    label: 'count',\n    insertText: 'count',\n    documentation: 'Count number of elements in the vector',\n  },\n  {\n    label: 'bottomk',\n    insertText: 'bottomk',\n    documentation: 'Smallest k elements by sample value',\n  },\n  {\n    label: 'topk',\n    insertText: 'topk',\n    documentation: 'Largest k elements by sample value',\n  },\n];\n\nexport const PIPE_PARSERS: CompletionItem[] = [\n  {\n    label: 'json',\n    insertText: 'json',\n    documentation: 'Extracting labels from the log line using json parser. Only available in Loki 2.0+.',\n  },\n  {\n    label: 'regexp',\n    insertText: 'regexp \"\"',\n    documentation: 'Extracting labels from the log line using regexp parser. Only available in Loki 2.0+.',\n    move: -1,\n  },\n  {\n    label: 'logfmt',\n    insertText: 'logfmt',\n    documentation: 'Extracting labels from the log line using logfmt parser. Only available in Loki 2.0+.',\n  },\n  {\n    label: 'pattern',\n    insertText: 'pattern',\n    documentation: 'Extracting labels from the log line using pattern parser. Only available in Loki 2.3+.',\n  },\n];\n\nexport const PIPE_OPERATORS: CompletionItem[] = [\n  {\n    label: 'unwrap',\n    insertText: 'unwrap',\n    detail: 'unwrap identifier',\n    documentation:\n      'Take labels and use the values as sample data for metric aggregations. Only available in Loki 2.0+.',\n  },\n  {\n    label: 'label_format',\n    insertText: 'label_format',\n    documentation:\n      'Use to rename, modify or add labels. For example, | label_format foo=bar . Only available in Loki 2.0+.',\n  },\n  {\n    label: 'line_format',\n    insertText: 'line_format',\n    documentation:\n      'Rewrites log line content. For example, | line_format \"{{.query}} {{.duration}}\" . Only available in Loki 2.0+.',\n  },\n];\n\nexport const RANGE_VEC_FUNCTIONS = [\n  {\n    insertText: 'avg_over_time',\n    label: 'avg_over_time',\n    detail: 'avg_over_time(range-vector)',\n    documentation: 'The average of all values in the specified interval. Only available in Loki 2.0+.',\n  },\n  {\n    insertText: 'min_over_time',\n    label: 'min_over_time',\n    detail: 'min_over_time(range-vector)',\n    documentation: 'The minimum of all values in the specified interval. Only available in Loki 2.0+.',\n  },\n  {\n    insertText: 'max_over_time',\n    label: 'max_over_time',\n    detail: 'max_over_time(range-vector)',\n    documentation: 'The maximum of all values in the specified interval. Only available in Loki 2.0+.',\n  },\n  {\n    insertText: 'sum_over_time',\n    label: 'sum_over_time',\n    detail: 'sum_over_time(range-vector)',\n    documentation: 'The sum of all values in the specified interval. Only available in Loki 2.0+.',\n  },\n  {\n    insertText: 'count_over_time',\n    label: 'count_over_time',\n    detail: 'count_over_time(range-vector)',\n    documentation: 'The count of all values in the specified interval.',\n  },\n  {\n    insertText: 'stdvar_over_time',\n    label: 'stdvar_over_time',\n    detail: 'stdvar_over_time(range-vector)',\n    documentation:\n      'The population standard variance of the values in the specified interval. Only available in Loki 2.0+.',\n  },\n  {\n    insertText: 'stddev_over_time',\n    label: 'stddev_over_time',\n    detail: 'stddev_over_time(range-vector)',\n    documentation:\n      'The population standard deviation of the values in the specified interval. Only available in Loki 2.0+.',\n  },\n  {\n    insertText: 'quantile_over_time',\n    label: 'quantile_over_time',\n    detail: 'quantile_over_time(scalar, range-vector)',\n    documentation: 'The φ-quantile (0 ≤ φ ≤ 1) of the values in the specified interval. Only available in Loki 2.0+.',\n  },\n  {\n    insertText: 'bytes_over_time',\n    label: 'bytes_over_time',\n    detail: 'bytes_over_time(range-vector)',\n    documentation: 'Counts the amount of bytes used by each log stream for a given range',\n  },\n  {\n    insertText: 'bytes_rate',\n    label: 'bytes_rate',\n    detail: 'bytes_rate(range-vector)',\n    documentation: 'Calculates the number of bytes per second for each stream.',\n  },\n  {\n    insertText: 'rate',\n    label: 'rate',\n    detail: 'rate(v range-vector)',\n    documentation:\n      \"Calculates the per-second average rate of increase of the time series in the range vector. Breaks in monotonicity (such as counter resets due to target restarts) are automatically adjusted for. Also, the calculation extrapolates to the ends of the time range, allowing for missed scrapes or imperfect alignment of scrape cycles with the range's time period.\",\n  },\n];\n\nexport const FUNCTIONS = [...AGGREGATION_OPERATORS, ...RANGE_VEC_FUNCTIONS];\n\nconst tokenizer: Grammar = {\n  comment: {\n    pattern: /#.*/,\n  },\n  'context-aggregation': {\n    pattern: /((without|by)\\s*)\\([^)]*\\)/, // by ()\n    lookbehind: true,\n    inside: {\n      'label-key': {\n        pattern: /[^(),\\s][^,)]*[^),\\s]*/,\n        alias: 'attr-name',\n      },\n      punctuation: /[()]/,\n    },\n  },\n  'context-labels': {\n    pattern: /\\{[^}]*(?=}?)/,\n    greedy: true,\n    inside: {\n      comment: {\n        pattern: /#.*/,\n      },\n      'label-key': {\n        pattern: /[a-z_]\\w*(?=\\s*(=|!=|=~|!~))/,\n        alias: 'attr-name',\n        greedy: true,\n      },\n      'label-value': {\n        pattern: /\"(?:\\\\.|[^\\\\\"])*\"/,\n        greedy: true,\n        alias: 'attr-value',\n      },\n      punctuation: /[{]/,\n    },\n  },\n  'context-pipe': {\n    pattern: /\\s\\|[^=~]\\s?\\w*/i,\n    inside: {\n      'pipe-operator': {\n        pattern: /\\|/i,\n        alias: 'operator',\n      },\n      'pipe-operations': {\n        pattern: new RegExp(`${[...PIPE_PARSERS, ...PIPE_OPERATORS].map((f) => f.label).join('|')}`, 'i'),\n        alias: 'keyword',\n      },\n    },\n  },\n  function: new RegExp(`\\\\b(?:${FUNCTIONS.map((f) => f.label).join('|')})(?=\\\\s*\\\\()`, 'i'),\n  'context-range': [\n    {\n      pattern: /\\[[^\\]]*(?=\\])/, // [1m]\n      inside: {\n        'range-duration': {\n          pattern: /\\b\\d+[smhdwy]\\b/i,\n          alias: 'number',\n        },\n      },\n    },\n    {\n      pattern: /(offset\\s+)\\w+/, // offset 1m\n      lookbehind: true,\n      inside: {\n        'range-duration': {\n          pattern: /\\b\\d+[smhdwy]\\b/i,\n          alias: 'number',\n        },\n      },\n    },\n  ],\n  number: /\\b-?\\d+((\\.\\d*)?([eE][+-]?\\d+)?)?\\b/,\n  operator: /\\s?(\\|[=~]?|!=?|<(?:=>?|<|>)?|>[>=]?)\\s?/i,\n  punctuation: /[{}()`,.]/,\n};\n\nexport default tokenizer;\n","import { useEffect, useRef } from 'react';\nvar usePrevious = function (state) {\n    var ref = useRef();\n    useEffect(function () {\n        ref.current = state;\n    });\n    return ref.current;\n};\nexport default usePrevious;\n"],"sourceRoot":""}