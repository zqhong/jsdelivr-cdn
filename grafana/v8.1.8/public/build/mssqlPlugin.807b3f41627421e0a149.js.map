{"version":3,"sources":["webpack:///./public/app/features/datasources/utils/passwordHandlers.ts","webpack:///./public/app/plugins/datasource/mssql/response_parser.ts","webpack:///./public/app/plugins/datasource/mssql/datasource.ts","webpack:///./public/app/plugins/datasource/mssql/query_ctrl.ts","webpack:///./public/app/plugins/datasource/mssql/config_ctrl.ts","webpack:///./public/app/plugins/datasource/mssql/module.ts"],"names":["PasswordFieldEnum","createResetHandler","ctrl","field","event","preventDefault","current","undefined","secureJsonFields","secureJsonData","createChangeHandler","currentTarget","value","ResponseParser","transformMetricFindResponse","raw","frames","toDataQueryResponse","data","length","frame","values","textField","fields","find","f","name","valueField","i","push","text","get","flatMap","toArray","map","v","Array","from","Set","options","timeField","Promise","reject","message","timeEndField","tagsField","list","timeEnd","Math","floor","annotation","time","tags","trim","split","MssqlDatasource","DataSourceWithBackend","constructor","instanceSettings","templateSrv","getTemplateSrv","timeSrv","getTimeSrv","super","this","id","responseParser","settingsData","jsonData","interval","timeInterval","interpolateVariable","variable","multi","includeAll","replace","_map","val","join","interpolateVariablesInQueries","queries","scopedVars","expandedQueries","query","datasource","rawSql","rawQuery","applyTemplateVariables","target","refId","datasourceId","format","getBackendSrv","fetch","url","method","range","valueOf","toString","to","requestId","pipe","async","transformAnnotationResponse","res","toPromise","filterQuery","hide","metricFindQuery","optionalOptions","timeRange","interpolatedQuery","rsp","testDatasource","intervalMs","maxDataPoints","mapTo","status","catchError","err","of","toTestingStatus","targetContainsTemplate","variableExists","MssqlQueryCtrl","QueryCtrl","$scope","$injector","alias","formats","panelCtrl","panel","type","events","on","PanelEvents","dataReceived","onDataReceived","bind","dataError","onDataError","dataList","lastQueryError","lastQueryMeta","meta","results","queryRes","error","MssqlConfigCtrl","encrypt","authenticationType","onPasswordReset","Password","onPasswordChange","showUserCredentials","onAuthenticationTypeChange","user","password","MssqlAnnotationsQueryCtrl","plugin","DataSourcePlugin","setQueryCtrl","setConfigCtrl","setAnnotationQueryCtrl"],"mappings":"4FAOO,IAAKA,EAPZ,sG,SAOYA,K,oBAAAA,E,uCAAAA,M,KAqBL,MAAMC,EAAqB,CAACC,EAAYC,IAC7CC,IAEAA,EAAMC,iBAENH,EAAKI,QAAQH,QAASI,EACtBL,EAAKI,QAAQE,iBAAiBL,IAAS,EACvCD,EAAKI,QAAQG,eAAiBP,EAAKI,QAAQG,gBAAkB,GAC7DP,EAAKI,QAAQG,eAAeN,GAAS,IAG1BO,EAAsB,CAACR,EAAWC,IAC7CC,IAEAF,EAAKI,QAAQG,eAAiBP,EAAKI,QAAQG,gBAAkB,GAC7DP,EAAKI,QAAQG,eAAeN,GAASC,EAAMO,cAAcC,Q,qHCxC5C,MAAMC,EACnBC,4BAA4BC,GAC1B,MAAMC,EAASC,8BAAoBF,GAAKG,KAExC,IAAKF,IAAWA,EAAOG,OACrB,MAAO,GAGT,MAAMC,EAAQJ,EAAO,GAEfK,EAA4B,GAC5BC,EAAYF,EAAMG,OAAOC,KAAMC,GAAiB,WAAXA,EAAEC,MACvCC,EAAaP,EAAMG,OAAOC,KAAMC,GAAiB,YAAXA,EAAEC,MAE9C,GAAIJ,GAAaK,EACf,IAAK,IAAIC,EAAI,EAAGA,EAAIN,EAAUD,OAAOF,OAAQS,IAC3CP,EAAOQ,KAAK,CAAEC,KAAM,GAAKR,EAAUD,OAAOU,IAAIH,GAAIhB,MAAO,GAAKe,EAAWN,OAAOU,IAAIH,UAGtFP,EAAOQ,QACFT,EAAMG,OACNS,QAASP,GAAMA,EAAEJ,OAAOY,WACxBC,IAAKC,IAAD,CACHL,KAAMK,MAKd,OAAOC,MAAMC,KAAK,IAAIC,IAAIjB,EAAOa,IAAKC,GAAMA,EAAEL,QAAQI,IAAKJ,IAAD,YAAW,CACnEA,OACAlB,MAAK,UAAES,EAAOG,KAAMW,GAAMA,EAAEL,OAASA,UAAhC,aAAE,EAAqClB,SAIf,kCAAC2B,EAAcrB,GAC9C,MAAMF,EAASC,8BAAoB,CAAEC,KAAMA,IAAQA,KACnD,IAAKF,IAAWA,EAAOG,OACrB,MAAO,GAET,MAAMC,EAAQJ,EAAO,GACfwB,EAAYpB,EAAMG,OAAOC,KAAMC,GAAiB,SAAXA,EAAEC,MAE7C,IAAKc,EACH,OAAOC,QAAQC,OAAO,CAAEC,QAAS,gFAGnC,MAAMC,EAAexB,EAAMG,OAAOC,KAAMC,GAAiB,YAAXA,EAAEC,MAC1CJ,EAAYF,EAAMG,OAAOC,KAAMC,GAAiB,SAAXA,EAAEC,MACvCmB,EAAYzB,EAAMG,OAAOC,KAAMC,GAAiB,SAAXA,EAAEC,MAEvCoB,EAA0B,GAChC,IAAK,IAAIlB,EAAI,EAAGA,EAAIR,EAAMD,OAAQS,IAAK,CACrC,MAAMmB,EAAUH,GAAgBA,EAAavB,OAAOU,IAAIH,GAAKoB,KAAKC,MAAML,EAAavB,OAAOU,IAAIH,SAAMrB,EACtGuC,EAAKjB,KAAK,CACRqB,WAAYX,EAAQW,WACpBC,KAAMH,KAAKC,MAAMT,EAAUnB,OAAOU,IAAIH,IACtCmB,UACAjB,KAAMR,GAAaA,EAAUD,OAAOU,IAAIH,GAAKN,EAAUD,OAAOU,IAAIH,GAAK,GACvEwB,KACEP,GAAaA,EAAUxB,OAAOU,IAAIH,GAC9BiB,EAAUxB,OACPU,IAAIH,GACJyB,OACAC,MAAM,WACT,KAIV,OAAOR,G,+WC3DJ,MAAMS,UAAwBC,wBAMnCC,YACEC,EACiBC,EAA2BC,cAC3BC,EAAmBC,eAEpCC,MAAML,GADN,yGAFiBC,cAEjB,KADiBE,UAGjBG,KAAKtC,KAAOgC,EAAiBhC,KAC7BsC,KAAKC,GAAKP,EAAiBO,GAC3BD,KAAKE,eAAiB,IAAIrD,EAC1B,MAAMsD,EAAeT,EAAiBU,UAAa,GACnDJ,KAAKK,SAAWF,EAAaG,cAAgB,KAG/CC,oBAAoB3D,EAAY4D,GAC9B,GAAqB,iBAAV5D,EACT,OAAI4D,EAASC,OAASD,EAASE,WACtB,IAAM9D,EAAM+D,QAAQ,KAAO,MAAO,IAElC/D,EAIX,GAAqB,iBAAVA,EACT,OAAOA,EAUT,OAPqBgE,cAAKhE,EAAQiE,GACX,iBAAVjE,EACFA,EAGF,IAAMiE,EAAIF,QAAQ,KAAO,MAAO,KAErBG,KAAK,KAG3BC,8BACEC,EACAC,GAEA,IAAIC,EAAkBF,EAYtB,OAXIA,GAAWA,EAAQ7D,OAAS,IAC9B+D,EAAkBF,EAAQ9C,IAAKiD,GACP,EAAH,GACdA,EADc,CAEjBC,WAAYpB,KAAKtC,KACjB2D,OAAQrB,KAAKL,YAAYgB,QAAQQ,EAAME,OAAQJ,EAAYjB,KAAKO,qBAChEe,UAAU,MAKTJ,EAGTK,uBAAuBC,EAAoBP,GACzC,MAAO,CACLQ,MAAOD,EAAOC,MACdC,aAAc1B,KAAKC,GACnBoB,OAAQrB,KAAKL,YAAYgB,QAAQa,EAAOH,OAAQJ,EAAYjB,KAAKO,qBACjEoB,OAAQH,EAAOG,QAIE,sBAACpD,GACpB,IAAKA,EAAQW,WAAWoC,SACtB,OAAO7C,QAAQC,OAAO,CAAEC,QAAS,2CAGnC,MAAMwC,EAAQ,CACZM,MAAOlD,EAAQW,WAAWxB,KAC1BgE,aAAc1B,KAAKC,GACnBoB,OAAQrB,KAAKL,YAAYgB,QAAQpC,EAAQW,WAAWoC,SAAU/C,EAAQ0C,WAAYjB,KAAKO,qBACvFoB,OAAQ,SAGV,OAAOC,0BACJC,MAAiC,CAChCC,IAAK,gBACLC,OAAQ,OACR7E,KAAM,CACJmB,KAAME,EAAQyD,MAAM3D,KAAK4D,UAAUC,WACnCC,GAAI5D,EAAQyD,MAAMG,GAAGF,UAAUC,WAC/BlB,QAAS,CAACG,IAEZiB,UAAW7D,EAAQW,WAAWxB,OAE/B2E,KACCnE,YACEoE,eACQtC,KAAKE,eAAeqC,4BAA4BhE,EAASiE,EAAItF,QAGxEuF,YAGLC,YAAYvB,GACV,OAAQA,EAAMwB,KAGhBC,gBAAgBzB,EAAe0B,GAC7B,IAAIpB,EAAQ,UACRoB,GAAmBA,EAAgBrC,UAAYqC,EAAgBrC,SAAS9C,OAC1E+D,EAAQoB,EAAgBrC,SAAS9C,MAGnC,MAAMsE,EAAQhC,KAAKH,QAAQiD,YAErBC,EAAoB,CACxBtB,MAAOA,EACPC,aAAc1B,KAAKC,GACnBoB,OAAQrB,KAAKL,YAAYgB,QAAQQ,EAAO,GAAInB,KAAKO,qBACjDoB,OAAQ,SAGV,OAAOC,0BACJC,MAAiC,CAChCC,IAAK,gBACLC,OAAQ,OACR7E,KAAM,CACJmB,KAAM2D,EAAM3D,KAAK4D,UAAUC,WAC3BC,GAAIH,EAAMG,GAAGF,UAAUC,WACvBlB,QAAS,CAAC+B,IAEZX,UAAWX,IAEZY,KACCnE,YAAK8E,GACIhD,KAAKE,eAAepD,4BAA4BkG,KAG1DP,YAGLQ,iBACE,OAAOrB,0BACJC,MAAM,CACLC,IAAK,gBACLC,OAAQ,OACR7E,KAAM,CACJmB,KAAM,KACN8D,GAAI,MACJnB,QAAS,CACP,CACES,MAAO,IACPyB,WAAY,EACZC,cAAe,EACfzB,aAAc1B,KAAKC,GACnBoB,OAAQ,WACRM,OAAQ,aAKfU,KACCe,YAAM,CAAEC,OAAQ,UAAW1E,QAAS,2BACpC2E,YAAYC,GACHC,YAAGC,YAAgBF,MAG7Bd,YAGLiB,uBAAuBvC,GACrB,MAAME,EAASF,EAAME,OAAOV,QAAQ,MAAO,IAC3C,OAAOX,KAAKL,YAAYgE,eAAetC,I,oJCvKpC,MAAMuC,UAAuBC,YASlCpE,YAAYqE,EAAaC,GACvBhE,MAAM+D,EAAQC,GAD2C,2GAHhD,GAMT/D,KAAKwB,OAAOG,OAAS3B,KAAKwB,OAAOG,QAAU,cAC3C3B,KAAKwB,OAAOwC,MAAQ,GACpBhE,KAAKiE,QAAU,CACb,CAAEnG,KAAM,cAAelB,MAAO,eAC9B,CAAEkB,KAAM,QAASlB,MAAO,UAGrBoD,KAAKwB,OAAOH,SAEmB,UAA9BrB,KAAKkE,UAAUC,MAAMC,MACvBpE,KAAKwB,OAAOG,OAAS,QACrB3B,KAAKwB,OAAOH,OAAS,YAErBrB,KAAKwB,OAAOH,OApCE,kMAwClBrB,KAAKkE,UAAUG,OAAOC,GAAGC,cAAYC,aAAcxE,KAAKyE,eAAeC,KAAK1E,MAAO8D,GACnF9D,KAAKkE,UAAUG,OAAOC,GAAGC,cAAYI,UAAW3E,KAAK4E,YAAYF,KAAK1E,MAAO8D,GAG/EW,eAAeI,GAAe,MAC5B7E,KAAK8E,oBAAiBvI,EACtByD,KAAK+E,cAAL,UAAqBF,EAAS,UAA9B,aAAqB,EAAaG,KAGpCJ,YAAYrB,GACV,GAAIA,EAAIrG,MAAQqG,EAAIrG,KAAK+H,QAAS,CAChC,MAAMC,EAAW3B,EAAIrG,KAAK+H,QAAQjF,KAAKwB,OAAOC,OAC1CyD,IACFlF,KAAK8E,eAAiBI,EAASC,S,mCA1C1BvB,E,cACU,8B,wICXhB,MAAMwB,EAWX3F,YAAYqE,GAAa,wGACvB9D,KAAK1D,QAAUwH,EAAO5H,KAAKI,QAC3B0D,KAAK1D,QAAQ8D,SAASiF,QAAUrF,KAAK1D,QAAQ8D,SAASiF,SAAW,QACjErF,KAAK1D,QAAQ8D,SAASkF,mBAAqBtF,KAAK1D,QAAQ8D,SAASkF,oBAAsB,4BACvFtF,KAAKuF,gBAAkBtJ,YAAmB+D,KAAMhE,IAAkBwJ,UAClExF,KAAKyF,iBAAmB/I,YAAoBsD,KAAMhE,IAAkBwJ,UACpExF,KAAK0F,oBAAmE,2BAA7C1F,KAAK1D,QAAQ8D,SAASkF,mBAGnDK,6BAEmD,2BAA7C3F,KAAK1D,QAAQ8D,SAASkF,qBACxBtF,KAAK1D,QAAQsJ,KAAO,GACpB5F,KAAK1D,QAAQuJ,SAAW,IAG1B7F,KAAK0F,oBAAmE,2BAA7C1F,KAAK1D,QAAQ8D,SAASkF,oB,uBA3BxCF,E,cACU,wB,uCCUvB,MAAMU,EAMJrG,YAAYqE,GACV9D,KAAKd,WAAa4E,EAAO5H,KAAKgD,WAC9Bc,KAAKd,WAAWoC,SAAWtB,KAAKd,WAAWoC,UAnBzB,mM,iCAYC,oC,qBADjBwE,G,sFAYC,MAAMC,EAAS,IAAIC,mBAA8CzG,GACrE0G,aAAarC,GACbsC,cAAcd,GACde,uBAAuBL","file":"mssqlPlugin.807b3f41627421e0a149.js","sourcesContent":["/**\n * Set of handlers for secure password field in Angular components. They handle backward compatibility with\n * passwords stored in plain text fields.\n */\n\nimport { SyntheticEvent } from 'react';\n\nexport enum PasswordFieldEnum {\n  Password = 'password',\n  BasicAuthPassword = 'basicAuthPassword',\n}\n\n/**\n * Basic shape for settings controllers in at the moment mostly angular data source plugins.\n */\nexport type Ctrl = {\n  current: {\n    secureJsonFields: {\n      [key: string]: boolean;\n    };\n    secureJsonData?: {\n      [key: string]: string;\n    };\n    password?: string;\n    basicAuthPassword?: string;\n  };\n};\n\nexport const createResetHandler = (ctrl: Ctrl, field: PasswordFieldEnum) => (\n  event: SyntheticEvent<HTMLInputElement>\n) => {\n  event.preventDefault();\n  // Reset also normal plain text password to remove it and only save it in secureJsonData.\n  ctrl.current[field] = undefined;\n  ctrl.current.secureJsonFields[field] = false;\n  ctrl.current.secureJsonData = ctrl.current.secureJsonData || {};\n  ctrl.current.secureJsonData[field] = '';\n};\n\nexport const createChangeHandler = (ctrl: any, field: PasswordFieldEnum) => (\n  event: SyntheticEvent<HTMLInputElement>\n) => {\n  ctrl.current.secureJsonData = ctrl.current.secureJsonData || {};\n  ctrl.current.secureJsonData[field] = event.currentTarget.value;\n};\n","import { AnnotationEvent, DataFrame, MetricFindValue } from '@grafana/data';\nimport { BackendDataSourceResponse, toDataQueryResponse, FetchResponse } from '@grafana/runtime';\n\nexport default class ResponseParser {\n  transformMetricFindResponse(raw: FetchResponse<BackendDataSourceResponse>): MetricFindValue[] {\n    const frames = toDataQueryResponse(raw).data as DataFrame[];\n\n    if (!frames || !frames.length) {\n      return [];\n    }\n\n    const frame = frames[0];\n\n    const values: MetricFindValue[] = [];\n    const textField = frame.fields.find((f) => f.name === '__text');\n    const valueField = frame.fields.find((f) => f.name === '__value');\n\n    if (textField && valueField) {\n      for (let i = 0; i < textField.values.length; i++) {\n        values.push({ text: '' + textField.values.get(i), value: '' + valueField.values.get(i) });\n      }\n    } else {\n      values.push(\n        ...frame.fields\n          .flatMap((f) => f.values.toArray())\n          .map((v) => ({\n            text: v,\n          }))\n      );\n    }\n\n    return Array.from(new Set(values.map((v) => v.text))).map((text) => ({\n      text,\n      value: values.find((v) => v.text === text)?.value,\n    }));\n  }\n\n  async transformAnnotationResponse(options: any, data: BackendDataSourceResponse): Promise<AnnotationEvent[]> {\n    const frames = toDataQueryResponse({ data: data }).data as DataFrame[];\n    if (!frames || !frames.length) {\n      return [];\n    }\n    const frame = frames[0];\n    const timeField = frame.fields.find((f) => f.name === 'time');\n\n    if (!timeField) {\n      return Promise.reject({ message: 'Missing mandatory time column (with time column alias) in annotation query.' });\n    }\n\n    const timeEndField = frame.fields.find((f) => f.name === 'timeend');\n    const textField = frame.fields.find((f) => f.name === 'text');\n    const tagsField = frame.fields.find((f) => f.name === 'tags');\n\n    const list: AnnotationEvent[] = [];\n    for (let i = 0; i < frame.length; i++) {\n      const timeEnd = timeEndField && timeEndField.values.get(i) ? Math.floor(timeEndField.values.get(i)) : undefined;\n      list.push({\n        annotation: options.annotation,\n        time: Math.floor(timeField.values.get(i)),\n        timeEnd,\n        text: textField && textField.values.get(i) ? textField.values.get(i) : '',\n        tags:\n          tagsField && tagsField.values.get(i)\n            ? tagsField.values\n                .get(i)\n                .trim()\n                .split(/\\s*,\\s*/)\n            : [],\n      });\n    }\n\n    return list;\n  }\n}\n","import { map as _map } from 'lodash';\nimport { of } from 'rxjs';\nimport { catchError, map, mapTo } from 'rxjs/operators';\nimport { BackendDataSourceResponse, DataSourceWithBackend, FetchResponse, getBackendSrv } from '@grafana/runtime';\nimport { AnnotationEvent, DataSourceInstanceSettings, ScopedVars, MetricFindValue } from '@grafana/data';\n\nimport ResponseParser from './response_parser';\nimport { getTemplateSrv, TemplateSrv } from 'app/features/templating/template_srv';\nimport { MssqlQueryForInterpolation, MssqlQuery, MssqlOptions } from './types';\nimport { getTimeSrv, TimeSrv } from 'app/features/dashboard/services/TimeSrv';\nimport { toTestingStatus } from '@grafana/runtime/src/utils/queryResponse';\n\nexport class MssqlDatasource extends DataSourceWithBackend<MssqlQuery, MssqlOptions> {\n  id: any;\n  name: any;\n  responseParser: ResponseParser;\n  interval: string;\n\n  constructor(\n    instanceSettings: DataSourceInstanceSettings<MssqlOptions>,\n    private readonly templateSrv: TemplateSrv = getTemplateSrv(),\n    private readonly timeSrv: TimeSrv = getTimeSrv()\n  ) {\n    super(instanceSettings);\n    this.name = instanceSettings.name;\n    this.id = instanceSettings.id;\n    this.responseParser = new ResponseParser();\n    const settingsData = instanceSettings.jsonData || ({} as MssqlOptions);\n    this.interval = settingsData.timeInterval || '1m';\n  }\n\n  interpolateVariable(value: any, variable: any) {\n    if (typeof value === 'string') {\n      if (variable.multi || variable.includeAll) {\n        return \"'\" + value.replace(/'/g, `''`) + \"'\";\n      } else {\n        return value;\n      }\n    }\n\n    if (typeof value === 'number') {\n      return value;\n    }\n\n    const quotedValues = _map(value, (val) => {\n      if (typeof value === 'number') {\n        return value;\n      }\n\n      return \"'\" + val.replace(/'/g, `''`) + \"'\";\n    });\n    return quotedValues.join(',');\n  }\n\n  interpolateVariablesInQueries(\n    queries: MssqlQueryForInterpolation[],\n    scopedVars: ScopedVars\n  ): MssqlQueryForInterpolation[] {\n    let expandedQueries = queries;\n    if (queries && queries.length > 0) {\n      expandedQueries = queries.map((query) => {\n        const expandedQuery = {\n          ...query,\n          datasource: this.name,\n          rawSql: this.templateSrv.replace(query.rawSql, scopedVars, this.interpolateVariable),\n          rawQuery: true,\n        };\n        return expandedQuery;\n      });\n    }\n    return expandedQueries;\n  }\n\n  applyTemplateVariables(target: MssqlQuery, scopedVars: ScopedVars): Record<string, any> {\n    return {\n      refId: target.refId,\n      datasourceId: this.id,\n      rawSql: this.templateSrv.replace(target.rawSql, scopedVars, this.interpolateVariable),\n      format: target.format,\n    };\n  }\n\n  async annotationQuery(options: any): Promise<AnnotationEvent[]> {\n    if (!options.annotation.rawQuery) {\n      return Promise.reject({ message: 'Query missing in annotation definition' });\n    }\n\n    const query = {\n      refId: options.annotation.name,\n      datasourceId: this.id,\n      rawSql: this.templateSrv.replace(options.annotation.rawQuery, options.scopedVars, this.interpolateVariable),\n      format: 'table',\n    };\n\n    return getBackendSrv()\n      .fetch<BackendDataSourceResponse>({\n        url: '/api/ds/query',\n        method: 'POST',\n        data: {\n          from: options.range.from.valueOf().toString(),\n          to: options.range.to.valueOf().toString(),\n          queries: [query],\n        },\n        requestId: options.annotation.name,\n      })\n      .pipe(\n        map(\n          async (res: FetchResponse<BackendDataSourceResponse>) =>\n            await this.responseParser.transformAnnotationResponse(options, res.data)\n        )\n      )\n      .toPromise();\n  }\n\n  filterQuery(query: MssqlQuery): boolean {\n    return !query.hide;\n  }\n\n  metricFindQuery(query: string, optionalOptions: any): Promise<MetricFindValue[]> {\n    let refId = 'tempvar';\n    if (optionalOptions && optionalOptions.variable && optionalOptions.variable.name) {\n      refId = optionalOptions.variable.name;\n    }\n\n    const range = this.timeSrv.timeRange();\n\n    const interpolatedQuery = {\n      refId: refId,\n      datasourceId: this.id,\n      rawSql: this.templateSrv.replace(query, {}, this.interpolateVariable),\n      format: 'table',\n    };\n\n    return getBackendSrv()\n      .fetch<BackendDataSourceResponse>({\n        url: '/api/ds/query',\n        method: 'POST',\n        data: {\n          from: range.from.valueOf().toString(),\n          to: range.to.valueOf().toString(),\n          queries: [interpolatedQuery],\n        },\n        requestId: refId,\n      })\n      .pipe(\n        map((rsp) => {\n          return this.responseParser.transformMetricFindResponse(rsp);\n        })\n      )\n      .toPromise();\n  }\n\n  testDatasource(): Promise<any> {\n    return getBackendSrv()\n      .fetch({\n        url: '/api/ds/query',\n        method: 'POST',\n        data: {\n          from: '5m',\n          to: 'now',\n          queries: [\n            {\n              refId: 'A',\n              intervalMs: 1,\n              maxDataPoints: 1,\n              datasourceId: this.id,\n              rawSql: 'SELECT 1',\n              format: 'table',\n            },\n          ],\n        },\n      })\n      .pipe(\n        mapTo({ status: 'success', message: 'Database Connection OK' }),\n        catchError((err) => {\n          return of(toTestingStatus(err));\n        })\n      )\n      .toPromise();\n  }\n\n  targetContainsTemplate(query: MssqlQuery): boolean {\n    const rawSql = query.rawSql.replace('$__', '');\n    return this.templateSrv.variableExists(rawSql);\n  }\n}\n","import { QueryCtrl } from 'app/plugins/sdk';\nimport { auto } from 'angular';\nimport { PanelEvents, QueryResultMeta } from '@grafana/data';\nimport { MssqlQuery } from './types';\n\nconst defaultQuery = `SELECT\n  $__timeEpoch(<time_column>),\n  <value column> as value,\n  <series name column> as metric\nFROM\n  <table name>\nWHERE\n  $__timeFilter(time_column)\nORDER BY\n  <time_column> ASC`;\n\nexport class MssqlQueryCtrl extends QueryCtrl<MssqlQuery> {\n  static templateUrl = 'partials/query.editor.html';\n\n  formats: any[];\n  lastQueryMeta?: QueryResultMeta;\n  lastQueryError?: string;\n  showHelp = false;\n\n  /** @ngInject */\n  constructor($scope: any, $injector: auto.IInjectorService) {\n    super($scope, $injector);\n\n    this.target.format = this.target.format || 'time_series';\n    this.target.alias = '';\n    this.formats = [\n      { text: 'Time series', value: 'time_series' },\n      { text: 'Table', value: 'table' },\n    ];\n\n    if (!this.target.rawSql) {\n      // special handling when in table panel\n      if (this.panelCtrl.panel.type === 'table') {\n        this.target.format = 'table';\n        this.target.rawSql = 'SELECT 1';\n      } else {\n        this.target.rawSql = defaultQuery;\n      }\n    }\n\n    this.panelCtrl.events.on(PanelEvents.dataReceived, this.onDataReceived.bind(this), $scope);\n    this.panelCtrl.events.on(PanelEvents.dataError, this.onDataError.bind(this), $scope);\n  }\n\n  onDataReceived(dataList: any) {\n    this.lastQueryError = undefined;\n    this.lastQueryMeta = dataList[0]?.meta;\n  }\n\n  onDataError(err: any) {\n    if (err.data && err.data.results) {\n      const queryRes = err.data.results[this.target.refId];\n      if (queryRes) {\n        this.lastQueryError = queryRes.error;\n      }\n    }\n  }\n}\n","import {\n  createChangeHandler,\n  createResetHandler,\n  PasswordFieldEnum,\n} from '../../../features/datasources/utils/passwordHandlers';\n\nexport class MssqlConfigCtrl {\n  static templateUrl = 'partials/config.html';\n\n  // Set through angular bindings\n  declare current: any;\n\n  onPasswordReset: ReturnType<typeof createResetHandler>;\n  onPasswordChange: ReturnType<typeof createChangeHandler>;\n  showUserCredentials: boolean;\n\n  /** @ngInject */\n  constructor($scope: any) {\n    this.current = $scope.ctrl.current;\n    this.current.jsonData.encrypt = this.current.jsonData.encrypt || 'false';\n    this.current.jsonData.authenticationType = this.current.jsonData.authenticationType || 'SQL Server Authentication';\n    this.onPasswordReset = createResetHandler(this, PasswordFieldEnum.Password);\n    this.onPasswordChange = createChangeHandler(this, PasswordFieldEnum.Password);\n    this.showUserCredentials = this.current.jsonData.authenticationType !== 'Windows Authentication';\n  }\n\n  onAuthenticationTypeChange() {\n    // This is using the fallback in https://github.com/denisenkom/go-mssqldb to use Windows Auth if login/user id is empty.\n    if (this.current.jsonData.authenticationType === 'Windows Authentication') {\n      this.current.user = '';\n      this.current.password = '';\n    }\n\n    this.showUserCredentials = this.current.jsonData.authenticationType !== 'Windows Authentication';\n  }\n}\n","import { MssqlDatasource } from './datasource';\nimport { MssqlQueryCtrl } from './query_ctrl';\nimport { MssqlConfigCtrl } from './config_ctrl';\nimport { MssqlQuery } from './types';\nimport { DataSourcePlugin } from '@grafana/data';\n\nconst defaultQuery = `SELECT\n    <time_column> as time,\n    <text_column> as text,\n    <tags_column> as tags\n  FROM\n    <table name>\n  WHERE\n    $__timeFilter(time_column)\n  ORDER BY\n    <time_column> ASC`;\n\nclass MssqlAnnotationsQueryCtrl {\n  static templateUrl = 'partials/annotations.editor.html';\n\n  declare annotation: any;\n\n  /** @ngInject */\n  constructor($scope: any) {\n    this.annotation = $scope.ctrl.annotation;\n    this.annotation.rawQuery = this.annotation.rawQuery || defaultQuery;\n  }\n}\n\nexport const plugin = new DataSourcePlugin<MssqlDatasource, MssqlQuery>(MssqlDatasource)\n  .setQueryCtrl(MssqlQueryCtrl)\n  .setConfigCtrl(MssqlConfigCtrl)\n  .setAnnotationQueryCtrl(MssqlAnnotationsQueryCtrl);\n"],"sourceRoot":""}