{"version":3,"sources":["webpack:///./public/app/core/components/TraceToLogsSettings.tsx","webpack:///./public/app/plugins/datasource/tempo/graphTransform.ts","webpack:///./public/app/plugins/datasource/tempo/resultTransformer.ts","webpack:///./public/app/plugins/datasource/tempo/datasource.ts","webpack:///./public/app/plugins/datasource/tempo/QueryField.tsx","webpack:///./public/app/plugins/datasource/tempo/module.ts","webpack:///./public/app/plugins/datasource/tempo/ConfigEditor.tsx","webpack:///./public/app/plugins/datasource/tempo/CheatSheet.tsx","webpack:///./public/app/core/utils/tracing.ts"],"names":["TraceToLogsSettings","options","onOptionsChange","styles","useStyles","getStyles","className","css","width","infoText","tooltip","label","labelWidth","pluginId","current","jsonData","tracesToLogs","datasourceUid","noDefault","onChange","ds","updateDatasourcePluginJsonDataOption","uid","tags","grow","type","placeholder","v","spanStartTimeShift","currentTarget","value","spanEndTimeShift","theme","spacing","md","colors","textSemiWeak","createGraphFrames","data","nodes","edges","view","DataFrameView","traceDuration","traceEndTime","traceStartTime","Infinity","i","length","row","get","startTime","duration","findTraceDuration","spanMap","makeSpanMap","index","span","id","spanID","parentIds","parentSpanID","ranges","children","map","c","childrenDuration","getNonOverlappingDuration","selfDuration","stats","getStats","push","Fields","title","serviceName","subTitle","operationName","mainStat","main","secondaryStat","secondary","color","target","source","convertTraceToGraph","nodesFrame","edgesFrame","makeFrames","node","add","edge","transformTraceList","response","datasourceId","datasourceName","traceRegexs","forEach","frame","logsFrame","tableFrame","MutableDataFrame","fields","name","FieldType","time","config","custom","string","displayNameFromDS","links","url","internal","query","meta","preferredVisualisationType","timeField","find","f","field","hasMatch","values","toArray","line","traceRegex","match","traceId","createTableFrame","transformTrace","fieldName","fieldIndex","indexOf","ArrayVector","newField","other","set","undefined","JSON","parse","parseJsonFields","emptyDataQueryResponse","trace","TempoDatasource","DataSourceWithBackend","constructor","instanceSettings","super","this","subQueries","filteredTargets","targets","filter","hide","searchTargets","queryType","traceTargets","dsSrv","getDatasourceSrv","from","pipe","mergeMap","linkedDatasource","linkedRequest","t","linkedQuery","traceLinkMatcher","derivedFields","matcherRegex","error","throwError","traceRequest","merge","errorMessage","toPromise","message","startsWith","endsWith","status","getQueryDisplayText","TempoQueryField","React","PureComponent","props","refId","onRunQuery","datasource","linkedDatasourceUid","getDataSourceSrv","setState","render","state","size","LokiQueryField","onChangeLinkedQuery","onRunLinkedQuery","history","FormField","inputEl","aria-label","selectors","components","QueryField","container","style","e","plugin","DataSourcePlugin","setConfigEditor","defaultUrl","dataSourceConfig","showAccessOptions","setQueryEditorHelp","href","setExploreQueryField","sort","a","b","reduce","acc","range","tail","slice","prevStart","prevEnd","start","end","getSpan","parentId","toFixedNoTrailingZeros","n","parseFloat","toFixed","displayName","number","mode"],"mappings":"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","file":"tempoPlugin.62c612232a976d8836f5.js","sourcesContent":["import { css } from '@emotion/css';\nimport {\n  DataSourceJsonData,\n  DataSourcePluginOptionsEditorProps,\n  GrafanaTheme,\n  updateDatasourcePluginJsonDataOption,\n} from '@grafana/data';\nimport { DataSourcePicker } from '@grafana/runtime';\nimport { InlineField, InlineFieldRow, Input, TagsInput, useStyles } from '@grafana/ui';\nimport React from 'react';\n\nexport interface TraceToLogsOptions {\n  datasourceUid?: string;\n  tags?: string[];\n  spanStartTimeShift?: string;\n  spanEndTimeShift?: string;\n}\n\nexport interface TraceToLogsData extends DataSourceJsonData {\n  tracesToLogs?: TraceToLogsOptions;\n}\n\ninterface Props extends DataSourcePluginOptionsEditorProps<TraceToLogsData> {}\n\nexport function TraceToLogsSettings({ options, onOptionsChange }: Props) {\n  const styles = useStyles(getStyles);\n\n  return (\n    <div className={css({ width: '100%' })}>\n      <h3 className=\"page-heading\">Trace to logs</h3>\n\n      <div className={styles.infoText}>\n        Trace to logs let&apos;s you navigate from a trace span to the selected data source&apos;s log.\n      </div>\n\n      <InlineFieldRow>\n        <InlineField tooltip=\"The data source the trace is going to navigate to\" label=\"Data source\" labelWidth={26}>\n          <DataSourcePicker\n            pluginId=\"loki\"\n            current={options.jsonData.tracesToLogs?.datasourceUid}\n            noDefault={true}\n            width={40}\n            onChange={(ds) =>\n              updateDatasourcePluginJsonDataOption({ onOptionsChange, options }, 'tracesToLogs', {\n                datasourceUid: ds.uid,\n                tags: options.jsonData.tracesToLogs?.tags,\n              })\n            }\n          />\n        </InlineField>\n      </InlineFieldRow>\n\n      <InlineFieldRow>\n        <InlineField\n          tooltip=\"Tags that will be used in the Loki query. Default tags: 'cluster', 'hostname', 'namespace', 'pod'\"\n          label=\"Tags\"\n          labelWidth={26}\n        >\n          <TagsInput\n            tags={options.jsonData.tracesToLogs?.tags}\n            width={40}\n            onChange={(tags) =>\n              updateDatasourcePluginJsonDataOption({ onOptionsChange, options }, 'tracesToLogs', {\n                datasourceUid: options.jsonData.tracesToLogs?.datasourceUid,\n                tags: tags,\n              })\n            }\n          />\n        </InlineField>\n      </InlineFieldRow>\n\n      <InlineFieldRow>\n        <InlineField\n          label=\"Span start time shift\"\n          labelWidth={26}\n          grow\n          tooltip=\"Shifts the start time of the span. Default 0 (Time units can be used here, for example: 5s, 1m, 3h)\"\n        >\n          <Input\n            type=\"text\"\n            placeholder=\"1h\"\n            width={40}\n            onChange={(v) =>\n              updateDatasourcePluginJsonDataOption({ onOptionsChange, options }, 'tracesToLogs', {\n                ...options.jsonData.tracesToLogs,\n                spanStartTimeShift: v.currentTarget.value,\n              })\n            }\n            value={options.jsonData.tracesToLogs?.spanStartTimeShift || ''}\n          />\n        </InlineField>\n      </InlineFieldRow>\n\n      <InlineFieldRow>\n        <InlineField\n          label=\"Span end time shift\"\n          labelWidth={26}\n          grow\n          tooltip=\"Shifts the end time of the span. Default 0 Time units can be used here, for example: 5s, 1m, 3h\"\n        >\n          <Input\n            type=\"text\"\n            placeholder=\"1h\"\n            width={40}\n            onChange={(v) =>\n              updateDatasourcePluginJsonDataOption({ onOptionsChange, options }, 'tracesToLogs', {\n                ...options.jsonData.tracesToLogs,\n                spanEndTimeShift: v.currentTarget.value,\n              })\n            }\n            value={options.jsonData.tracesToLogs?.spanEndTimeShift || ''}\n          />\n        </InlineField>\n      </InlineFieldRow>\n    </div>\n  );\n}\n\nconst getStyles = (theme: GrafanaTheme) => ({\n  infoText: css`\n    padding-bottom: ${theme.spacing.md};\n    color: ${theme.colors.textSemiWeak};\n  `,\n});\n","import { DataFrame, DataFrameView, NodeGraphDataFrameFieldNames as Fields } from '@grafana/data';\nimport { getNonOverlappingDuration, getStats, makeFrames, makeSpanMap } from '../../../core/utils/tracing';\n\ninterface Row {\n  traceID: string;\n  spanID: string;\n  parentSpanID: string;\n  operationName: string;\n  serviceName: string;\n  serviceTags: string;\n  startTime: number;\n  duration: number;\n  logs: string;\n  tags: string;\n}\n\ninterface Node {\n  [Fields.id]: string;\n  [Fields.title]: string;\n  [Fields.subTitle]: string;\n  [Fields.mainStat]: string;\n  [Fields.secondaryStat]: string;\n  [Fields.color]: number;\n}\n\ninterface Edge {\n  [Fields.id]: string;\n  [Fields.target]: string;\n  [Fields.source]: string;\n}\n\nexport function createGraphFrames(data: DataFrame): DataFrame[] {\n  const { nodes, edges } = convertTraceToGraph(data);\n  const [nodesFrame, edgesFrame] = makeFrames();\n\n  for (const node of nodes) {\n    nodesFrame.add(node);\n  }\n  for (const edge of edges) {\n    edgesFrame.add(edge);\n  }\n\n  return [nodesFrame, edgesFrame];\n}\n\nfunction convertTraceToGraph(data: DataFrame): { nodes: Node[]; edges: Edge[] } {\n  const nodes: Node[] = [];\n  const edges: Edge[] = [];\n\n  const view = new DataFrameView<Row>(data);\n\n  const traceDuration = findTraceDuration(view);\n  const spanMap = makeSpanMap((index) => {\n    if (index >= data.length) {\n      return undefined;\n    }\n    const span = view.get(index);\n    return {\n      span: { ...span },\n      id: span.spanID,\n      parentIds: span.parentSpanID ? [span.parentSpanID] : [],\n    };\n  });\n\n  for (let i = 0; i < view.length; i++) {\n    const row = view.get(i);\n\n    const ranges: Array<[number, number]> = spanMap[row.spanID].children.map((c) => {\n      const span = spanMap[c].span;\n      return [span.startTime, span.startTime + span.duration];\n    });\n    const childrenDuration = getNonOverlappingDuration(ranges);\n    const selfDuration = row.duration - childrenDuration;\n    const stats = getStats(row.duration, traceDuration, selfDuration);\n\n    nodes.push({\n      [Fields.id]: row.spanID,\n      [Fields.title]: row.serviceName ?? '',\n      [Fields.subTitle]: row.operationName,\n      [Fields.mainStat]: stats.main,\n      [Fields.secondaryStat]: stats.secondary,\n      [Fields.color]: selfDuration / traceDuration,\n    });\n\n    // Sometimes some span can be missing. Don't add edges for those.\n    if (row.parentSpanID && spanMap[row.parentSpanID].span) {\n      edges.push({\n        [Fields.id]: row.parentSpanID + '--' + row.spanID,\n        [Fields.target]: row.spanID,\n        [Fields.source]: row.parentSpanID,\n      });\n    }\n  }\n\n  return { nodes, edges };\n}\n\n/**\n * Get the duration of the whole trace as it isn't a part of the response data.\n * Note: Seems like this should be the same as just longest span, but this is probably safer.\n */\nfunction findTraceDuration(view: DataFrameView<Row>): number {\n  let traceEndTime = 0;\n  let traceStartTime = Infinity;\n\n  for (let i = 0; i < view.length; i++) {\n    const row = view.get(i);\n\n    if (row.startTime < traceStartTime) {\n      traceStartTime = row.startTime;\n    }\n\n    if (row.startTime + row.duration > traceEndTime) {\n      traceEndTime = row.startTime + row.duration;\n    }\n  }\n\n  return traceEndTime - traceStartTime;\n}\n","import { DataQueryResponse, ArrayVector, DataFrame, Field, FieldType, MutableDataFrame } from '@grafana/data';\nimport { createGraphFrames } from './graphTransform';\n\nexport function createTableFrame(\n  logsFrame: DataFrame,\n  datasourceUid: string,\n  datasourceName: string,\n  traceRegexs: string[]\n): DataFrame {\n  const tableFrame = new MutableDataFrame({\n    fields: [\n      {\n        name: 'Time',\n        type: FieldType.time,\n        config: {\n          custom: {\n            width: 150,\n          },\n        },\n      },\n      {\n        name: 'traceID',\n        type: FieldType.string,\n        config: {\n          displayNameFromDS: 'Trace ID',\n          custom: { width: 300 },\n          links: [\n            {\n              title: 'Click to open trace ${__value.raw}',\n              url: '',\n              internal: {\n                datasourceUid,\n                datasourceName,\n                query: {\n                  query: '${__value.raw}',\n                },\n              },\n            },\n          ],\n        },\n      },\n      {\n        name: 'Message',\n        type: FieldType.string,\n      },\n    ],\n    meta: {\n      preferredVisualisationType: 'table',\n    },\n  });\n\n  if (!logsFrame || traceRegexs.length === 0) {\n    return tableFrame;\n  }\n\n  const timeField = logsFrame.fields.find((f) => f.type === FieldType.time);\n\n  // Going through all string fields to look for trace IDs\n  for (let field of logsFrame.fields) {\n    let hasMatch = false;\n    if (field.type === FieldType.string) {\n      const values = field.values.toArray();\n      for (let i = 0; i < values.length; i++) {\n        const line = values[i];\n        if (line) {\n          for (let traceRegex of traceRegexs) {\n            const match = (line as string).match(traceRegex);\n            if (match) {\n              const traceId = match[1];\n              const time = timeField ? timeField.values.get(i) : null;\n              tableFrame.fields[0].values.add(time);\n              tableFrame.fields[1].values.add(traceId);\n              tableFrame.fields[2].values.add(line);\n              hasMatch = true;\n            }\n          }\n        }\n      }\n    }\n    if (hasMatch) {\n      break;\n    }\n  }\n\n  return tableFrame;\n}\n\nexport function transformTraceList(\n  response: DataQueryResponse,\n  datasourceId: string,\n  datasourceName: string,\n  traceRegexs: string[]\n): DataQueryResponse {\n  response.data.forEach((data, index) => {\n    const frame = createTableFrame(data, datasourceId, datasourceName, traceRegexs);\n    response.data[index] = frame;\n  });\n  return response;\n}\n\nexport function transformTrace(response: DataQueryResponse): DataQueryResponse {\n  // We need to parse some of the fields which contain stringified json.\n  // Seems like we can't just map the values as the frame we got from backend has some default processing\n  // and will stringify the json back when we try to set it. So we create a new field and swap it instead.\n  const frame: DataFrame = response.data[0];\n\n  if (!frame) {\n    return emptyDataQueryResponse;\n  }\n\n  parseJsonFields(frame);\n\n  return {\n    ...response,\n    data: [...response.data, ...createGraphFrames(frame)],\n  };\n}\n\n/**\n * Change fields which are json string into JS objects. Modifies the frame in place.\n */\nfunction parseJsonFields(frame: DataFrame) {\n  for (const fieldName of ['serviceTags', 'logs', 'tags']) {\n    const field = frame.fields.find((f) => f.name === fieldName);\n    if (field) {\n      const fieldIndex = frame.fields.indexOf(field);\n      const values = new ArrayVector();\n      const newField: Field = {\n        ...field,\n        values,\n        type: FieldType.other,\n      };\n\n      for (let i = 0; i < field.values.length; i++) {\n        const value = field.values.get(i);\n        values.set(i, value === '' ? undefined : JSON.parse(value));\n      }\n      frame.fields[fieldIndex] = newField;\n    }\n  }\n}\n\nconst emptyDataQueryResponse = {\n  data: [\n    new MutableDataFrame({\n      fields: [\n        {\n          name: 'trace',\n          type: FieldType.trace,\n          values: [],\n        },\n      ],\n      meta: {\n        preferredVisualisationType: 'trace',\n      },\n    }),\n  ],\n};\n","import {\n  DataQuery,\n  DataQueryRequest,\n  DataQueryResponse,\n  DataSourceApi,\n  DataSourceInstanceSettings,\n} from '@grafana/data';\nimport { DataSourceWithBackend } from '@grafana/runtime';\nimport { TraceToLogsData, TraceToLogsOptions } from 'app/core/components/TraceToLogsSettings';\nimport { getDatasourceSrv } from 'app/features/plugins/datasource_srv';\nimport { from, merge, Observable, throwError } from 'rxjs';\nimport { map, mergeMap } from 'rxjs/operators';\nimport { LokiOptions } from '../loki/types';\nimport { transformTrace, transformTraceList } from './resultTransformer';\n\nexport type TempoQueryType = 'search' | 'traceId';\n\nexport type TempoQuery = {\n  query: string;\n  // Query to find list of traces, e.g., via Loki\n  linkedQuery?: DataQuery;\n  queryType: TempoQueryType;\n} & DataQuery;\n\nexport class TempoDatasource extends DataSourceWithBackend<TempoQuery, TraceToLogsData> {\n  tracesToLogs?: TraceToLogsOptions;\n\n  constructor(instanceSettings: DataSourceInstanceSettings<TraceToLogsData>) {\n    super(instanceSettings);\n    this.tracesToLogs = instanceSettings.jsonData.tracesToLogs;\n  }\n\n  query(options: DataQueryRequest<TempoQuery>): Observable<DataQueryResponse> {\n    const subQueries: Array<Observable<DataQueryResponse>> = [];\n    const filteredTargets = options.targets.filter((target) => !target.hide);\n    const searchTargets = filteredTargets.filter((target) => target.queryType === 'search');\n    const traceTargets = filteredTargets.filter(\n      (target) => target.queryType === 'traceId' || target.queryType === undefined\n    );\n\n    // Run search queries on linked datasource\n    if (this.tracesToLogs?.datasourceUid && searchTargets.length > 0) {\n      const dsSrv = getDatasourceSrv();\n      subQueries.push(\n        from(dsSrv.get(this.tracesToLogs.datasourceUid)).pipe(\n          mergeMap((linkedDatasource: DataSourceApi) => {\n            // Wrap linked query into a data request based on original request\n            const linkedRequest: DataQueryRequest = { ...options, targets: searchTargets.map((t) => t.linkedQuery!) };\n            // Find trace matchers in derived fields of the linked datasource that's identical to this datasource\n            const settings: DataSourceInstanceSettings<LokiOptions> = (linkedDatasource as any).instanceSettings;\n            const traceLinkMatcher: string[] =\n              settings.jsonData.derivedFields\n                ?.filter((field) => field.datasourceUid === this.uid && field.matcherRegex)\n                .map((field) => field.matcherRegex) || [];\n            if (!traceLinkMatcher || traceLinkMatcher.length === 0) {\n              return throwError(\n                'No Loki datasource configured for search. Set up Derived Fields for traces in a Loki datasource settings and link it to this Tempo datasource.'\n              );\n            } else {\n              return (linkedDatasource.query(linkedRequest) as Observable<DataQueryResponse>).pipe(\n                map((response) =>\n                  response.error ? response : transformTraceList(response, this.uid, this.name, traceLinkMatcher)\n                )\n              );\n            }\n          })\n        )\n      );\n    }\n\n    if (traceTargets.length > 0) {\n      const traceRequest: DataQueryRequest<TempoQuery> = { ...options, targets: traceTargets };\n      subQueries.push(\n        super.query(traceRequest).pipe(\n          map((response) => {\n            if (response.error) {\n              return response;\n            }\n            return transformTrace(response);\n          })\n        )\n      );\n    }\n\n    return merge(...subQueries);\n  }\n\n  async testDatasource(): Promise<any> {\n    // to test Tempo we send a dummy traceID and verify Tempo answers with 'trace not found'\n    const response = await super.query({ targets: [{ query: '0' }] } as any).toPromise();\n\n    const errorMessage = response.error?.message;\n    if (\n      errorMessage &&\n      errorMessage.startsWith('failed to get trace') &&\n      errorMessage.endsWith('trace not found in Tempo')\n    ) {\n      return { status: 'success', message: 'Data source is working' };\n    }\n\n    return { status: 'error', message: 'Data source is not working' + (errorMessage ? `: ${errorMessage}` : '') };\n  }\n\n  getQueryDisplayText(query: TempoQuery) {\n    return query.query;\n  }\n}\n","import { DataQuery, DataSourceApi, ExploreQueryFieldProps } from '@grafana/data';\nimport { selectors } from '@grafana/e2e-selectors';\nimport { getDataSourceSrv } from '@grafana/runtime';\nimport { InlineField, InlineFieldRow, InlineLabel, LegacyForms, RadioButtonGroup } from '@grafana/ui';\nimport { TraceToLogsOptions } from 'app/core/components/TraceToLogsSettings';\nimport React from 'react';\nimport { LokiQueryField } from '../loki/components/LokiQueryField';\nimport { TempoDatasource, TempoQuery, TempoQueryType } from './datasource';\n\ntype Props = ExploreQueryFieldProps<TempoDatasource, TempoQuery>;\nconst DEFAULT_QUERY_TYPE: TempoQueryType = 'traceId';\ninterface State {\n  linkedDatasource?: DataSourceApi;\n}\nexport class TempoQueryField extends React.PureComponent<Props, State> {\n  state = {\n    linkedDatasource: undefined,\n  };\n\n  constructor(props: Props) {\n    super(props);\n  }\n\n  async componentDidMount() {\n    const { datasource } = this.props;\n    // Find query field from linked datasource\n    const tracesToLogsOptions: TraceToLogsOptions = datasource.tracesToLogs || {};\n    const linkedDatasourceUid = tracesToLogsOptions.datasourceUid;\n    if (linkedDatasourceUid) {\n      const dsSrv = getDataSourceSrv();\n      const linkedDatasource = await dsSrv.get(linkedDatasourceUid);\n      this.setState({\n        linkedDatasource,\n      });\n    }\n\n    // Set initial query type to ensure traceID field appears\n    if (!this.props.query.queryType) {\n      this.props.onChange({\n        ...this.props.query,\n        queryType: DEFAULT_QUERY_TYPE,\n      });\n    }\n  }\n\n  onChangeLinkedQuery = (value: DataQuery) => {\n    const { query, onChange } = this.props;\n    onChange({\n      ...query,\n      linkedQuery: { ...value, refId: 'linked' },\n    });\n  };\n\n  onRunLinkedQuery = () => {\n    this.props.onRunQuery();\n  };\n\n  render() {\n    const { query, onChange } = this.props;\n    const { linkedDatasource } = this.state;\n\n    return (\n      <>\n        <InlineFieldRow>\n          <InlineField label=\"Query type\">\n            <RadioButtonGroup<TempoQueryType>\n              options={[\n                { value: 'search', label: 'Search' },\n                { value: 'traceId', label: 'TraceID' },\n              ]}\n              value={query.queryType}\n              onChange={(v) =>\n                onChange({\n                  ...query,\n                  queryType: v,\n                })\n              }\n              size=\"md\"\n            />\n          </InlineField>\n        </InlineFieldRow>\n        {query.queryType === 'search' && linkedDatasource && (\n          <>\n            <InlineLabel>\n              Tempo uses {((linkedDatasource as unknown) as DataSourceApi).name} to find traces.\n            </InlineLabel>\n\n            <LokiQueryField\n              datasource={linkedDatasource!}\n              onChange={this.onChangeLinkedQuery}\n              onRunQuery={this.onRunLinkedQuery}\n              query={this.props.query.linkedQuery ?? ({ refId: 'linked' } as any)}\n              history={[]}\n            />\n          </>\n        )}\n        {query.queryType === 'search' && !linkedDatasource && (\n          <div className=\"text-warning\">Please set up a Traces-to-logs datasource in the datasource settings.</div>\n        )}\n        {query.queryType !== 'search' && (\n          <LegacyForms.FormField\n            label=\"Trace ID\"\n            labelWidth={4}\n            inputEl={\n              <div className=\"slate-query-field__wrapper\">\n                <div className=\"slate-query-field\" aria-label={selectors.components.QueryField.container}>\n                  <input\n                    style={{ width: '100%' }}\n                    value={query.query || ''}\n                    onChange={(e) =>\n                      onChange({\n                        ...query,\n                        query: e.currentTarget.value,\n                        queryType: 'traceId',\n                        linkedQuery: undefined,\n                      })\n                    }\n                  />\n                </div>\n              </div>\n            }\n          />\n        )}\n      </>\n    );\n  }\n}\n","import { DataSourcePlugin } from '@grafana/data';\nimport CheatSheet from './CheatSheet';\nimport { ConfigEditor } from './ConfigEditor';\nimport { TempoDatasource } from './datasource';\nimport { TempoQueryField } from './QueryField';\n\nexport const plugin = new DataSourcePlugin(TempoDatasource)\n  .setConfigEditor(ConfigEditor)\n  .setQueryEditorHelp(CheatSheet)\n  .setExploreQueryField(TempoQueryField);\n","import { DataSourcePluginOptionsEditorProps } from '@grafana/data';\nimport { DataSourceHttpSettings } from '@grafana/ui';\nimport { TraceToLogsSettings } from 'app/core/components/TraceToLogsSettings';\nimport React from 'react';\n\nexport type Props = DataSourcePluginOptionsEditorProps;\n\nexport const ConfigEditor: React.FC<Props> = ({ options, onOptionsChange }) => {\n  return (\n    <>\n      <DataSourceHttpSettings\n        defaultUrl=\"http://tempo\"\n        dataSourceConfig={options}\n        showAccessOptions={false}\n        onChange={onOptionsChange}\n      />\n\n      <TraceToLogsSettings options={options} onOptionsChange={onOptionsChange} />\n    </>\n  );\n};\n","import React from 'react';\n\nexport default function CheatSheet() {\n  return (\n    <div>\n      <h2 id=\"tempo-cheat-sheet\">Tempo Cheat Sheet</h2>\n      <p>\n        Tempo is a trace id lookup store. Enter a trace id in the above field and hit “Run Query” to retrieve your\n        trace. Tempo is generally paired with other datasources such as Loki or Prometheus to find traces.\n      </p>\n      <p>\n        Here are some{' '}\n        <a href=\"https://grafana.com/docs/tempo/latest/guides/instrumentation/\" target=\"blank\">\n          instrumentation examples\n        </a>{' '}\n        to get you started with trace discovery through logs and metrics (exemplars).\n      </p>\n    </div>\n  );\n}\n","/**\n * Get non overlapping duration of the ranges as they can overlap or have gaps.\n */\nimport { FieldType, MutableDataFrame, NodeGraphDataFrameFieldNames as Fields } from '@grafana/data';\n\nexport function getNonOverlappingDuration(ranges: Array<[number, number]>): number {\n  ranges.sort((a, b) => a[0] - b[0]);\n  const mergedRanges = ranges.reduce((acc, range) => {\n    if (!acc.length) {\n      return [range];\n    }\n    const tail = acc.slice(-1)[0];\n    const [prevStart, prevEnd] = tail;\n    const [start, end] = range;\n    if (end < prevEnd) {\n      // In this case the range is completely inside the prev range so we can just ignore it.\n      return acc;\n    }\n\n    if (start > prevEnd) {\n      // There is no overlap so we can just add it to stack\n      return [...acc, range];\n    }\n\n    // We know there is overlap and current range ends later than previous so we can just extend the range\n    return [...acc.slice(0, -1), [prevStart, end]] as Array<[number, number]>;\n  }, [] as Array<[number, number]>);\n\n  return mergedRanges.reduce((acc, range) => {\n    return acc + (range[1] - range[0]);\n  }, 0);\n}\n\n/**\n * Returns a map of the spans with children array for easier processing. It will also contain empty spans in case\n * span is missing but other spans are it's children. This is more generic because it needs to allow iterating over\n * both arrays and dataframe views.\n */\nexport function makeSpanMap<T>(\n  getSpan: (index: number) => { span: T; id: string; parentIds: string[] } | undefined\n): { [id: string]: { span: T; children: string[] } } {\n  const spanMap: { [id: string]: { span?: T; children: string[] } } = {};\n\n  let span;\n  for (let index = 0; (span = getSpan(index)), !!span; index++) {\n    if (!spanMap[span.id]) {\n      spanMap[span.id] = {\n        span: span.span,\n        children: [],\n      };\n    } else {\n      spanMap[span.id].span = span.span;\n    }\n\n    for (const parentId of span.parentIds) {\n      if (parentId) {\n        if (!spanMap[parentId]) {\n          spanMap[parentId] = {\n            span: undefined,\n            children: [span.id],\n          };\n        } else {\n          spanMap[parentId].children.push(span.id);\n        }\n      }\n    }\n  }\n  return spanMap as { [id: string]: { span: T; children: string[] } };\n}\n\nexport function getStats(duration: number, traceDuration: number, selfDuration: number) {\n  return {\n    main: `${toFixedNoTrailingZeros(duration)}ms (${toFixedNoTrailingZeros((duration / traceDuration) * 100)}%)`,\n    secondary: `${toFixedNoTrailingZeros(selfDuration)}ms (${toFixedNoTrailingZeros(\n      (selfDuration / duration) * 100\n    )}%)`,\n  };\n}\n\nfunction toFixedNoTrailingZeros(n: number) {\n  return parseFloat(n.toFixed(2));\n}\n\n/**\n * Create default frames used when returning data for node graph.\n */\nexport function makeFrames() {\n  const nodesFrame = new MutableDataFrame({\n    fields: [\n      { name: Fields.id, type: FieldType.string },\n      { name: Fields.title, type: FieldType.string },\n      { name: Fields.subTitle, type: FieldType.string },\n      { name: Fields.mainStat, type: FieldType.string, config: { displayName: 'Total time (% of trace)' } },\n      { name: Fields.secondaryStat, type: FieldType.string, config: { displayName: 'Self time (% of total)' } },\n      {\n        name: Fields.color,\n        type: FieldType.number,\n        config: { color: { mode: 'continuous-GrYlRd' }, displayName: 'Self time / Trace duration' },\n      },\n    ],\n    meta: {\n      preferredVisualisationType: 'nodeGraph',\n    },\n  });\n\n  const edgesFrame = new MutableDataFrame({\n    fields: [\n      { name: Fields.id, type: FieldType.string },\n      { name: Fields.target, type: FieldType.string },\n      { name: Fields.source, type: FieldType.string },\n    ],\n    meta: {\n      preferredVisualisationType: 'nodeGraph',\n    },\n  });\n\n  return [nodesFrame, edgesFrame];\n}\n"],"sourceRoot":""}