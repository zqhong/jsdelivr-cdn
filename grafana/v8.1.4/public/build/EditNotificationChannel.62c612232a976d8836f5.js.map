{"version":3,"sources":["webpack:///./public/app/features/alerting/components/NotificationSettings.tsx","webpack:///./public/app/features/alerting/components/OptionElement.tsx","webpack:///./public/app/features/alerting/components/NotificationChannelOptions.tsx","webpack:///./public/app/features/alerting/components/BasicSettings.tsx","webpack:///./public/app/features/alerting/components/ChannelSettings.tsx","webpack:///./public/app/features/alerting/components/NotificationChannelForm.tsx","webpack:///./public/app/features/alerting/state/actions.ts","webpack:///./public/app/features/alerting/EditNotificationChannelPage.tsx","webpack:///./public/app/features/alerting/utils/notificationChannels.ts","webpack:///./public/app/core/components/connectWithCleanUp.tsx"],"names":["NotificationSettings","currentFormValues","imageRendererAvailable","register","label","isOpen","description","uploadImage","title","sendReminder","width","OptionElement","control","option","invalid","modelValue","secure","propertyName","element","required","validate","v","validationRule","validateOption","type","inputType","placeholder","name","render","field","menuShouldPortal","options","selectOptions","undefined","console","error","value","RegExp","test","NotificationChannelOptions","errors","selectedChannelOptions","onResetSecureField","secureFields","map","index","key","selectedOptionValue","showWhen","is","settings","message","readOnly","suffix","onClick","fill","size","BasicSettings","selectedChannel","channels","resetSecureField","rules","filter","o","ChannelSettings","heading","info","severity","NotificationChannelForm","selectableChannels","watch","getValues","onTestChannel","styles","getStyles","useTheme","useEffect","fieldsToWatch","Set","className","formContainer","formItem","length","formButtons","variant","href","config","appSubUrl","stylesFactory","theme","css","spacing","md","xl","getAlertRulesAsync","async","dispatch","loadAlertRules","getBackendSrv","get","loadedAlertRules","togglePauseAlertRule","id","post","state","locationService","getSearchObject","toString","createNotificationChannel","data","appEvents","emit","AppEvents","alertSuccess","push","alertError","updateNotificationChannel","put","testNotificationChannel","getState","channel","notificationChannel","loadNotificationTypes","notificationTypes","sort","o1","o2","setNotificationChannels","loadNotificationChannel","notificationChannelLoaded","EditNotificationChannelPage","PureComponent","formData","this","props","transformSubmitData","transformTestData","componentDidMount","parseInt","match","params","navModel","notificationChannelTypes","Contents","maxWidth","onSubmit","defaultValues","find","n","c","mapChannelsToSelectableValue","rendererAvailable","mapDispatchToProps","connectWithCleanUp","getNavModel","navIndex","disableResolveMessage","frequency","autoResolve","httpMethod","secureSettings","isDefault","memoizeOne","notificationChannels","includeDescription","Object","fromEntries","entries","hasOwnProperty","assign","mapStateToProps","stateSelector","Component","ConnectedComponent","connect","ConnectedComponentWithCleanUp","useDispatch","cleanUpAction","displayName","hoistNonReactStatics"],"mappings":"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","file":"EditNotificationChannel.62c612232a976d8836f5.js","sourcesContent":["import React, { FC } from 'react';\nimport { Checkbox, CollapsableSection, Field, InfoBox, Input } from '@grafana/ui';\nimport { NotificationSettingsProps } from './NotificationChannelForm';\n\ninterface Props extends NotificationSettingsProps {\n  imageRendererAvailable: boolean;\n}\n\nexport const NotificationSettings: FC<Props> = ({ currentFormValues, imageRendererAvailable, register }) => {\n  return (\n    <CollapsableSection label=\"Notification settings\" isOpen={false}>\n      <Field>\n        <Checkbox {...register('isDefault')} label=\"Default\" description=\"Use this notification for all alerts\" />\n      </Field>\n      <Field>\n        <Checkbox\n          {...register('settings.uploadImage')}\n          label=\"Include image\"\n          description=\"Captures an image and include it in the notification\"\n        />\n      </Field>\n      {currentFormValues.uploadImage && !imageRendererAvailable && (\n        <InfoBox title=\"No image renderer available/installed\">\n          Grafana cannot find an image renderer to capture an image for the notification. Please make sure the Grafana\n          Image Renderer plugin is installed. Please contact your Grafana administrator to install the plugin.\n        </InfoBox>\n      )}\n      <Field>\n        <Checkbox\n          {...register('disableResolveMessage')}\n          label=\"Disable Resolve Message\"\n          description=\"Disable the resolve message [OK] that is sent when alerting state returns to false\"\n        />\n      </Field>\n      <Field>\n        <Checkbox\n          {...register('sendReminder')}\n          label=\"Send reminders\"\n          description=\"Send additional notifications for triggered alerts\"\n        />\n      </Field>\n      {currentFormValues.sendReminder && (\n        <>\n          <Field\n            label=\"Send reminder every\"\n            description=\"Specify how often reminders should be sent, e.g. every 30s, 1m, 10m, 30m', or 1h etc.\n            Alert reminders are sent after rules are evaluated. A reminder can never be sent more frequently\n            than a configured alert rule evaluation interval.\"\n          >\n            <Input {...register('frequency')} width={8} />\n          </Field>\n        </>\n      )}\n    </CollapsableSection>\n  );\n};\n","import React, { FC } from 'react';\nimport { FormAPI, Input, InputControl, Select, TextArea } from '@grafana/ui';\nimport { NotificationChannelOption } from '../../../types';\n\ninterface Props extends Pick<FormAPI<any>, 'register' | 'control'> {\n  option: NotificationChannelOption;\n  invalid?: boolean;\n}\n\nexport const OptionElement: FC<Props> = ({ control, option, register, invalid }) => {\n  const modelValue = option.secure ? `secureSettings.${option.propertyName}` : `settings.${option.propertyName}`;\n  switch (option.element) {\n    case 'input':\n      return (\n        <Input\n          {...register(`${modelValue}`, {\n            required: option.required ? 'Required' : false,\n            validate: (v) => (option.validationRule !== '' ? validateOption(v, option.validationRule) : true),\n          })}\n          invalid={invalid}\n          type={option.inputType}\n          placeholder={option.placeholder}\n        />\n      );\n\n    case 'select':\n      return (\n        <InputControl\n          control={control}\n          name={`${modelValue}`}\n          render={({ field: { ref, ...field } }) => (\n            <Select menuShouldPortal {...field} options={option.selectOptions ?? undefined} invalid={invalid} />\n          )}\n        />\n      );\n\n    case 'textarea':\n      return (\n        <TextArea\n          invalid={invalid}\n          {...register(`${modelValue}`, {\n            required: option.required ? 'Required' : false,\n            validate: (v) => (option.validationRule !== '' ? validateOption(v, option.validationRule) : true),\n          })}\n        />\n      );\n\n    default:\n      console.error('Element not supported', option.element);\n      return null;\n  }\n};\n\nconst validateOption = (value: string, validationRule: string) => {\n  return RegExp(validationRule).test(value) ? true : 'Invalid format';\n};\n","import React, { FC } from 'react';\nimport { SelectableValue } from '@grafana/data';\nimport { Button, Checkbox, Field, Input } from '@grafana/ui';\nimport { OptionElement } from './OptionElement';\nimport { NotificationChannelDTO, NotificationChannelOption, NotificationChannelSecureFields } from '../../../types';\nimport { NotificationSettingsProps } from './NotificationChannelForm';\n\ninterface Props extends NotificationSettingsProps {\n  selectedChannelOptions: NotificationChannelOption[];\n  currentFormValues: NotificationChannelDTO;\n  secureFields: NotificationChannelSecureFields;\n\n  onResetSecureField: (key: string) => void;\n}\n\nexport const NotificationChannelOptions: FC<Props> = ({\n  control,\n  currentFormValues,\n  errors,\n  selectedChannelOptions,\n  register,\n  onResetSecureField,\n  secureFields,\n}) => {\n  return (\n    <>\n      {selectedChannelOptions.map((option: NotificationChannelOption, index: number) => {\n        const key = `${option.label}-${index}`;\n        // Some options can be dependent on other options, this determines what is selected in the dependency options\n        // I think this needs more thought.\n        const selectedOptionValue =\n          currentFormValues[`settings.${option.showWhen.field}`] &&\n          (currentFormValues[`settings.${option.showWhen.field}`] as SelectableValue<string>).value;\n\n        if (option.showWhen.field && selectedOptionValue !== option.showWhen.is) {\n          return null;\n        }\n\n        if (option.element === 'checkbox') {\n          return (\n            <Field key={key}>\n              <Checkbox\n                {...register(\n                  option.secure ? `secureSettings.${option.propertyName}` : `settings.${option.propertyName}`\n                )}\n                label={option.label}\n                description={option.description}\n              />\n            </Field>\n          );\n        }\n        return (\n          <Field\n            key={key}\n            label={option.label}\n            description={option.description}\n            invalid={errors.settings && !!errors.settings[option.propertyName]}\n            error={errors.settings && errors.settings[option.propertyName]?.message}\n          >\n            {secureFields && secureFields[option.propertyName] ? (\n              <Input\n                readOnly={true}\n                value=\"Configured\"\n                suffix={\n                  <Button onClick={() => onResetSecureField(option.propertyName)} fill=\"text\" type=\"button\" size=\"sm\">\n                    Clear\n                  </Button>\n                }\n              />\n            ) : (\n              <OptionElement option={option} register={register} control={control} />\n            )}\n          </Field>\n        );\n      })}\n    </>\n  );\n};\n","import React, { FC } from 'react';\nimport { SelectableValue } from '@grafana/data';\nimport { Field, Input, InputControl, Select } from '@grafana/ui';\nimport { NotificationChannelOptions } from './NotificationChannelOptions';\nimport { NotificationSettingsProps } from './NotificationChannelForm';\nimport { NotificationChannelSecureFields, NotificationChannelType } from '../../../types';\n\ninterface Props extends NotificationSettingsProps {\n  selectedChannel: NotificationChannelType;\n  channels: Array<SelectableValue<string>>;\n  secureFields: NotificationChannelSecureFields;\n  resetSecureField: (key: string) => void;\n}\n\nexport const BasicSettings: FC<Props> = ({\n  control,\n  currentFormValues,\n  errors,\n  secureFields,\n  selectedChannel,\n  channels,\n  register,\n  resetSecureField,\n}) => {\n  return (\n    <>\n      <Field label=\"Name\" invalid={!!errors.name} error={errors.name && errors.name.message}>\n        <Input {...register('name', { required: 'Name is required' })} />\n      </Field>\n      <Field label=\"Type\">\n        <InputControl\n          name=\"type\"\n          render={({ field: { ref, ...field } }) => <Select menuShouldPortal {...field} options={channels} />}\n          control={control}\n          rules={{ required: true }}\n        />\n      </Field>\n      <NotificationChannelOptions\n        selectedChannelOptions={selectedChannel.options.filter((o) => o.required)}\n        currentFormValues={currentFormValues}\n        secureFields={secureFields}\n        onResetSecureField={resetSecureField}\n        register={register}\n        errors={errors}\n        control={control}\n      />\n    </>\n  );\n};\n","import React, { FC } from 'react';\nimport { Alert, CollapsableSection } from '@grafana/ui';\nimport { NotificationChannelOptions } from './NotificationChannelOptions';\nimport { NotificationSettingsProps } from './NotificationChannelForm';\nimport { NotificationChannelSecureFields, NotificationChannelType } from '../../../types';\n\ninterface Props extends NotificationSettingsProps {\n  selectedChannel: NotificationChannelType;\n  secureFields: NotificationChannelSecureFields;\n  resetSecureField: (key: string) => void;\n}\n\nexport const ChannelSettings: FC<Props> = ({\n  control,\n  currentFormValues,\n  errors,\n  selectedChannel,\n  secureFields,\n  register,\n  resetSecureField,\n}) => {\n  return (\n    <CollapsableSection label={`Optional ${selectedChannel.heading}`} isOpen={false}>\n      {selectedChannel.info !== '' && <Alert severity=\"info\" title={selectedChannel.info ?? ''} />}\n      <NotificationChannelOptions\n        selectedChannelOptions={selectedChannel.options.filter((o) => !o.required)}\n        currentFormValues={currentFormValues}\n        register={register}\n        errors={errors}\n        control={control}\n        onResetSecureField={resetSecureField}\n        secureFields={secureFields}\n      />\n    </CollapsableSection>\n  );\n};\n","import React, { FC, useEffect } from 'react';\nimport { css } from '@emotion/css';\nimport { GrafanaTheme, SelectableValue } from '@grafana/data';\nimport { Button, FormAPI, HorizontalGroup, stylesFactory, useTheme, Spinner } from '@grafana/ui';\nimport { NotificationChannelType, NotificationChannelDTO, NotificationChannelSecureFields } from '../../../types';\nimport { NotificationSettings } from './NotificationSettings';\nimport { BasicSettings } from './BasicSettings';\nimport { ChannelSettings } from './ChannelSettings';\n\nimport config from 'app/core/config';\n\ninterface Props\n  extends Pick<FormAPI<NotificationChannelDTO>, 'control' | 'errors' | 'register' | 'watch' | 'getValues'> {\n  selectableChannels: Array<SelectableValue<string>>;\n  selectedChannel?: NotificationChannelType;\n  imageRendererAvailable: boolean;\n  secureFields: NotificationChannelSecureFields;\n  resetSecureField: (key: string) => void;\n  onTestChannel: (data: NotificationChannelDTO) => void;\n}\n\nexport interface NotificationSettingsProps\n  extends Pick<FormAPI<NotificationChannelDTO>, 'control' | 'errors' | 'register'> {\n  currentFormValues: NotificationChannelDTO;\n}\n\nexport const NotificationChannelForm: FC<Props> = ({\n  control,\n  errors,\n  selectedChannel,\n  selectableChannels,\n  register,\n  watch,\n  getValues,\n  imageRendererAvailable,\n  onTestChannel,\n  resetSecureField,\n  secureFields,\n}) => {\n  const styles = getStyles(useTheme());\n\n  useEffect(() => {\n    /*\n      Finds fields that have dependencies on other fields and removes duplicates.\n      Needs to be prefixed with settings.\n    */\n    const fieldsToWatch =\n      new Set(\n        selectedChannel?.options\n          .filter((o) => o.showWhen.field)\n          .map((option) => {\n            return `settings.${option.showWhen.field}`;\n          })\n      ) || [];\n    watch(['type', 'sendReminder', 'uploadImage', ...fieldsToWatch]);\n  }, [selectedChannel?.options, watch]);\n\n  const currentFormValues = getValues();\n\n  if (!selectedChannel) {\n    return <Spinner />;\n  }\n\n  return (\n    <div className={styles.formContainer}>\n      <div className={styles.formItem}>\n        <BasicSettings\n          selectedChannel={selectedChannel}\n          channels={selectableChannels}\n          secureFields={secureFields}\n          resetSecureField={resetSecureField}\n          currentFormValues={currentFormValues}\n          register={register}\n          errors={errors}\n          control={control}\n        />\n      </div>\n      {/* If there are no non-required fields, don't render this section*/}\n      {selectedChannel.options.filter((o) => !o.required).length > 0 && (\n        <div className={styles.formItem}>\n          <ChannelSettings\n            selectedChannel={selectedChannel}\n            secureFields={secureFields}\n            resetSecureField={resetSecureField}\n            currentFormValues={currentFormValues}\n            register={register}\n            errors={errors}\n            control={control}\n          />\n        </div>\n      )}\n      <div className={styles.formItem}>\n        <NotificationSettings\n          imageRendererAvailable={imageRendererAvailable}\n          currentFormValues={currentFormValues}\n          register={register}\n          errors={errors}\n          control={control}\n        />\n      </div>\n      <div className={styles.formButtons}>\n        <HorizontalGroup>\n          <Button type=\"submit\">Save</Button>\n          <Button type=\"button\" variant=\"secondary\" onClick={() => onTestChannel(getValues())}>\n            Test\n          </Button>\n          <a href={`${config.appSubUrl}/alerting/notifications`}>\n            <Button type=\"button\" variant=\"secondary\">\n              Back\n            </Button>\n          </a>\n        </HorizontalGroup>\n      </div>\n    </div>\n  );\n};\n\nconst getStyles = stylesFactory((theme: GrafanaTheme) => {\n  return {\n    formContainer: css``,\n    formItem: css`\n      flex-grow: 1;\n      padding-top: ${theme.spacing.md};\n    `,\n    formButtons: css`\n      padding-top: ${theme.spacing.xl};\n    `,\n  };\n});\n","import { AppEvents } from '@grafana/data';\nimport { getBackendSrv, locationService } from '@grafana/runtime';\nimport { appEvents } from 'app/core/core';\nimport { loadAlertRules, loadedAlertRules, notificationChannelLoaded, setNotificationChannels } from './reducers';\nimport { AlertRuleDTO, NotifierDTO, ThunkResult } from 'app/types';\n\nexport function getAlertRulesAsync(options: { state: string }): ThunkResult<void> {\n  return async (dispatch) => {\n    dispatch(loadAlertRules());\n    const rules: AlertRuleDTO[] = await getBackendSrv().get('/api/alerts', options);\n    dispatch(loadedAlertRules(rules));\n  };\n}\n\nexport function togglePauseAlertRule(id: number, options: { paused: boolean }): ThunkResult<void> {\n  return async (dispatch) => {\n    await getBackendSrv().post(`/api/alerts/${id}/pause`, options);\n    const stateFilter = locationService.getSearchObject().state || 'all';\n    dispatch(getAlertRulesAsync({ state: stateFilter.toString() }));\n  };\n}\n\nexport function createNotificationChannel(data: any): ThunkResult<void> {\n  return async (dispatch) => {\n    try {\n      await getBackendSrv().post(`/api/alert-notifications`, data);\n      appEvents.emit(AppEvents.alertSuccess, ['Notification created']);\n      locationService.push('/alerting/notifications');\n    } catch (error) {\n      appEvents.emit(AppEvents.alertError, [error.data.error]);\n    }\n  };\n}\n\nexport function updateNotificationChannel(data: any): ThunkResult<void> {\n  return async (dispatch) => {\n    try {\n      await getBackendSrv().put(`/api/alert-notifications/${data.id}`, data);\n      appEvents.emit(AppEvents.alertSuccess, ['Notification updated']);\n    } catch (error) {\n      appEvents.emit(AppEvents.alertError, [error.data.error]);\n    }\n  };\n}\n\nexport function testNotificationChannel(data: any): ThunkResult<void> {\n  return async (dispatch, getState) => {\n    const channel = getState().notificationChannel.notificationChannel;\n    await getBackendSrv().post('/api/alert-notifications/test', { id: channel.id, ...data });\n  };\n}\n\nexport function loadNotificationTypes(): ThunkResult<void> {\n  return async (dispatch) => {\n    const alertNotifiers: NotifierDTO[] = await getBackendSrv().get(`/api/alert-notifiers`);\n\n    const notificationTypes = alertNotifiers.sort((o1, o2) => {\n      if (o1.name > o2.name) {\n        return 1;\n      }\n      return -1;\n    });\n\n    dispatch(setNotificationChannels(notificationTypes));\n  };\n}\n\nexport function loadNotificationChannel(id: number): ThunkResult<void> {\n  return async (dispatch) => {\n    await dispatch(loadNotificationTypes());\n    const notificationChannel = await getBackendSrv().get(`/api/alert-notifications/${id}`);\n    dispatch(notificationChannelLoaded(notificationChannel));\n  };\n}\n","import React, { PureComponent } from 'react';\nimport { MapDispatchToProps, MapStateToProps } from 'react-redux';\nimport { NavModel } from '@grafana/data';\nimport { config } from '@grafana/runtime';\nimport { Form, Spinner } from '@grafana/ui';\nimport Page from 'app/core/components/Page/Page';\nimport { connectWithCleanUp } from 'app/core/components/connectWithCleanUp';\nimport { NotificationChannelForm } from './components/NotificationChannelForm';\nimport { loadNotificationChannel, testNotificationChannel, updateNotificationChannel } from './state/actions';\nimport { getNavModel } from 'app/core/selectors/navModel';\nimport { mapChannelsToSelectableValue, transformSubmitData, transformTestData } from './utils/notificationChannels';\nimport { NotificationChannelType, NotificationChannelDTO, StoreState } from 'app/types';\nimport { resetSecureField } from './state/reducers';\nimport { GrafanaRouteComponentProps } from 'app/core/navigation/types';\n\ninterface OwnProps extends GrafanaRouteComponentProps<{ id: string }> {}\n\ninterface ConnectedProps {\n  navModel: NavModel;\n  notificationChannel: any;\n  notificationChannelTypes: NotificationChannelType[];\n}\n\ninterface DispatchProps {\n  loadNotificationChannel: typeof loadNotificationChannel;\n  testNotificationChannel: typeof testNotificationChannel;\n  updateNotificationChannel: typeof updateNotificationChannel;\n  resetSecureField: typeof resetSecureField;\n}\n\ntype Props = OwnProps & ConnectedProps & DispatchProps;\n\nexport class EditNotificationChannelPage extends PureComponent<Props> {\n  componentDidMount() {\n    this.props.loadNotificationChannel(parseInt(this.props.match.params.id, 10));\n  }\n\n  onSubmit = (formData: NotificationChannelDTO) => {\n    const { notificationChannel } = this.props;\n\n    this.props.updateNotificationChannel({\n      /*\n       Some settings which lives in a collapsed section will not be registered since\n       the section will not be rendered if a user doesn't expand it. Therefore we need to\n       merge the initialData with any changes from the form.\n      */\n      ...transformSubmitData({\n        ...notificationChannel,\n        ...formData,\n        settings: { ...notificationChannel.settings, ...formData.settings },\n      }),\n      id: notificationChannel.id,\n    });\n  };\n\n  onTestChannel = (formData: NotificationChannelDTO) => {\n    const { notificationChannel } = this.props;\n    /*\n      Same as submit\n     */\n    this.props.testNotificationChannel(\n      transformTestData({\n        ...notificationChannel,\n        ...formData,\n        settings: { ...notificationChannel.settings, ...formData.settings },\n      })\n    );\n  };\n\n  render() {\n    const { navModel, notificationChannel, notificationChannelTypes } = this.props;\n\n    return (\n      <Page navModel={navModel}>\n        <Page.Contents>\n          <h2 className=\"page-sub-heading\">Edit notification channel</h2>\n          {notificationChannel && notificationChannel.id > 0 ? (\n            <Form\n              maxWidth={600}\n              onSubmit={this.onSubmit}\n              defaultValues={{\n                ...notificationChannel,\n                type: notificationChannelTypes.find((n) => n.value === notificationChannel.type),\n              }}\n            >\n              {({ control, errors, getValues, register, watch }) => {\n                const selectedChannel = notificationChannelTypes.find((c) => c.value === getValues().type.value);\n\n                return (\n                  <NotificationChannelForm\n                    selectableChannels={mapChannelsToSelectableValue(notificationChannelTypes, true)}\n                    selectedChannel={selectedChannel}\n                    imageRendererAvailable={config.rendererAvailable}\n                    onTestChannel={this.onTestChannel}\n                    register={register}\n                    watch={watch}\n                    errors={errors}\n                    getValues={getValues}\n                    control={control}\n                    resetSecureField={this.props.resetSecureField}\n                    secureFields={notificationChannel.secureFields}\n                  />\n                );\n              }}\n            </Form>\n          ) : (\n            <div>\n              Loading notification channel\n              <Spinner />\n            </div>\n          )}\n        </Page.Contents>\n      </Page>\n    );\n  }\n}\n\nconst mapStateToProps: MapStateToProps<ConnectedProps, OwnProps, StoreState> = (state) => {\n  return {\n    navModel: getNavModel(state.navIndex, 'channels'),\n    notificationChannel: state.notificationChannel.notificationChannel,\n    notificationChannelTypes: state.notificationChannel.notificationChannelTypes,\n  };\n};\n\nconst mapDispatchToProps: MapDispatchToProps<DispatchProps, OwnProps> = {\n  loadNotificationChannel,\n  testNotificationChannel,\n  updateNotificationChannel,\n  resetSecureField,\n};\n\nexport default connectWithCleanUp(\n  mapStateToProps,\n  mapDispatchToProps,\n  (state) => state.notificationChannel\n)(EditNotificationChannelPage);\n","import memoizeOne from 'memoize-one';\nimport { SelectableValue } from '@grafana/data';\nimport { config } from '@grafana/runtime';\nimport { NotificationChannelDTO, NotificationChannelType } from 'app/types';\n\nexport const defaultValues: NotificationChannelDTO = {\n  id: -1,\n  name: '',\n  type: { value: 'email', label: 'Email' },\n  sendReminder: false,\n  disableResolveMessage: false,\n  frequency: '15m',\n  settings: {\n    uploadImage: config.rendererAvailable,\n    autoResolve: true,\n    httpMethod: 'POST',\n    severity: 'critical',\n  },\n  secureSettings: {},\n  secureFields: {},\n  isDefault: false,\n};\n\nexport const mapChannelsToSelectableValue = memoizeOne(\n  (notificationChannels: NotificationChannelType[], includeDescription: boolean): Array<SelectableValue<string>> => {\n    return notificationChannels.map((channel) => {\n      if (includeDescription) {\n        return {\n          value: channel.value,\n          label: channel.label,\n          description: channel.description,\n        };\n      }\n      return {\n        value: channel.value,\n        label: channel.label,\n      };\n    });\n  }\n);\n\nexport const transformSubmitData = (formData: NotificationChannelDTO) => {\n  /*\n    Some settings can be options in a select, in order to not save a SelectableValue<T>\n    we need to use check if it is a SelectableValue and use its value.\n  */\n  const settings = Object.fromEntries(\n    Object.entries(formData.settings).map(([key, value]) => {\n      return [key, value && value.hasOwnProperty('value') ? value.value : value];\n    })\n  );\n\n  return {\n    ...defaultValues,\n    ...formData,\n    frequency: formData.frequency === '' ? defaultValues.frequency : formData.frequency,\n    type: formData.type.value,\n    settings: { ...defaultValues.settings, ...settings },\n    secureSettings: { ...formData.secureSettings },\n  };\n};\n\nexport const transformTestData = (formData: NotificationChannelDTO) => {\n  return {\n    name: formData.name,\n    type: formData.type.value,\n    frequency: formData.frequency ?? defaultValues.frequency,\n    settings: { ...Object.assign(defaultValues.settings, formData.settings) },\n    secureSettings: { ...formData.secureSettings },\n  };\n};\n","import { connect, MapDispatchToPropsParam, MapStateToPropsParam, useDispatch } from 'react-redux';\nimport { cleanUpAction, StateSelector } from '../actions/cleanUp';\nimport React, { ComponentType, FunctionComponent, useEffect } from 'react';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\n\nexport const connectWithCleanUp = <\n  TStateProps extends {} = {},\n  TDispatchProps = {},\n  TOwnProps = {},\n  State = {},\n  TSelector extends object = {},\n  Statics = {}\n>(\n  mapStateToProps: MapStateToPropsParam<TStateProps, TOwnProps, State>,\n  mapDispatchToProps: MapDispatchToPropsParam<TDispatchProps, TOwnProps>,\n  stateSelector: StateSelector<TSelector>\n) => (Component: ComponentType<any>) => {\n  const ConnectedComponent = connect(\n    mapStateToProps,\n    mapDispatchToProps\n    // @ts-ignore\n  )(Component);\n\n  const ConnectedComponentWithCleanUp: FunctionComponent = (props) => {\n    const dispatch = useDispatch();\n    useEffect(() => {\n      return function cleanUp() {\n        dispatch(cleanUpAction({ stateSelector }));\n      };\n    }, [dispatch]);\n    // @ts-ignore\n    return <ConnectedComponent {...props} />;\n  };\n\n  ConnectedComponentWithCleanUp.displayName = `ConnectWithCleanUp(${ConnectedComponent.displayName})`;\n  hoistNonReactStatics(ConnectedComponentWithCleanUp, Component);\n  type Hoisted = typeof ConnectedComponentWithCleanUp & Statics;\n\n  return ConnectedComponentWithCleanUp as Hoisted;\n};\n"],"sourceRoot":""}