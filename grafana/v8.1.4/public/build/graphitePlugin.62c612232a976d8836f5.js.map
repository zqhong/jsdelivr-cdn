{"version":3,"sources":["webpack:///./public/app/core/utils/version.ts","webpack:///./public/app/plugins/datasource/graphite/gfunc.ts","webpack:///./public/app/plugins/datasource/graphite/types.ts","webpack:///./public/app/plugins/datasource/graphite/meta.ts","webpack:///./public/app/plugins/datasource/graphite/versions.ts","webpack:///./public/app/plugins/datasource/graphite/datasource.ts","webpack:///./public/app/plugins/datasource/graphite/utils.ts","webpack:///./public/app/plugins/datasource/graphite/state/helpers.ts","webpack:///./public/app/plugins/datasource/graphite/state/providers.ts","webpack:///./public/app/plugins/datasource/graphite/state/store.ts","webpack:///./public/app/plugins/datasource/graphite/query_ctrl.ts","webpack:///./public/app/plugins/datasource/graphite/configuration/MappingsHelp.tsx","webpack:///./public/app/plugins/datasource/graphite/configuration/MappingsConfiguration.tsx","webpack:///./public/app/plugins/datasource/graphite/configuration/parseLokiLabelMappings.ts","webpack:///./public/app/plugins/datasource/graphite/configuration/ConfigEditor.tsx","webpack:///./public/app/plugins/datasource/graphite/MetricTankMetaInspector.tsx","webpack:///./public/app/plugins/datasource/graphite/module.ts"],"names":["versionPattern","SemVersion","constructor","version","this","major","minor","patch","meta","match","exec","Number","isGtOrEq","compared","i","comparable","length","isValid","isNumber","isVersionGtOrEq","a","b","index","addFuncDef","funcDef","params","defaultParams","name","shortName","optionalSeriesRefArgs","type","optional","multiple","isVersionRelatedFunction","obj","graphiteVersion","category","options","fake","FuncInstance","def","withDefaultParams","slice","updateText","render","metricExp","replaceVariables","str","parameters","map","value","paramType","get","last","includes","valueInterpolated","isString","isFinite","toString","pop","unshift","join","_hasMultipleParamsInString","strValue","indexOf","updateParam","each","split","partVal","idx","trim","splice","text","getFuncDef","unknown","createFuncInstance","getFuncDefs","funcs","forEach","assign","filter","param","parseFuncDefs","rawDefs","funcDefs","funcName","group","description","replace","func","test","required","shift","rawParam","undefined","default","Infinity","push","suggestions","GraphiteType","toInteger","val","parseInt","toBooleanOrTimestamp","getRollupNotice","metaList","archiveIndex","parseSchemaRetentions","interval","severity","inspect","getRuntimeConsolidationNotice","runtimeNr","spec","vals","retention","chunkspan","numchunks","ready","GRAPHITE_VERSIONS","DEFAULT_GRAPHITE_VERSION","GraphiteDatasource","DataSourceApi","instanceSettings","templateSrv","getTemplateSrv","super","result","data","series","isArray","message","s","title","target","y","datapoints","frame","toDataFrame","custom","requestMetaList","seriesMetaList","rollupIndicatorEnabled","rollupNotice","runtimeNotice","notices","stats","getRequestStats","basicAuth","url","jsonData","metricMappings","importConfiguration","loki","mappings","isMetricTank","graphiteType","Metrictank","supportsTags","cacheTimeout","withCredentials","funcDefsPromise","_seriesRefLetters","getQueryOptionsInfo","maxDataPoints","links","getImportQueryConfiguration","query","graphOptions","from","translateTime","range","raw","timezone","until","to","targets","format","buildGraphiteParams","scopedVars","of","httpOptions","method","headers","addTracingHeaders","panelId","requestId","doGraphiteRequest","pipe","convertResponseToDataFrames","dashboardId","key","unit","endsWith","displayName","parseTags","tagString","tags","interpolateVariablesInQueries","queries","expandedQueries","datasource","annotationQuery","annotation","graphiteQuery","list","time","fields","values","toPromise","events","then","results","console","error","e","when","what","err","Promise","reject","targetContainsTemplate","variableExists","date","roundUp","substring","dateMath","parse","add","subtract","unix","metricFindQuery","optionalOptions","interpolatedQuery","getSearchFilterScopedVar","wildcardChar","allParams","expressions","p","limit","getTagValuesAutoComplete","getTagsAutoComplete","useExpand","requestMetricExpand","requestMetricFind","_map","metric","expandable","getTags","tag","id","getTagValues","tagPrefix","expr","expression","mapToTags","valuePrefix","getVersion","catchError","gfunc","waitForFuncDefsLoaded","resolve","status","fixedData","JSON","testDatasource","rangeRaw","Authorization","getBackendSrv","fetch","throwError","startsWith","newMessage","reduceError","graphiteOptions","cleanOptions","targetValue","regex","intervalFormatFixRegex","hasTargets","fixIntervalFormat","refId","nestedSeriesRegexReplacer","g1","hide","encodeURIComponent","GRAPHITE_TAG_OPERATORS","async","parseTarget","state","queryModel","buildSegments","modifyLastSegment","segments","segment","uiSegmentSrv","newSegment","checkOtherSegmentsIndex","checkOtherSegments","seriesByTagUsed","fixTagSegments","addSelectMetricSegment","newSelectMetric","fromIndex","path","getSegmentPathUpTo","handleMetricsAutoCompleteError","setSegmentFocus","segmentIndex","focus","emptySegments","addTagSegments","newPlusButton","handleTargetChanged","oldTarget","updateModelTarget","panelCtrl","panel","paused","refresh","metricAutoCompleteErrorShown","dispatch","notifyApp","createErrorNotification","handleTagsAutoCompleteError","tagsAutoCompleteErrorShown","getAltSegments","prefix","altSegments","eachRight","getVariables","variable","remove","removeTaggedEntry","tagSegments","getTagsAsSegments","concat","addAltTagSegments","tagsAsSegments","tagExpressions","renderTagExpressions","mapToDropdownOptions","reducer","action","actions","init","deps","payload","GraphiteQuery","removeTagValue","segmentValueChanged","updateSegmentValue","functions","pause","newFunc","tagParam","addFunction","added","addSeriesByTagFunc","spliceSegments","tagChanged","tagIndex","updateTag","addNewTag","newTag","operator","addTag","unpause","smartlyHandleNewAliasByNode","removeFunction","moveFunction","offset","updateFunctionParam","updateQuery","runQuery","toggleEditorMode","textEditor","GraphiteQueryCtrl","QueryCtrl","$scope","$injector","onChange","createStore","$digest","event","getAllTags","altTags","getTagOperators","getAllTagValues","tagKey","altValues","removeTag","showDelimiter","getCollapsedText","MappingsHelp","props","onRemove","onDismiss","MappingsConfiguration","setMappings","useState","className","showHelp","variant","onClick","onRestoreHelp","mapping","label","width","changeEvent","newMappings","onBlur","placeholder","aria-label","size","_","icon","fromString","matchers","metricNode","labelName","matcher","Select","Switch","LegacyForms","SHOW_MAPPINGS_HELP_KEY","graphiteVersions","graphiteTypes","Object","entries","ConfigEditor","PureComponent","href","rel","showMappingsHelp","store","getObject","componentDidMount","updateDatasourcePluginJsonDataOption","currentGraphiteVersion","onOptionsChange","currentVersion","find","item","access","defaultUrl","dataSourceConfig","tooltip","menuShouldPortal","onUpdateDatasourceJsonDataOptionSelect","renderTypeHelp","labelClass","checked","onUpdateDatasourceJsonDataOptionChecked","setState","setObject","MetricTankMetaInspector","renderMeta","styles","getStyles","buckets","normFunc","totalSeconds","reduce","acc","bucket","rangeUtil","intervalToSeconds","metaItem","metaItemHeader","count","metaItemBody","step","stepHeading","stepDescription","lengthPercent","isActive","bucketInterval","cx","bucketRetention","bucketRetentionActive","style","flexGrow","seriesMetas","stringify","keys","stylesFactory","theme","config","borderColor","isDark","palette","gray25","gray85","background","dark1","white","headerBg","gray15","css","spacing","md","xs","typography","sm","colors","textWeak","lg","border","radius","blue85","blue95","greenBase","greenShade","AnnotationsQueryCtrl","plugin","DataSourcePlugin","setQueryCtrl","setConfigEditor","setMetadataInspector","setAnnotationQueryCtrl"],"mappings":"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","file":"graphitePlugin.62c612232a976d8836f5.js","sourcesContent":["import { isNumber } from 'lodash';\n\nconst versionPattern = /^(\\d+)(?:\\.(\\d+))?(?:\\.(\\d+))?(?:-([0-9A-Za-z\\.]+))?/;\n\nexport class SemVersion {\n  major: number;\n  minor: number;\n  patch: number;\n  meta: string;\n\n  constructor(version: string) {\n    this.major = 0;\n    this.minor = 0;\n    this.patch = 0;\n    this.meta = '';\n    const match = versionPattern.exec(version);\n    if (match) {\n      this.major = Number(match[1]);\n      this.minor = Number(match[2] || 0);\n      this.patch = Number(match[3] || 0);\n      this.meta = match[4];\n    }\n  }\n\n  isGtOrEq(version: string): boolean {\n    const compared = new SemVersion(version);\n\n    for (let i = 0; i < this.comparable.length; ++i) {\n      if (this.comparable[i] > compared.comparable[i]) {\n        return true;\n      }\n      if (this.comparable[i] < compared.comparable[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  isValid(): boolean {\n    return isNumber(this.major);\n  }\n\n  get comparable() {\n    return [this.major, this.minor, this.patch];\n  }\n}\n\nexport function isVersionGtOrEq(a: string, b: string): boolean {\n  const aSemver = new SemVersion(a);\n  return aSemver.isGtOrEq(b);\n}\n","import { assign, each, filter, forEach, get, includes, isString, last, map, toString, isFinite } from 'lodash';\nimport { isVersionGtOrEq } from 'app/core/utils/version';\nimport { InterpolateFunction } from '@grafana/data';\n\nexport type ParamDef = {\n  name: string;\n  type: string;\n  options?: Array<string | number>;\n  multiple?: boolean;\n  optional?: boolean;\n  version?: string;\n};\n\nexport interface FuncDef {\n  name: string;\n  params: ParamDef[];\n  defaultParams: Array<string | number>;\n  category?: string;\n  shortName?: any;\n  fake?: boolean;\n  version?: string;\n  description?: string;\n  /**\n   * True if the function was not found on the list of available function descriptions.\n   */\n  unknown?: boolean;\n}\n\nexport type FuncDefs = {\n  [functionName in string]: FuncDef;\n};\n\nconst index: FuncDefs = {};\n\nfunction addFuncDef(funcDef: Partial<FuncDef> & { name: string; category: string }) {\n  funcDef.params = funcDef.params || [];\n  funcDef.defaultParams = funcDef.defaultParams || [];\n\n  index[funcDef.name] = funcDef as FuncDef;\n  if (funcDef.shortName) {\n    index[funcDef.shortName] = funcDef as FuncDef;\n  }\n}\n\nconst optionalSeriesRefArgs = [{ name: 'other', type: 'value_or_series', optional: true, multiple: true }];\n\naddFuncDef({\n  name: 'scaleToSeconds',\n  category: 'Transform',\n  params: [{ name: 'seconds', type: 'int' }],\n  defaultParams: [1],\n});\n\naddFuncDef({\n  name: 'perSecond',\n  category: 'Transform',\n  params: [{ name: 'max value', type: 'int', optional: true }],\n  defaultParams: [],\n});\n\naddFuncDef({\n  name: 'holtWintersForecast',\n  category: 'Calculate',\n});\n\naddFuncDef({\n  name: 'holtWintersConfidenceBands',\n  category: 'Calculate',\n  params: [{ name: 'delta', type: 'int' }],\n  defaultParams: [3],\n});\n\naddFuncDef({\n  name: 'holtWintersAberration',\n  category: 'Calculate',\n  params: [{ name: 'delta', type: 'int' }],\n  defaultParams: [3],\n});\n\naddFuncDef({\n  name: 'nPercentile',\n  category: 'Calculate',\n  params: [{ name: 'Nth percentile', type: 'int' }],\n  defaultParams: [95],\n});\n\naddFuncDef({\n  name: 'diffSeries',\n  params: optionalSeriesRefArgs,\n  defaultParams: ['#A'],\n  category: 'Combine',\n});\n\naddFuncDef({\n  name: 'stddevSeries',\n  params: optionalSeriesRefArgs,\n  defaultParams: [''],\n  category: 'Combine',\n});\n\naddFuncDef({\n  name: 'divideSeries',\n  params: optionalSeriesRefArgs,\n  defaultParams: ['#A'],\n  category: 'Combine',\n});\n\naddFuncDef({\n  name: 'multiplySeries',\n  params: optionalSeriesRefArgs,\n  defaultParams: ['#A'],\n  category: 'Combine',\n});\n\naddFuncDef({\n  name: 'asPercent',\n  params: optionalSeriesRefArgs,\n  defaultParams: ['#A'],\n  category: 'Combine',\n});\n\naddFuncDef({\n  name: 'group',\n  params: optionalSeriesRefArgs,\n  defaultParams: ['#A', '#B'],\n  category: 'Combine',\n});\n\naddFuncDef({\n  name: 'sumSeries',\n  shortName: 'sum',\n  category: 'Combine',\n  params: optionalSeriesRefArgs,\n  defaultParams: [''],\n});\n\naddFuncDef({\n  name: 'averageSeries',\n  shortName: 'avg',\n  category: 'Combine',\n  params: optionalSeriesRefArgs,\n  defaultParams: [''],\n});\n\naddFuncDef({\n  name: 'rangeOfSeries',\n  category: 'Combine',\n});\n\naddFuncDef({\n  name: 'percentileOfSeries',\n  category: 'Combine',\n  params: [\n    { name: 'n', type: 'int' },\n    { name: 'interpolate', type: 'boolean', options: ['true', 'false'] },\n  ],\n  defaultParams: [95, 'false'],\n});\n\naddFuncDef({\n  name: 'sumSeriesWithWildcards',\n  category: 'Combine',\n  params: [{ name: 'node', type: 'int', multiple: true }],\n  defaultParams: [3],\n});\n\naddFuncDef({\n  name: 'maxSeries',\n  shortName: 'max',\n  category: 'Combine',\n});\n\naddFuncDef({\n  name: 'minSeries',\n  shortName: 'min',\n  category: 'Combine',\n});\n\naddFuncDef({\n  name: 'averageSeriesWithWildcards',\n  category: 'Combine',\n  params: [{ name: 'node', type: 'int', multiple: true }],\n  defaultParams: [3],\n});\n\naddFuncDef({\n  name: 'alias',\n  category: 'Alias',\n  params: [{ name: 'alias', type: 'string' }],\n  defaultParams: ['alias'],\n});\n\naddFuncDef({\n  name: 'aliasSub',\n  category: 'Alias',\n  params: [\n    { name: 'search', type: 'string' },\n    { name: 'replace', type: 'string' },\n  ],\n  defaultParams: ['', '\\\\1'],\n});\n\naddFuncDef({\n  name: 'consolidateBy',\n  category: 'Special',\n  params: [\n    {\n      name: 'function',\n      type: 'string',\n      options: ['sum', 'average', 'min', 'max'],\n    },\n  ],\n  defaultParams: ['max'],\n});\n\naddFuncDef({\n  name: 'cumulative',\n  category: 'Special',\n  params: [],\n  defaultParams: [],\n});\n\naddFuncDef({\n  name: 'groupByNode',\n  category: 'Combine',\n  params: [\n    {\n      name: 'node',\n      type: 'int',\n      options: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12],\n    },\n    {\n      name: 'function',\n      type: 'string',\n      options: ['sum', 'avg', 'maxSeries'],\n    },\n  ],\n  defaultParams: [3, 'sum'],\n});\n\naddFuncDef({\n  name: 'aliasByNode',\n  category: 'Alias',\n  params: [\n    {\n      name: 'node',\n      type: 'int',\n      options: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12],\n      multiple: true,\n    },\n  ],\n  defaultParams: [3],\n});\n\naddFuncDef({\n  name: 'substr',\n  category: 'Special',\n  params: [\n    {\n      name: 'start',\n      type: 'int',\n      options: [-6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12],\n    },\n    {\n      name: 'stop',\n      type: 'int',\n      options: [-6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12],\n    },\n  ],\n  defaultParams: [0, 0],\n});\n\naddFuncDef({\n  name: 'sortByName',\n  category: 'Sorting',\n  params: [\n    {\n      name: 'natural',\n      type: 'boolean',\n      options: ['true', 'false'],\n      optional: true,\n    },\n  ],\n  defaultParams: ['false'],\n});\n\naddFuncDef({\n  name: 'sortByMaxima',\n  category: 'Sorting',\n});\n\naddFuncDef({\n  name: 'sortByMinima',\n  category: 'Sorting',\n});\n\naddFuncDef({\n  name: 'sortByTotal',\n  category: 'Sorting',\n});\n\naddFuncDef({\n  name: 'aliasByMetric',\n  category: 'Alias',\n});\n\naddFuncDef({\n  name: 'randomWalk',\n  fake: true,\n  category: 'Special',\n  params: [{ name: 'name', type: 'string' }],\n  defaultParams: ['randomWalk'],\n});\n\naddFuncDef({\n  name: 'countSeries',\n  category: 'Combine',\n});\n\naddFuncDef({\n  name: 'constantLine',\n  category: 'Special',\n  params: [{ name: 'value', type: 'int' }],\n  defaultParams: [10],\n});\n\naddFuncDef({\n  name: 'cactiStyle',\n  category: 'Special',\n});\n\naddFuncDef({\n  name: 'keepLastValue',\n  category: 'Transform',\n  params: [{ name: 'n', type: 'int' }],\n  defaultParams: [100],\n});\n\naddFuncDef({\n  name: 'changed',\n  category: 'Special',\n  params: [],\n  defaultParams: [],\n});\n\naddFuncDef({\n  name: 'scale',\n  category: 'Transform',\n  params: [{ name: 'factor', type: 'int' }],\n  defaultParams: [1],\n});\n\naddFuncDef({\n  name: 'offset',\n  category: 'Transform',\n  params: [{ name: 'amount', type: 'int' }],\n  defaultParams: [10],\n});\n\naddFuncDef({\n  name: 'transformNull',\n  category: 'Transform',\n  params: [{ name: 'amount', type: 'int' }],\n  defaultParams: [0],\n});\n\naddFuncDef({\n  name: 'integral',\n  category: 'Transform',\n});\n\naddFuncDef({\n  name: 'derivative',\n  category: 'Transform',\n});\n\naddFuncDef({\n  name: 'nonNegativeDerivative',\n  category: 'Transform',\n  params: [{ name: 'max value or 0', type: 'int', optional: true }],\n  defaultParams: [''],\n});\n\naddFuncDef({\n  name: 'timeShift',\n  category: 'Transform',\n  params: [\n    {\n      name: 'amount',\n      type: 'select',\n      options: ['1h', '6h', '12h', '1d', '2d', '7d', '14d', '30d'],\n    },\n  ],\n  defaultParams: ['1d'],\n});\n\naddFuncDef({\n  name: 'timeStack',\n  category: 'Transform',\n  params: [\n    {\n      name: 'timeShiftUnit',\n      type: 'select',\n      options: ['1h', '6h', '12h', '1d', '2d', '7d', '14d', '30d'],\n    },\n    { name: 'timeShiftStart', type: 'int' },\n    { name: 'timeShiftEnd', type: 'int' },\n  ],\n  defaultParams: ['1d', 0, 7],\n});\n\naddFuncDef({\n  name: 'summarize',\n  category: 'Transform',\n  params: [\n    { name: 'interval', type: 'string' },\n    {\n      name: 'func',\n      type: 'select',\n      options: ['sum', 'avg', 'min', 'max', 'last'],\n    },\n    {\n      name: 'alignToFrom',\n      type: 'boolean',\n      optional: true,\n      options: ['false', 'true'],\n    },\n  ],\n  defaultParams: ['1h', 'sum', 'false'],\n});\n\naddFuncDef({\n  name: 'smartSummarize',\n  category: 'Transform',\n  params: [\n    { name: 'interval', type: 'string' },\n    {\n      name: 'func',\n      type: 'select',\n      options: ['sum', 'avg', 'min', 'max', 'last'],\n    },\n  ],\n  defaultParams: ['1h', 'sum'],\n});\n\naddFuncDef({\n  name: 'absolute',\n  category: 'Transform',\n});\n\naddFuncDef({\n  name: 'hitcount',\n  category: 'Transform',\n  params: [{ name: 'interval', type: 'string' }],\n  defaultParams: ['10s'],\n});\n\naddFuncDef({\n  name: 'log',\n  category: 'Transform',\n  params: [{ name: 'base', type: 'int' }],\n  defaultParams: ['10'],\n});\n\naddFuncDef({\n  name: 'averageAbove',\n  category: 'Filter Series',\n  params: [{ name: 'n', type: 'int' }],\n  defaultParams: [25],\n});\n\naddFuncDef({\n  name: 'averageBelow',\n  category: 'Filter Series',\n  params: [{ name: 'n', type: 'int' }],\n  defaultParams: [25],\n});\n\naddFuncDef({\n  name: 'currentAbove',\n  category: 'Filter Series',\n  params: [{ name: 'n', type: 'int' }],\n  defaultParams: [25],\n});\n\naddFuncDef({\n  name: 'currentBelow',\n  category: 'Filter Series',\n  params: [{ name: 'n', type: 'int' }],\n  defaultParams: [25],\n});\n\naddFuncDef({\n  name: 'maximumAbove',\n  category: 'Filter Series',\n  params: [{ name: 'value', type: 'int' }],\n  defaultParams: [0],\n});\n\naddFuncDef({\n  name: 'maximumBelow',\n  category: 'Filter Series',\n  params: [{ name: 'value', type: 'int' }],\n  defaultParams: [0],\n});\n\naddFuncDef({\n  name: 'minimumAbove',\n  category: 'Filter Series',\n  params: [{ name: 'value', type: 'int' }],\n  defaultParams: [0],\n});\n\naddFuncDef({\n  name: 'minimumBelow',\n  category: 'Filter Series',\n  params: [{ name: 'value', type: 'int' }],\n  defaultParams: [0],\n});\n\naddFuncDef({\n  name: 'limit',\n  category: 'Filter Series',\n  params: [{ name: 'n', type: 'int' }],\n  defaultParams: [5],\n});\n\naddFuncDef({\n  name: 'mostDeviant',\n  category: 'Filter Series',\n  params: [{ name: 'n', type: 'int' }],\n  defaultParams: [10],\n});\n\naddFuncDef({\n  name: 'exclude',\n  category: 'Filter Series',\n  params: [{ name: 'exclude', type: 'string' }],\n  defaultParams: ['exclude'],\n});\n\naddFuncDef({\n  name: 'highestCurrent',\n  category: 'Filter Series',\n  params: [{ name: 'count', type: 'int' }],\n  defaultParams: [5],\n});\n\naddFuncDef({\n  name: 'highestMax',\n  category: 'Filter Series',\n  params: [{ name: 'count', type: 'int' }],\n  defaultParams: [5],\n});\n\naddFuncDef({\n  name: 'lowestCurrent',\n  category: 'Filter Series',\n  params: [{ name: 'count', type: 'int' }],\n  defaultParams: [5],\n});\n\naddFuncDef({\n  name: 'movingAverage',\n  category: 'Calculate',\n  params: [\n    {\n      name: 'windowSize',\n      type: 'int_or_interval',\n      options: ['5', '7', '10', '5min', '10min', '30min', '1hour'],\n    },\n  ],\n  defaultParams: [10],\n});\n\naddFuncDef({\n  name: 'movingMedian',\n  category: 'Calculate',\n  params: [\n    {\n      name: 'windowSize',\n      type: 'int_or_interval',\n      options: ['5', '7', '10', '5min', '10min', '30min', '1hour'],\n    },\n  ],\n  defaultParams: ['5'],\n});\n\naddFuncDef({\n  name: 'stdev',\n  category: 'Calculate',\n  params: [\n    { name: 'n', type: 'int' },\n    { name: 'tolerance', type: 'int' },\n  ],\n  defaultParams: [5, 0.1],\n});\n\naddFuncDef({\n  name: 'highestAverage',\n  category: 'Filter Series',\n  params: [{ name: 'count', type: 'int' }],\n  defaultParams: [5],\n});\n\naddFuncDef({\n  name: 'lowestAverage',\n  category: 'Filter Series',\n  params: [{ name: 'count', type: 'int' }],\n  defaultParams: [5],\n});\n\naddFuncDef({\n  name: 'removeAbovePercentile',\n  category: 'Filter Data',\n  params: [{ name: 'n', type: 'int' }],\n  defaultParams: [5],\n});\n\naddFuncDef({\n  name: 'removeAboveValue',\n  category: 'Filter Data',\n  params: [{ name: 'n', type: 'int' }],\n  defaultParams: [5],\n});\n\naddFuncDef({\n  name: 'removeBelowPercentile',\n  category: 'Filter Data',\n  params: [{ name: 'n', type: 'int' }],\n  defaultParams: [5],\n});\n\naddFuncDef({\n  name: 'removeBelowValue',\n  category: 'Filter Data',\n  params: [{ name: 'n', type: 'int' }],\n  defaultParams: [5],\n});\n\naddFuncDef({\n  name: 'useSeriesAbove',\n  category: 'Filter Series',\n  params: [\n    { name: 'value', type: 'int' },\n    { name: 'search', type: 'string' },\n    { name: 'replace', type: 'string' },\n  ],\n  defaultParams: [0, 'search', 'replace'],\n});\n\n////////////////////\n// Graphite 1.0.x //\n////////////////////\n\naddFuncDef({\n  name: 'aggregateLine',\n  category: 'Calculate',\n  params: [\n    {\n      name: 'func',\n      type: 'select',\n      options: ['sum', 'avg', 'min', 'max', 'last'],\n    },\n  ],\n  defaultParams: ['avg'],\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'averageOutsidePercentile',\n  category: 'Filter Series',\n  params: [{ name: 'n', type: 'int' }],\n  defaultParams: [95],\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'delay',\n  category: 'Transform',\n  params: [{ name: 'steps', type: 'int' }],\n  defaultParams: [1],\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'exponentialMovingAverage',\n  category: 'Calculate',\n  params: [\n    {\n      name: 'windowSize',\n      type: 'int_or_interval',\n      options: ['5', '7', '10', '5min', '10min', '30min', '1hour'],\n    },\n  ],\n  defaultParams: [10],\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'fallbackSeries',\n  category: 'Special',\n  params: [{ name: 'fallback', type: 'string' }],\n  defaultParams: ['constantLine(0)'],\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'grep',\n  category: 'Filter Series',\n  params: [{ name: 'grep', type: 'string' }],\n  defaultParams: ['grep'],\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'groupByNodes',\n  category: 'Combine',\n  params: [\n    {\n      name: 'function',\n      type: 'string',\n      options: ['sum', 'avg', 'maxSeries'],\n    },\n    {\n      name: 'node',\n      type: 'int',\n      options: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12],\n      multiple: true,\n    },\n  ],\n  defaultParams: ['sum', 3],\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'integralByInterval',\n  category: 'Transform',\n  params: [\n    {\n      name: 'intervalUnit',\n      type: 'select',\n      options: ['1h', '6h', '12h', '1d', '2d', '7d', '14d', '30d'],\n    },\n  ],\n  defaultParams: ['1d'],\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'interpolate',\n  category: 'Transform',\n  params: [{ name: 'limit', type: 'int', optional: true }],\n  defaultParams: [],\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'invert',\n  category: 'Transform',\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'isNonNull',\n  category: 'Combine',\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'linearRegression',\n  category: 'Calculate',\n  params: [\n    {\n      name: 'startSourceAt',\n      type: 'select',\n      options: ['-1h', '-6h', '-12h', '-1d', '-2d', '-7d', '-14d', '-30d'],\n      optional: true,\n    },\n    {\n      name: 'endSourceAt',\n      type: 'select',\n      options: ['-1h', '-6h', '-12h', '-1d', '-2d', '-7d', '-14d', '-30d'],\n      optional: true,\n    },\n  ],\n  defaultParams: [],\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'mapSeries',\n  shortName: 'map',\n  params: [{ name: 'node', type: 'int' }],\n  defaultParams: [3],\n  category: 'Combine',\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'movingMin',\n  category: 'Calculate',\n  params: [\n    {\n      name: 'windowSize',\n      type: 'int_or_interval',\n      options: ['5', '7', '10', '5min', '10min', '30min', '1hour'],\n    },\n  ],\n  defaultParams: [10],\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'movingMax',\n  category: 'Calculate',\n  params: [\n    {\n      name: 'windowSize',\n      type: 'int_or_interval',\n      options: ['5', '7', '10', '5min', '10min', '30min', '1hour'],\n    },\n  ],\n  defaultParams: [10],\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'movingSum',\n  category: 'Calculate',\n  params: [\n    {\n      name: 'windowSize',\n      type: 'int_or_interval',\n      options: ['5', '7', '10', '5min', '10min', '30min', '1hour'],\n    },\n  ],\n  defaultParams: [10],\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'multiplySeriesWithWildcards',\n  category: 'Combine',\n  params: [\n    {\n      name: 'position',\n      type: 'int',\n      options: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12],\n      multiple: true,\n    },\n  ],\n  defaultParams: [2],\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'offsetToZero',\n  category: 'Transform',\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'pow',\n  category: 'Transform',\n  params: [{ name: 'factor', type: 'int' }],\n  defaultParams: [10],\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'powSeries',\n  category: 'Transform',\n  params: optionalSeriesRefArgs,\n  defaultParams: [''],\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'reduceSeries',\n  shortName: 'reduce',\n  params: [\n    {\n      name: 'function',\n      type: 'string',\n      options: ['asPercent', 'diffSeries', 'divideSeries'],\n    },\n    {\n      name: 'reduceNode',\n      type: 'int',\n      options: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13],\n    },\n    { name: 'reduceMatchers', type: 'string', multiple: true },\n  ],\n  defaultParams: ['asPercent', 2, 'used_bytes'],\n  category: 'Combine',\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'removeBetweenPercentile',\n  category: 'Filter Series',\n  params: [{ name: 'n', type: 'int' }],\n  defaultParams: [95],\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'removeEmptySeries',\n  category: 'Filter Series',\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'squareRoot',\n  category: 'Transform',\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'timeSlice',\n  category: 'Transform',\n  params: [\n    {\n      name: 'startSliceAt',\n      type: 'select',\n      options: ['-1h', '-6h', '-12h', '-1d', '-2d', '-7d', '-14d', '-30d'],\n    },\n    {\n      name: 'endSliceAt',\n      type: 'select',\n      options: ['-1h', '-6h', '-12h', '-1d', '-2d', '-7d', '-14d', '-30d'],\n      optional: true,\n    },\n  ],\n  defaultParams: ['-1h'],\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'weightedAverage',\n  category: 'Combine',\n  params: [\n    { name: 'other', type: 'value_or_series', optional: true },\n    {\n      name: 'node',\n      type: 'int',\n      options: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12],\n    },\n  ],\n  defaultParams: ['#A', 4],\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'seriesByTag',\n  category: 'Special',\n  params: [{ name: 'tagExpression', type: 'string', multiple: true }],\n  version: '1.1',\n});\n\naddFuncDef({\n  name: 'groupByTags',\n  category: 'Combine',\n  params: [\n    {\n      name: 'function',\n      type: 'string',\n      options: ['sum', 'avg', 'maxSeries'],\n    },\n    { name: 'tag', type: 'string', multiple: true },\n  ],\n  defaultParams: ['sum', 'tag'],\n  version: '1.1',\n});\n\naddFuncDef({\n  name: 'aliasByTags',\n  category: 'Alias',\n  params: [{ name: 'tag', type: 'string', multiple: true }],\n  defaultParams: ['tag'],\n  version: '1.1',\n});\n\nfunction isVersionRelatedFunction(obj: { version?: string }, graphiteVersion: string) {\n  return !obj.version || isVersionGtOrEq(graphiteVersion, obj.version);\n}\n\nexport class FuncInstance {\n  def: FuncDef;\n  params: Array<string | number>;\n  text: any;\n  /**\n   * True if this function was just added and not edited yet. It's used to focus on first\n   * function param to edit it straight away after adding a function.\n   */\n  declare added: boolean;\n  /**\n   * Hidden functions are not displayed in UI but available in text editor\n   * This is used for seriesByTagUsed function which when used switches\n   * the editor to tag-only mode. Defined tags are provided to seriesByTagUsed\n   * as parameters.\n   */\n  hidden?: boolean;\n\n  constructor(funcDef: FuncDef, options?: { withDefaultParams: any }) {\n    this.def = funcDef;\n    this.params = [];\n\n    if (options && options.withDefaultParams && funcDef.defaultParams) {\n      this.params = funcDef.defaultParams.slice(0);\n    }\n\n    this.updateText();\n  }\n\n  render(metricExp: string, replaceVariables: InterpolateFunction): string {\n    const str = this.def.name + '(';\n\n    const parameters = map(this.params, (value, index) => {\n      let paramType;\n\n      if (index < this.def.params.length) {\n        paramType = this.def.params[index].type;\n      } else if (get(last(this.def.params), 'multiple')) {\n        paramType = get(last(this.def.params), 'type');\n      }\n\n      // param types that should never be quoted\n      if (includes(['value_or_series', 'boolean', 'int', 'float', 'node', 'int_or_infinity'], paramType)) {\n        return value;\n      }\n\n      const valueInterpolated = isString(value) ? replaceVariables(value) : value;\n\n      // param types that might be quoted\n      // To quote variables correctly we need to interpolate it to check if it contains a numeric or string value\n      if (includes(['int_or_interval', 'node_or_tag'], paramType) && isFinite(+valueInterpolated)) {\n        return toString(value);\n      }\n\n      return \"'\" + value + \"'\";\n    });\n\n    // don't send any blank parameters to graphite\n    while (parameters[parameters.length - 1] === '') {\n      parameters.pop();\n    }\n\n    if (metricExp) {\n      parameters.unshift(metricExp);\n    }\n\n    return str + parameters.join(', ') + ')';\n  }\n\n  _hasMultipleParamsInString(strValue: any, index: number) {\n    if (strValue.indexOf(',') === -1) {\n      return false;\n    }\n\n    if (this.def.params[index + 1] && this.def.params[index + 1].optional) {\n      return true;\n    }\n\n    if (index + 1 >= this.def.params.length && get(last(this.def.params), 'multiple')) {\n      return true;\n    }\n\n    return false;\n  }\n\n  updateParam(strValue: any, index: any) {\n    // handle optional parameters\n    // if string contains ',' and next param is optional, split and update both\n    if (this._hasMultipleParamsInString(strValue, index)) {\n      each(strValue.split(','), (partVal, idx) => {\n        this.updateParam(partVal.trim(), index + idx);\n      });\n      return;\n    }\n\n    if (strValue === '' && (index >= this.def.params.length || this.def.params[index].optional)) {\n      this.params.splice(index, 1);\n    } else {\n      this.params[index] = strValue;\n    }\n\n    this.updateText();\n  }\n\n  updateText() {\n    if (this.params.length === 0) {\n      this.text = this.def.name + '()';\n      return;\n    }\n\n    let text = this.def.name + '(';\n    text += this.params.join(', ');\n    text += ')';\n    this.text = text;\n  }\n}\n\nfunction createFuncInstance(funcDef: any, options?: { withDefaultParams: any }, idx?: any): FuncInstance {\n  if (isString(funcDef)) {\n    funcDef = getFuncDef(funcDef, idx);\n  }\n  return new FuncInstance(funcDef, options);\n}\n\nfunction getFuncDef(name: string, idx?: any): FuncDef {\n  if (!(idx || index)[name]) {\n    return { name: name, params: [{ name: '', type: '', multiple: true }], defaultParams: [''], unknown: true };\n  }\n  return (idx || index)[name];\n}\n\nfunction getFuncDefs(graphiteVersion: string, idx?: any): FuncDefs {\n  const funcs: FuncDefs = {};\n  forEach(idx || index, (funcDef: FuncDef) => {\n    if (isVersionRelatedFunction(funcDef, graphiteVersion)) {\n      funcs[funcDef.name] = assign({}, funcDef, {\n        params: filter(funcDef.params, (param) => {\n          return isVersionRelatedFunction(param, graphiteVersion);\n        }),\n      });\n    }\n  });\n  return funcs;\n}\n\n// parse response from graphite /functions endpoint into internal format\nfunction parseFuncDefs(rawDefs: any): FuncDefs {\n  const funcDefs: FuncDefs = {};\n\n  forEach(rawDefs || {}, (funcDef, funcName) => {\n    // skip graphite graph functions\n    if (funcDef.group === 'Graph') {\n      return;\n    }\n\n    let description = funcDef.description;\n    if (description) {\n      // tidy up some pydoc syntax that rst2html can't handle\n      description = description\n        .replace(/:py:func:`(.+)( <[^>]*>)?`/g, '``$1``')\n        .replace(/.. seealso:: /g, 'See also: ')\n        .replace(/.. code-block *:: *none/g, '.. code-block::');\n    }\n\n    const func: FuncDef = {\n      name: funcDef.name,\n      description,\n      category: funcDef.group,\n      params: [],\n      defaultParams: [],\n      fake: false,\n    };\n\n    // get rid of the first \"seriesList\" param\n    if (/^seriesLists?$/.test(get(funcDef, 'params[0].type', ''))) {\n      // handle functions that accept multiple seriesLists\n      // we leave the param in place but mark it optional, so users can add more series if they wish\n      if (funcDef.params[0].multiple) {\n        funcDef.params[0].required = false;\n        // otherwise chop off the first param, it'll be handled separately\n      } else {\n        funcDef.params.shift();\n      }\n      // tag function as fake\n    } else {\n      func.fake = true;\n    }\n\n    forEach(funcDef.params, (rawParam) => {\n      const param: any = {\n        name: rawParam.name,\n        type: 'string',\n        optional: !rawParam.required,\n        multiple: !!rawParam.multiple,\n        options: undefined,\n      };\n\n      if (rawParam.default !== undefined) {\n        if (rawParam.default === Infinity) {\n          func.defaultParams.push('inf');\n        } else {\n          func.defaultParams.push(toString(rawParam.default));\n        }\n      } else if (rawParam.suggestions) {\n        func.defaultParams.push(toString(rawParam.suggestions[0]));\n      } else {\n        func.defaultParams.push('');\n      }\n\n      if (rawParam.type === 'boolean') {\n        param.type = 'boolean';\n        param.options = ['true', 'false'];\n      } else if (rawParam.type === 'integer') {\n        param.type = 'int';\n      } else if (rawParam.type === 'float') {\n        param.type = 'float';\n      } else if (rawParam.type === 'node') {\n        param.type = 'node';\n        param.options = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'];\n      } else if (rawParam.type === 'nodeOrTag') {\n        param.type = 'node_or_tag';\n        param.options = ['name', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'];\n      } else if (rawParam.type === 'intOrInterval') {\n        param.type = 'int_or_interval';\n      } else if (rawParam.type === 'seriesList') {\n        param.type = 'value_or_series';\n      } else if (rawParam.type === 'intOrInf') {\n        param.type = 'int_or_infinity';\n      }\n\n      if (rawParam.options) {\n        param.options = map(rawParam.options, toString);\n      } else if (rawParam.suggestions) {\n        param.options = map(rawParam.suggestions, toString);\n      }\n\n      func.params.push(param);\n    });\n\n    funcDefs[funcName] = func;\n  });\n\n  return funcDefs;\n}\n\nexport default {\n  createFuncInstance: createFuncInstance,\n  getFuncDef: getFuncDef,\n  getFuncDefs: getFuncDefs,\n  parseFuncDefs: parseFuncDefs,\n};\n","import { DataQuery, DataSourceJsonData } from '@grafana/data';\nimport { GraphiteDatasource } from './datasource';\nimport { TemplateSrv } from '../../../features/templating/template_srv';\n\nexport interface GraphiteQuery extends DataQuery {\n  target?: string;\n}\n\nexport interface GraphiteOptions extends DataSourceJsonData {\n  graphiteVersion: string;\n  graphiteType: GraphiteType;\n  rollupIndicatorEnabled?: boolean;\n  importConfiguration: GraphiteQueryImportConfiguration;\n}\n\nexport enum GraphiteType {\n  Default = 'default',\n  Metrictank = 'metrictank',\n}\n\nexport interface MetricTankRequestMeta {\n  [key: string]: any;\n}\n\nexport interface MetricTankSeriesMeta {\n  'schema-name': string;\n  'schema-retentions': string; //\"1s:35d:20min:5:1542274085,1min:38d:2h:1:true,10min:120d:6h:1:true,2h:2y:6h:2\",\n  'archive-read': number;\n  'archive-interval': number;\n  'aggnum-norm': number;\n  'consolidator-normfetch': string; //\"MaximumConsolidator\",\n  'aggnum-rc': number;\n  'consolidator-rc': string; //\"MaximumConsolidator\",\n  count: number;\n}\n\nexport interface MetricTankMeta {\n  request: MetricTankRequestMeta;\n  info: MetricTankSeriesMeta[];\n}\n\nexport type GraphiteQueryImportConfiguration = {\n  loki: GraphiteToLokiQueryImportConfiguration;\n};\n\nexport type GraphiteToLokiQueryImportConfiguration = {\n  mappings: GraphiteLokiMapping[];\n};\n\nexport type GraphiteLokiMapping = {\n  matchers: GraphiteMetricLokiMatcher[];\n};\n\nexport type GraphiteMetricLokiMatcher = {\n  value: string;\n  labelName?: string;\n};\n\nexport type GraphiteSegment = {\n  value: string;\n  type?: 'tag' | 'metric' | 'series-ref';\n  expandable?: boolean;\n  focus?: boolean;\n  fake?: boolean;\n};\n\nexport type GraphiteTagOperator = '=' | '!=' | '=~' | '!=~';\n\nexport type GraphiteTag = {\n  key: string;\n  operator: GraphiteTagOperator;\n  value: string;\n};\n\nexport type GraphiteActionDispatcher = (action: any) => Promise<void>;\n\nexport type GraphiteQueryEditorAngularDependencies = {\n  panelCtrl: any;\n  target: any;\n  datasource: GraphiteDatasource;\n  uiSegmentSrv: any;\n  templateSrv: TemplateSrv;\n};\n\nexport type AngularDropdownOptions = {\n  text: string;\n  value: string;\n};\n","import { MetricTankSeriesMeta } from './types';\nimport { QueryResultMetaNotice } from '@grafana/data';\n\n// https://github.com/grafana/metrictank/blob/master/scripts/config/storage-schemas.conf#L15-L46\n\nexport interface RetentionInfo {\n  interval: string;\n  retention?: string;\n  chunkspan?: string;\n  numchunks?: number;\n  ready?: boolean | number; // whether, or as of what data timestamp, the archive is ready for querying.\n}\n\nfunction toInteger(val?: string): number | undefined {\n  if (val) {\n    return parseInt(val, 10);\n  }\n  return undefined;\n}\n\nfunction toBooleanOrTimestamp(val?: string): number | boolean | undefined {\n  if (val) {\n    if (val === 'true') {\n      return true;\n    }\n    if (val === 'false') {\n      return false;\n    }\n    return parseInt(val, 10);\n  }\n  return undefined;\n}\n\nexport function getRollupNotice(metaList: MetricTankSeriesMeta[]): QueryResultMetaNotice | null {\n  for (const meta of metaList) {\n    const archiveIndex = meta['archive-read'];\n\n    if (archiveIndex > 0) {\n      const schema = parseSchemaRetentions(meta['schema-retentions']);\n      const intervalString = schema[archiveIndex].interval;\n      const func = (meta['consolidator-normfetch'] ?? '').replace('Consolidator', '');\n\n      return {\n        text: `Data is rolled up, aggregated over ${intervalString} using ${func} function`,\n        severity: 'info',\n        inspect: 'meta',\n      };\n    }\n  }\n\n  return null;\n}\n\nexport function getRuntimeConsolidationNotice(metaList: MetricTankSeriesMeta[]): QueryResultMetaNotice | null {\n  for (const meta of metaList) {\n    const runtimeNr = meta['aggnum-rc'];\n\n    if (runtimeNr > 0) {\n      const func = (meta['consolidator-rc'] ?? '').replace('Consolidator', '');\n\n      return {\n        text: `Data is runtime consolidated, ${runtimeNr} datapoints combined using ${func} function`,\n        severity: 'info',\n        inspect: 'meta',\n      };\n    }\n  }\n\n  return null;\n}\n\nexport function parseSchemaRetentions(spec: string): RetentionInfo[] {\n  if (!spec) {\n    return [];\n  }\n  return spec.split(',').map((str) => {\n    const vals = str.split(':');\n    return {\n      interval: vals[0],\n      retention: vals[1],\n      chunkspan: vals[2],\n      numchunks: toInteger(vals[3]),\n      ready: toBooleanOrTimestamp(vals[4]),\n    };\n  });\n}\n","import { last } from 'lodash';\n\nexport const GRAPHITE_VERSIONS = ['0.9', '1.0', '1.1'];\n\nexport const DEFAULT_GRAPHITE_VERSION = last(GRAPHITE_VERSIONS)!;\n","import { each, indexOf, isArray, isString, map as _map } from 'lodash';\nimport {\n  DataFrame,\n  DataQueryRequest,\n  DataQueryResponse,\n  DataSourceApi,\n  dateMath,\n  MetricFindValue,\n  QueryResultMetaStat,\n  ScopedVars,\n  TimeRange,\n  toDataFrame,\n} from '@grafana/data';\nimport { isVersionGtOrEq, SemVersion } from 'app/core/utils/version';\nimport gfunc, { FuncDefs, FuncInstance } from './gfunc';\nimport { getBackendSrv } from '@grafana/runtime';\nimport { getTemplateSrv, TemplateSrv } from 'app/features/templating/template_srv';\n// Types\nimport {\n  GraphiteLokiMapping,\n  GraphiteOptions,\n  GraphiteQuery,\n  GraphiteQueryImportConfiguration,\n  GraphiteType,\n  MetricTankRequestMeta,\n} from './types';\nimport { getRollupNotice, getRuntimeConsolidationNotice } from 'app/plugins/datasource/graphite/meta';\nimport { getSearchFilterScopedVar } from '../../../features/variables/utils';\nimport { Observable, of, OperatorFunction, pipe, throwError } from 'rxjs';\nimport { catchError, map } from 'rxjs/operators';\nimport { DEFAULT_GRAPHITE_VERSION } from './versions';\nimport { reduceError } from './utils';\n\nexport class GraphiteDatasource extends DataSourceApi<\n  GraphiteQuery,\n  GraphiteOptions,\n  GraphiteQueryImportConfiguration\n> {\n  basicAuth: string;\n  url: string;\n  name: string;\n  graphiteVersion: any;\n  supportsTags: boolean;\n  isMetricTank: boolean;\n  rollupIndicatorEnabled: boolean;\n  cacheTimeout: any;\n  withCredentials: boolean;\n  funcDefs: FuncDefs | null = null;\n  funcDefsPromise: Promise<any> | null = null;\n  _seriesRefLetters: string;\n  private readonly metricMappings: GraphiteLokiMapping[];\n\n  constructor(instanceSettings: any, private readonly templateSrv: TemplateSrv = getTemplateSrv()) {\n    super(instanceSettings);\n    this.basicAuth = instanceSettings.basicAuth;\n    this.url = instanceSettings.url;\n    this.name = instanceSettings.name;\n    // graphiteVersion is set when a datasource is created but it hadn't been set in the past so we're\n    // still falling back to the default behavior here for backwards compatibility (see also #17429)\n    this.graphiteVersion = instanceSettings.jsonData.graphiteVersion || DEFAULT_GRAPHITE_VERSION;\n    this.metricMappings = instanceSettings.jsonData.importConfiguration?.loki?.mappings || [];\n    this.isMetricTank = instanceSettings.jsonData.graphiteType === GraphiteType.Metrictank;\n    this.supportsTags = supportsTags(this.graphiteVersion);\n    this.cacheTimeout = instanceSettings.cacheTimeout;\n    this.rollupIndicatorEnabled = instanceSettings.jsonData.rollupIndicatorEnabled;\n    this.withCredentials = instanceSettings.withCredentials;\n    this.funcDefs = null;\n    this.funcDefsPromise = null;\n    this._seriesRefLetters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  }\n\n  getQueryOptionsInfo() {\n    return {\n      maxDataPoints: true,\n      cacheTimeout: true,\n      links: [\n        {\n          text: 'Help',\n          url: 'http://docs.grafana.org/features/datasources/graphite/#using-graphite-in-grafana',\n        },\n      ],\n    };\n  }\n\n  getImportQueryConfiguration(): GraphiteQueryImportConfiguration {\n    return {\n      loki: {\n        mappings: this.metricMappings,\n      },\n    };\n  }\n\n  query(options: DataQueryRequest<GraphiteQuery>): Observable<DataQueryResponse> {\n    const graphOptions = {\n      from: this.translateTime(options.range.raw.from, false, options.timezone),\n      until: this.translateTime(options.range.raw.to, true, options.timezone),\n      targets: options.targets,\n      format: (options as any).format,\n      cacheTimeout: options.cacheTimeout || this.cacheTimeout,\n      maxDataPoints: options.maxDataPoints,\n    };\n\n    const params = this.buildGraphiteParams(graphOptions, options.scopedVars);\n    if (params.length === 0) {\n      return of({ data: [] });\n    }\n\n    if (this.isMetricTank) {\n      params.push('meta=true');\n    }\n\n    const httpOptions: any = {\n      method: 'POST',\n      url: '/render',\n      data: params.join('&'),\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n      },\n    };\n\n    this.addTracingHeaders(httpOptions, options);\n\n    if (options.panelId) {\n      httpOptions.requestId = this.name + '.panelId.' + options.panelId;\n    }\n\n    return this.doGraphiteRequest(httpOptions).pipe(map(this.convertResponseToDataFrames));\n  }\n\n  addTracingHeaders(httpOptions: { headers: any }, options: { dashboardId?: number; panelId?: number }) {\n    const proxyMode = !this.url.match(/^http/);\n    if (proxyMode) {\n      if (options.dashboardId) {\n        httpOptions.headers['X-Dashboard-Id'] = options.dashboardId;\n      }\n      if (options.panelId) {\n        httpOptions.headers['X-Panel-Id'] = options.panelId;\n      }\n    }\n  }\n\n  convertResponseToDataFrames = (result: any): DataQueryResponse => {\n    const data: DataFrame[] = [];\n    if (!result || !result.data) {\n      return { data };\n    }\n\n    // Series are either at the root or under a node called 'series'\n    const series = result.data.series || result.data;\n\n    if (!isArray(series)) {\n      throw { message: 'Missing series in result', data: result };\n    }\n\n    for (let i = 0; i < series.length; i++) {\n      const s = series[i];\n\n      // Disables Grafana own series naming\n      s.title = s.target;\n\n      for (let y = 0; y < s.datapoints.length; y++) {\n        s.datapoints[y][1] *= 1000;\n      }\n\n      const frame = toDataFrame(s);\n\n      // Metrictank metadata\n      if (s.meta) {\n        frame.meta = {\n          custom: {\n            requestMetaList: result.data.meta, // info for the whole request\n            seriesMetaList: s.meta, // Array of metadata\n          },\n        };\n\n        if (this.rollupIndicatorEnabled) {\n          const rollupNotice = getRollupNotice(s.meta);\n          const runtimeNotice = getRuntimeConsolidationNotice(s.meta);\n\n          if (rollupNotice) {\n            frame.meta.notices = [rollupNotice];\n          } else if (runtimeNotice) {\n            frame.meta.notices = [runtimeNotice];\n          }\n        }\n\n        // only add the request stats to the first frame\n        if (i === 0 && result.data.meta.stats) {\n          frame.meta.stats = this.getRequestStats(result.data.meta);\n        }\n      }\n\n      data.push(frame);\n    }\n\n    return { data };\n  };\n\n  getRequestStats(meta: MetricTankRequestMeta): QueryResultMetaStat[] {\n    const stats: QueryResultMetaStat[] = [];\n\n    for (const key in meta.stats) {\n      let unit: string | undefined = undefined;\n\n      if (key.endsWith('.ms')) {\n        unit = 'ms';\n      }\n\n      stats.push({ displayName: key, value: meta.stats[key], unit });\n    }\n\n    return stats;\n  }\n\n  parseTags(tagString: string) {\n    let tags: string[] = [];\n    tags = tagString.split(',');\n    if (tags.length === 1) {\n      tags = tagString.split(' ');\n      if (tags[0] === '') {\n        tags = [];\n      }\n    }\n    return tags;\n  }\n\n  interpolateVariablesInQueries(queries: GraphiteQuery[], scopedVars: ScopedVars): GraphiteQuery[] {\n    let expandedQueries = queries;\n    if (queries && queries.length > 0) {\n      expandedQueries = queries.map((query) => {\n        const expandedQuery = {\n          ...query,\n          datasource: this.name,\n          target: this.templateSrv.replace(query.target ?? '', scopedVars),\n        };\n        return expandedQuery;\n      });\n    }\n    return expandedQueries;\n  }\n\n  annotationQuery(options: any) {\n    // Graphite metric as annotation\n    if (options.annotation.target) {\n      const target = this.templateSrv.replace(options.annotation.target, {}, 'glob');\n      const graphiteQuery = ({\n        range: options.range,\n        targets: [{ target: target }],\n        format: 'json',\n        maxDataPoints: 100,\n      } as unknown) as DataQueryRequest<GraphiteQuery>;\n\n      return this.query(graphiteQuery)\n        .pipe(\n          map((result: any) => {\n            const list = [];\n\n            for (let i = 0; i < result.data.length; i++) {\n              const target = result.data[i];\n\n              for (let y = 0; y < target.length; y++) {\n                const time = target.fields[0].values.get(y);\n                const value = target.fields[1].values.get(y);\n\n                if (!value) {\n                  continue;\n                }\n\n                list.push({\n                  annotation: options.annotation,\n                  time,\n                  title: target.name,\n                });\n              }\n            }\n\n            return list;\n          })\n        )\n        .toPromise();\n    } else {\n      // Graphite event as annotation\n      const tags = this.templateSrv.replace(options.annotation.tags);\n      return this.events({ range: options.range, tags: tags }).then((results: any) => {\n        const list = [];\n        if (!isArray(results.data)) {\n          console.error(`Unable to get annotations from ${results.url}.`);\n          return [];\n        }\n        for (let i = 0; i < results.data.length; i++) {\n          const e = results.data[i];\n\n          let tags = e.tags;\n          if (isString(e.tags)) {\n            tags = this.parseTags(e.tags);\n          }\n\n          list.push({\n            annotation: options.annotation,\n            time: e.when * 1000,\n            title: e.what,\n            tags: tags,\n            text: e.data,\n          });\n        }\n\n        return list;\n      });\n    }\n  }\n\n  events(options: { range: TimeRange; tags: any; timezone?: any }) {\n    try {\n      let tags = '';\n      if (options.tags) {\n        tags = '&tags=' + options.tags;\n      }\n      return this.doGraphiteRequest({\n        method: 'GET',\n        url:\n          '/events/get_data?from=' +\n          this.translateTime(options.range.raw.from, false, options.timezone) +\n          '&until=' +\n          this.translateTime(options.range.raw.to, true, options.timezone) +\n          tags,\n      }).toPromise();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n\n  targetContainsTemplate(target: GraphiteQuery) {\n    return this.templateSrv.variableExists(target.target ?? '');\n  }\n\n  translateTime(date: any, roundUp: any, timezone: any) {\n    if (isString(date)) {\n      if (date === 'now') {\n        return 'now';\n      } else if (date.indexOf('now-') >= 0 && date.indexOf('/') === -1) {\n        date = date.substring(3);\n        date = date.replace('m', 'min');\n        date = date.replace('M', 'mon');\n        return date;\n      }\n      date = dateMath.parse(date, roundUp, timezone);\n    }\n\n    // graphite' s from filter is exclusive\n    // here we step back one minute in order\n    // to guarantee that we get all the data that\n    // exists for the specified range\n    if (roundUp) {\n      if (date.get('s')) {\n        date.add(1, 's');\n      }\n    } else if (roundUp === false) {\n      if (date.get('s')) {\n        date.subtract(1, 's');\n      }\n    }\n\n    return date.unix();\n  }\n\n  metricFindQuery(query: string, optionalOptions?: any): Promise<MetricFindValue[]> {\n    const options: any = optionalOptions || {};\n\n    // First attempt to check for tag-related functions (using empty wildcard for interpolation)\n    let interpolatedQuery = this.templateSrv.replace(\n      query,\n      getSearchFilterScopedVar({ query, wildcardChar: '', options: optionalOptions })\n    );\n\n    // special handling for tag_values(<tag>[,<expression>]*), this is used for template variables\n    let allParams = interpolatedQuery.match(/^tag_values\\((.*)\\)$/);\n    let expressions = allParams ? allParams[1].split(',').filter((p) => !!p) : undefined;\n    if (expressions) {\n      options.limit = 10000;\n      return this.getTagValuesAutoComplete(expressions.slice(1), expressions[0], undefined, options);\n    }\n\n    // special handling for tags(<expression>[,<expression>]*), this is used for template variables\n    allParams = interpolatedQuery.match(/^tags\\((.*)\\)$/);\n    expressions = allParams ? allParams[1].split(',').filter((p) => !!p) : undefined;\n    if (expressions) {\n      options.limit = 10000;\n      return this.getTagsAutoComplete(expressions, undefined, options);\n    }\n\n    // If no tag-related query was found, perform metric-based search (using * as the wildcard for interpolation)\n    let useExpand = query.match(/^expand\\((.*)\\)$/);\n    query = useExpand ? useExpand[1] : query;\n\n    interpolatedQuery = this.templateSrv.replace(\n      query,\n      getSearchFilterScopedVar({ query, wildcardChar: '*', options: optionalOptions })\n    );\n\n    let range;\n    if (options.range) {\n      range = {\n        from: this.translateTime(options.range.from, false, options.timezone),\n        until: this.translateTime(options.range.to, true, options.timezone),\n      };\n    }\n\n    if (useExpand) {\n      return this.requestMetricExpand(interpolatedQuery, options.requestId, range);\n    } else {\n      return this.requestMetricFind(interpolatedQuery, options.requestId, range);\n    }\n  }\n\n  /**\n   * Search for metrics matching giving pattern using /metrics/find endpoint. It will\n   * return all possible values at the last level of the query, for example:\n   *\n   * metrics: prod.servers.001.cpu, prod.servers.002.cpu\n   * query: *.servers.*\n   * result: 001, 002\n   *\n   * For more complex searches use requestMetricExpand\n   */\n  private requestMetricFind(\n    query: string,\n    requestId: string,\n    range?: { from: any; until: any }\n  ): Promise<MetricFindValue[]> {\n    const httpOptions: any = {\n      method: 'POST',\n      url: '/metrics/find',\n      params: {},\n      data: `query=${query}`,\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n      },\n      // for cancellations\n      requestId: requestId,\n    };\n\n    if (range) {\n      httpOptions.params.from = range.from;\n      httpOptions.params.until = range.until;\n    }\n\n    return this.doGraphiteRequest(httpOptions)\n      .pipe(\n        map((results: any) => {\n          return _map(results.data, (metric) => {\n            return {\n              text: metric.text,\n              expandable: metric.expandable ? true : false,\n            };\n          });\n        })\n      )\n      .toPromise();\n  }\n\n  /**\n   * Search for metrics matching giving pattern using /metrics/expand endpoint.\n   * The result will contain all metrics (with full name) matching provided query.\n   * It's a more flexible version of /metrics/find endpoint (@see requestMetricFind)\n   */\n  private requestMetricExpand(\n    query: string,\n    requestId: string,\n    range?: { from: any; until: any }\n  ): Promise<MetricFindValue[]> {\n    const httpOptions: any = {\n      method: 'GET',\n      url: '/metrics/expand',\n      params: { query },\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n      },\n      // for cancellations\n      requestId,\n    };\n\n    if (range) {\n      httpOptions.params.from = range.from;\n      httpOptions.params.until = range.until;\n    }\n\n    return this.doGraphiteRequest(httpOptions)\n      .pipe(\n        map((results: any) => {\n          return _map(results.data.results, (metric) => {\n            return {\n              text: metric,\n              expandable: false,\n            };\n          });\n        })\n      )\n      .toPromise();\n  }\n\n  getTags(optionalOptions: any) {\n    const options = optionalOptions || {};\n\n    const httpOptions: any = {\n      method: 'GET',\n      url: '/tags',\n      // for cancellations\n      requestId: options.requestId,\n    };\n\n    if (options.range) {\n      httpOptions.params.from = this.translateTime(options.range.from, false, options.timezone);\n      httpOptions.params.until = this.translateTime(options.range.to, true, options.timezone);\n    }\n\n    return this.doGraphiteRequest(httpOptions)\n      .pipe(\n        map((results: any) => {\n          return _map(results.data, (tag) => {\n            return {\n              text: tag.tag,\n              id: tag.id,\n            };\n          });\n        })\n      )\n      .toPromise();\n  }\n\n  getTagValues(options: any = {}) {\n    const httpOptions: any = {\n      method: 'GET',\n      url: '/tags/' + this.templateSrv.replace(options.key),\n      // for cancellations\n      requestId: options.requestId,\n    };\n\n    if (options.range) {\n      httpOptions.params.from = this.translateTime(options.range.from, false, options.timezone);\n      httpOptions.params.until = this.translateTime(options.range.to, true, options.timezone);\n    }\n\n    return this.doGraphiteRequest(httpOptions)\n      .pipe(\n        map((results: any) => {\n          if (results.data && results.data.values) {\n            return _map(results.data.values, (value) => {\n              return {\n                text: value.value,\n                id: value.id,\n              };\n            });\n          } else {\n            return [];\n          }\n        })\n      )\n      .toPromise();\n  }\n\n  getTagsAutoComplete(expressions: any[], tagPrefix: any, optionalOptions?: any) {\n    const options = optionalOptions || {};\n\n    const httpOptions: any = {\n      method: 'GET',\n      url: '/tags/autoComplete/tags',\n      params: {\n        expr: _map(expressions, (expression) => this.templateSrv.replace((expression || '').trim())),\n      },\n      // for cancellations\n      requestId: options.requestId,\n    };\n\n    if (tagPrefix) {\n      httpOptions.params.tagPrefix = tagPrefix;\n    }\n    if (options.limit) {\n      httpOptions.params.limit = options.limit;\n    }\n    if (options.range) {\n      httpOptions.params.from = this.translateTime(options.range.from, false, options.timezone);\n      httpOptions.params.until = this.translateTime(options.range.to, true, options.timezone);\n    }\n    return this.doGraphiteRequest(httpOptions).pipe(mapToTags()).toPromise();\n  }\n\n  getTagValuesAutoComplete(expressions: any[], tag: any, valuePrefix: any, optionalOptions: any) {\n    const options = optionalOptions || {};\n\n    const httpOptions: any = {\n      method: 'GET',\n      url: '/tags/autoComplete/values',\n      params: {\n        expr: _map(expressions, (expression) => this.templateSrv.replace((expression || '').trim())),\n        tag: this.templateSrv.replace((tag || '').trim()),\n      },\n      // for cancellations\n      requestId: options.requestId,\n    };\n\n    if (valuePrefix) {\n      httpOptions.params.valuePrefix = valuePrefix;\n    }\n    if (options.limit) {\n      httpOptions.params.limit = options.limit;\n    }\n    if (options.range) {\n      httpOptions.params.from = this.translateTime(options.range.from, false, options.timezone);\n      httpOptions.params.until = this.translateTime(options.range.to, true, options.timezone);\n    }\n    return this.doGraphiteRequest(httpOptions).pipe(mapToTags()).toPromise();\n  }\n\n  getVersion(optionalOptions: any) {\n    const options = optionalOptions || {};\n\n    const httpOptions = {\n      method: 'GET',\n      url: '/version',\n      requestId: options.requestId,\n    };\n\n    return this.doGraphiteRequest(httpOptions)\n      .pipe(\n        map((results: any) => {\n          if (results.data) {\n            const semver = new SemVersion(results.data);\n            return semver.isValid() ? results.data : '';\n          }\n          return '';\n        }),\n        catchError(() => {\n          return of('');\n        })\n      )\n      .toPromise();\n  }\n\n  createFuncInstance(funcDef: any, options?: any): FuncInstance {\n    return gfunc.createFuncInstance(funcDef, options, this.funcDefs);\n  }\n\n  getFuncDef(name: string) {\n    return gfunc.getFuncDef(name, this.funcDefs);\n  }\n\n  waitForFuncDefsLoaded() {\n    return this.getFuncDefs();\n  }\n\n  getFuncDefs() {\n    if (this.funcDefsPromise !== null) {\n      return this.funcDefsPromise;\n    }\n\n    if (!supportsFunctionIndex(this.graphiteVersion)) {\n      this.funcDefs = gfunc.getFuncDefs(this.graphiteVersion);\n      this.funcDefsPromise = Promise.resolve(this.funcDefs);\n      return this.funcDefsPromise;\n    }\n\n    const httpOptions = {\n      method: 'GET',\n      url: '/functions',\n    };\n\n    return this.doGraphiteRequest(httpOptions)\n      .pipe(\n        map((results: any) => {\n          if (results.status !== 200 || typeof results.data !== 'object') {\n            if (typeof results.data === 'string') {\n              // Fix for a Graphite bug: https://github.com/graphite-project/graphite-web/issues/2609\n              // There is a fix for it https://github.com/graphite-project/graphite-web/pull/2612 but\n              // it was merged to master in July 2020 but it has never been released (the last Graphite\n              // release was 1.1.7 - March 2020). The bug was introduced in Graphite 1.1.7, in versions\n              // 1.1.0 - 1.1.6 /functions endpoint returns a valid JSON\n              const fixedData = JSON.parse(results.data.replace(/\"default\": ?Infinity/g, '\"default\": 1e9999'));\n              this.funcDefs = gfunc.parseFuncDefs(fixedData);\n            } else {\n              this.funcDefs = gfunc.getFuncDefs(this.graphiteVersion);\n            }\n          } else {\n            this.funcDefs = gfunc.parseFuncDefs(results.data);\n          }\n          return this.funcDefs;\n        }),\n        catchError((error: any) => {\n          console.error('Fetching graphite functions error', error);\n          this.funcDefs = gfunc.getFuncDefs(this.graphiteVersion);\n          return of(this.funcDefs);\n        })\n      )\n      .toPromise();\n  }\n\n  testDatasource() {\n    const query = ({\n      panelId: 3,\n      rangeRaw: { from: 'now-1h', to: 'now' },\n      range: {\n        raw: { from: 'now-1h', to: 'now' },\n      },\n      targets: [{ target: 'constantLine(100)' }],\n      maxDataPoints: 300,\n    } as unknown) as DataQueryRequest<GraphiteQuery>;\n\n    return this.query(query)\n      .toPromise()\n      .then(() => ({ status: 'success', message: 'Data source is working' }));\n  }\n\n  doGraphiteRequest(options: {\n    method?: string;\n    url: any;\n    requestId?: any;\n    withCredentials?: any;\n    headers?: any;\n    inspect?: any;\n  }) {\n    if (this.basicAuth || this.withCredentials) {\n      options.withCredentials = true;\n    }\n    if (this.basicAuth) {\n      options.headers = options.headers || {};\n      options.headers.Authorization = this.basicAuth;\n    }\n\n    options.url = this.url + options.url;\n    options.inspect = { type: 'graphite' };\n\n    return getBackendSrv()\n      .fetch(options)\n      .pipe(\n        catchError((err: any) => {\n          return throwError(reduceError(err));\n        })\n      );\n  }\n\n  buildGraphiteParams(options: any, scopedVars?: ScopedVars): string[] {\n    const graphiteOptions = ['from', 'until', 'rawData', 'format', 'maxDataPoints', 'cacheTimeout'];\n    const cleanOptions = [],\n      targets: any = {};\n    let target, targetValue, i;\n    const regex = /\\#([A-Z])/g;\n    const intervalFormatFixRegex = /'(\\d+)m'/gi;\n    let hasTargets = false;\n\n    options['format'] = 'json';\n\n    function fixIntervalFormat(match: any) {\n      return match.replace('m', 'min').replace('M', 'mon');\n    }\n\n    for (i = 0; i < options.targets.length; i++) {\n      target = options.targets[i];\n      if (!target.target) {\n        continue;\n      }\n\n      if (!target.refId) {\n        target.refId = this._seriesRefLetters[i];\n      }\n\n      targetValue = this.templateSrv.replace(target.target, scopedVars);\n      targetValue = targetValue.replace(intervalFormatFixRegex, fixIntervalFormat);\n      targets[target.refId] = targetValue;\n    }\n\n    function nestedSeriesRegexReplacer(match: any, g1: string | number) {\n      return targets[g1] || match;\n    }\n\n    for (i = 0; i < options.targets.length; i++) {\n      target = options.targets[i];\n      if (!target.target) {\n        continue;\n      }\n\n      targetValue = targets[target.refId];\n      targetValue = targetValue.replace(regex, nestedSeriesRegexReplacer);\n      targets[target.refId] = targetValue;\n\n      if (!target.hide) {\n        hasTargets = true;\n        cleanOptions.push('target=' + encodeURIComponent(targetValue));\n      }\n    }\n\n    each(options, (value, key) => {\n      if (indexOf(graphiteOptions, key) === -1) {\n        return;\n      }\n      if (value) {\n        cleanOptions.push(key + '=' + encodeURIComponent(value));\n      }\n    });\n\n    if (!hasTargets) {\n      return [];\n    }\n\n    return cleanOptions;\n  }\n}\n\nfunction supportsTags(version: string): boolean {\n  return isVersionGtOrEq(version, '1.1');\n}\n\nfunction supportsFunctionIndex(version: string): boolean {\n  return isVersionGtOrEq(version, '1.1');\n}\n\nfunction mapToTags(): OperatorFunction<any, Array<{ text: string }>> {\n  return pipe(\n    map((results: any) => {\n      if (results.data) {\n        return _map(results.data, (value) => {\n          return { text: value };\n        });\n      } else {\n        return [];\n      }\n    })\n  );\n}\n","import { last } from 'lodash';\n\n/**\n * Graphite-web before v1.6 returns HTTP 500 with full stack traces in an HTML page\n * when a query fails. It results in massive error alerts with HTML tags in the UI.\n * This function removes all HTML tags and keeps only the last line from the stack\n * trace which should be the most meaningful.\n */\nexport function reduceError(error: any): any {\n  if (error && error.status === 500 && error.data?.message?.startsWith('<body')) {\n    // Remove all HTML tags and take the last line from the stack trace\n    const newMessage = last<string>(\n      error.data.message\n        .replace(/(<([^>]+)>)/gi, '')\n        .trim()\n        .split(/\\n/)\n    )!.replace(/u?&#[^;]+;/g, '');\n    error.data.message = `Graphite encountered an unexpected error while handling your request. ${newMessage}`;\n  }\n  return error;\n}\n","import { GraphiteQueryEditorState } from './store';\nimport { each, map } from 'lodash';\nimport { dispatch } from '../../../../store/store';\nimport { notifyApp } from '../../../../core/reducers/appNotification';\nimport { createErrorNotification } from '../../../../core/copy/appNotification';\nimport { FuncInstance } from '../gfunc';\n\n/**\n * Helpers used by reducers and providers. They modify state object directly so should operate on a copy of the state.\n */\n\nexport const GRAPHITE_TAG_OPERATORS = ['=', '!=', '=~', '!=~'];\n\n/**\n * Tag names and metric names are displayed in a single dropdown. This prefix is used to\n * distinguish both in the UI.\n */\nexport const TAG_PREFIX = 'tag: ';\n\n/**\n * Create new AST based on new query.\n * Build segments from parsed metric name and functions.\n */\nexport async function parseTarget(state: GraphiteQueryEditorState): Promise<void> {\n  state.queryModel.parseTarget();\n  await buildSegments(state);\n}\n\n/**\n * Create segments out of the current metric path + add \"select metrics\" if it's possible to add more to the path\n */\nexport async function buildSegments(state: GraphiteQueryEditorState, modifyLastSegment = true): Promise<void> {\n  state.segments = map(state.queryModel.segments, (segment) => {\n    return state.uiSegmentSrv.newSegment(segment);\n  });\n\n  const checkOtherSegmentsIndex = state.queryModel.checkOtherSegmentsIndex || 0;\n\n  await checkOtherSegments(state, checkOtherSegmentsIndex, modifyLastSegment);\n\n  if (state.queryModel.seriesByTagUsed) {\n    fixTagSegments(state);\n  }\n}\n\n/**\n * Add \"select metric\" segment at the end\n */\nexport function addSelectMetricSegment(state: GraphiteQueryEditorState): void {\n  state.queryModel.addSelectMetricSegment();\n  state.segments.push(state.uiSegmentSrv.newSelectMetric());\n}\n\n/**\n * Validates the state after adding or changing a segment:\n * - adds \"select metric\" only when more segments can be added to the metric name\n * - check if subsequent segments are still valid if in-between segment changes and\n *   removes invalid segments.\n */\nexport async function checkOtherSegments(\n  state: GraphiteQueryEditorState,\n  fromIndex: number,\n  modifyLastSegment = true\n): Promise<void> {\n  if (state.queryModel.segments.length === 1 && state.queryModel.segments[0].type === 'series-ref') {\n    return;\n  }\n\n  if (fromIndex === 0) {\n    addSelectMetricSegment(state);\n    return;\n  }\n\n  const path = state.queryModel.getSegmentPathUpTo(fromIndex + 1);\n  if (path === '') {\n    return;\n  }\n\n  try {\n    const segments = await state.datasource.metricFindQuery(path);\n    if (segments.length === 0) {\n      if (path !== '' && modifyLastSegment) {\n        state.queryModel.segments = state.queryModel.segments.splice(0, fromIndex);\n        state.segments = state.segments.splice(0, fromIndex);\n        addSelectMetricSegment(state);\n      }\n    } else if (segments[0].expandable) {\n      if (state.segments.length === fromIndex) {\n        addSelectMetricSegment(state);\n      } else {\n        await checkOtherSegments(state, fromIndex + 1);\n      }\n    }\n  } catch (err) {\n    handleMetricsAutoCompleteError(state, err);\n  }\n}\n\n/**\n * Changes segment being in focus. After changing the value, next segment gets focus.\n *\n * Note: It's a bit hidden feature. After selecting one metric, and pressing down arrow the dropdown can be expanded.\n * But there's nothing indicating what's in focus and how to expand the dropdown.\n */\nexport function setSegmentFocus(state: GraphiteQueryEditorState, segmentIndex: number): void {\n  each(state.segments, (segment, index) => {\n    segment.focus = segmentIndex === index;\n  });\n}\n\nexport function spliceSegments(state: GraphiteQueryEditorState, index: number): void {\n  state.segments = state.segments.splice(0, index);\n  state.queryModel.segments = state.queryModel.segments.splice(0, index);\n}\n\nexport function emptySegments(state: GraphiteQueryEditorState): void {\n  state.queryModel.segments = [];\n  state.segments = [];\n}\n\n/**\n * When seriesByTag function is added the UI changes it's state and only tags can be added from now.\n */\nexport async function addSeriesByTagFunc(state: GraphiteQueryEditorState, tag: string): Promise<void> {\n  const newFunc = state.datasource.createFuncInstance('seriesByTag', {\n    withDefaultParams: false,\n  });\n  const tagParam = `${tag}=`;\n  newFunc.params = [tagParam];\n  state.queryModel.addFunction(newFunc);\n  newFunc.added = true;\n\n  emptySegments(state);\n  handleTargetChanged(state);\n  await parseTarget(state);\n}\n\nexport function smartlyHandleNewAliasByNode(state: GraphiteQueryEditorState, func: FuncInstance): void {\n  if (func.def.name !== 'aliasByNode') {\n    return;\n  }\n\n  for (let i = 0; i < state.segments.length; i++) {\n    if (state.segments[i].value.indexOf('*') >= 0) {\n      func.params[0] = i;\n      func.added = false;\n      handleTargetChanged(state);\n      return;\n    }\n  }\n}\n\n/**\n * Add \"+\" button for adding tags once at least one tag is selected\n */\nexport function fixTagSegments(state: GraphiteQueryEditorState): void {\n  // Adding tag with the same name as just removed works incorrectly if single segment is used (instead of array)\n  state.addTagSegments = [state.uiSegmentSrv.newPlusButton()];\n}\n\n/**\n * Pauses running the query to allow selecting tag value. This is to prevent getting errors if the query is run\n * for a tag with no selected value.\n */\nexport function pause(state: GraphiteQueryEditorState): void {\n  state.paused = true;\n}\n\nexport function removeTagPrefix(value: string): string {\n  return value.replace(TAG_PREFIX, '');\n}\n\nexport function handleTargetChanged(state: GraphiteQueryEditorState): void {\n  if (state.queryModel.error) {\n    return;\n  }\n\n  const oldTarget = state.queryModel.target.target;\n  state.queryModel.updateModelTarget(state.panelCtrl.panel.targets);\n\n  if (state.queryModel.target.target !== oldTarget && !state.paused) {\n    state.panelCtrl.refresh();\n  }\n}\n\n/**\n * When metrics autocomplete fails - the error is shown, but only once per page view\n */\nexport function handleMetricsAutoCompleteError(\n  state: GraphiteQueryEditorState,\n  error: Error\n): GraphiteQueryEditorState {\n  console.error(error);\n  if (!state.metricAutoCompleteErrorShown) {\n    state.metricAutoCompleteErrorShown = true;\n    dispatch(notifyApp(createErrorNotification(`Fetching metrics failed: ${error.message}.`)));\n  }\n  return state;\n}\n\n/**\n * When tags autocomplete fails - the error is shown, but only once per page view\n */\nexport function handleTagsAutoCompleteError(state: GraphiteQueryEditorState, error: Error): GraphiteQueryEditorState {\n  console.error(error);\n  if (!state.tagsAutoCompleteErrorShown) {\n    state.tagsAutoCompleteErrorShown = true;\n    dispatch(notifyApp(createErrorNotification(`Fetching tags failed: ${error.message}.`)));\n  }\n  return state;\n}\n","import { GraphiteQueryEditorState } from './store';\nimport { eachRight, map, remove } from 'lodash';\nimport {\n  TAG_PREFIX,\n  GRAPHITE_TAG_OPERATORS,\n  handleMetricsAutoCompleteError,\n  handleTagsAutoCompleteError,\n} from './helpers';\nimport { AngularDropdownOptions, GraphiteSegment, GraphiteTag } from '../types';\n\n/**\n * Providers are hooks for views to provide temporal data for autocomplete. They don't modify the state.\n */\n\n/**\n * Return list of available options for a segment with given index\n *\n * It may be:\n * - mixed list of metrics and tags (only when nothing was selected)\n * - list of metric names (if a metric name was selected for this segment)\n */\nexport async function getAltSegments(\n  state: GraphiteQueryEditorState,\n  index: number,\n  prefix: string\n): Promise<GraphiteSegment[]> {\n  let query = prefix.length > 0 ? '*' + prefix + '*' : '*';\n  if (index > 0) {\n    query = state.queryModel.getSegmentPathUpTo(index) + '.' + query;\n  }\n  const options = {\n    range: state.panelCtrl.range,\n    requestId: 'get-alt-segments',\n  };\n\n  try {\n    const segments = await state.datasource.metricFindQuery(query, options);\n    const altSegments = map(segments, (segment) => {\n      return state.uiSegmentSrv.newSegment({\n        value: segment.text,\n        expandable: segment.expandable,\n      });\n    });\n\n    if (index > 0 && altSegments.length === 0) {\n      return altSegments;\n    }\n\n    // add query references\n    if (index === 0) {\n      eachRight(state.panelCtrl.panel.targets, (target) => {\n        if (target.refId === state.queryModel.target.refId) {\n          return;\n        }\n\n        altSegments.unshift(\n          state.uiSegmentSrv.newSegment({\n            type: 'series-ref',\n            value: '#' + target.refId,\n            expandable: false,\n          })\n        );\n      });\n    }\n\n    // add template variables\n    eachRight(state.templateSrv.getVariables(), (variable) => {\n      altSegments.unshift(\n        state.uiSegmentSrv.newSegment({\n          type: 'template',\n          value: '$' + variable.name,\n          expandable: true,\n        })\n      );\n    });\n\n    // add wildcard option\n    altSegments.unshift(state.uiSegmentSrv.newSegment('*'));\n\n    if (state.supportsTags && index === 0) {\n      removeTaggedEntry(altSegments);\n      return await addAltTagSegments(state, prefix, altSegments);\n    } else {\n      return altSegments;\n    }\n  } catch (err) {\n    handleMetricsAutoCompleteError(state, err);\n  }\n\n  return [];\n}\n\nexport function getTagOperators(): AngularDropdownOptions[] {\n  return mapToDropdownOptions(GRAPHITE_TAG_OPERATORS);\n}\n\n/**\n * Returns tags as dropdown options\n */\nexport async function getTags(\n  state: GraphiteQueryEditorState,\n  index: number,\n  tagPrefix: string\n): Promise<AngularDropdownOptions[]> {\n  try {\n    const tagExpressions = state.queryModel.renderTagExpressions(index);\n    const values = await state.datasource.getTagsAutoComplete(tagExpressions, tagPrefix);\n\n    const altTags = map(values, 'text');\n    altTags.splice(0, 0, state.removeTagValue);\n    return mapToDropdownOptions(altTags);\n  } catch (err) {\n    handleTagsAutoCompleteError(state, err);\n  }\n\n  return [];\n}\n\n/**\n * List of tags when a tag is added. getTags is used for editing.\n * When adding - segment is used. When editing - dropdown is used.\n */\nexport async function getTagsAsSegments(\n  state: GraphiteQueryEditorState,\n  tagPrefix: string\n): Promise<GraphiteSegment[]> {\n  let tagsAsSegments: GraphiteSegment[] = [];\n  try {\n    const tagExpressions = state.queryModel.renderTagExpressions();\n    const values = await state.datasource.getTagsAutoComplete(tagExpressions, tagPrefix);\n    tagsAsSegments = map(values, (val) => {\n      return state.uiSegmentSrv.newSegment({\n        value: val.text,\n        type: 'tag',\n        expandable: false,\n      });\n    });\n  } catch (err) {\n    tagsAsSegments = [];\n    handleTagsAutoCompleteError(state, err);\n  }\n\n  return tagsAsSegments;\n}\n\nexport async function getTagValues(\n  state: GraphiteQueryEditorState,\n  tag: GraphiteTag,\n  index: number,\n  valuePrefix: string\n): Promise<AngularDropdownOptions[]> {\n  const tagExpressions = state.queryModel.renderTagExpressions(index);\n  const tagKey = tag.key;\n  const values = await state.datasource.getTagValuesAutoComplete(tagExpressions, tagKey, valuePrefix, {});\n  const altValues = map(values, 'text');\n  // Add template variables as additional values\n  eachRight(state.templateSrv.getVariables(), (variable) => {\n    altValues.push('${' + variable.name + ':regex}');\n  });\n\n  return mapToDropdownOptions(altValues);\n}\n\n/**\n * Add segments with tags prefixed with \"tag: \" to include them in the same list as metrics\n */\nasync function addAltTagSegments(\n  state: GraphiteQueryEditorState,\n  prefix: string,\n  altSegments: GraphiteSegment[]\n): Promise<GraphiteSegment[]> {\n  let tagSegments = await getTagsAsSegments(state, prefix);\n\n  tagSegments = map(tagSegments, (segment) => {\n    segment.value = TAG_PREFIX + segment.value;\n    return segment;\n  });\n\n  return altSegments.concat(...tagSegments);\n}\n\nfunction removeTaggedEntry(altSegments: GraphiteSegment[]) {\n  remove(altSegments, (s) => s.value === '_tagged');\n}\n\nfunction mapToDropdownOptions(results: string[]) {\n  return map(results, (value) => {\n    return { text: value, value: value };\n  });\n}\n","import GraphiteQuery from '../graphite_query';\nimport { GraphiteActionDispatcher, GraphiteSegment, GraphiteTagOperator } from '../types';\nimport { GraphiteDatasource } from '../datasource';\nimport { TemplateSrv } from '../../../../features/templating/template_srv';\nimport { actions } from './actions';\nimport { getTemplateSrv } from '@grafana/runtime';\nimport {\n  addSeriesByTagFunc,\n  buildSegments,\n  checkOtherSegments,\n  emptySegments,\n  fixTagSegments,\n  handleTargetChanged,\n  parseTarget,\n  pause,\n  removeTagPrefix,\n  setSegmentFocus,\n  smartlyHandleNewAliasByNode,\n  spliceSegments,\n} from './helpers';\nimport { Action } from 'redux';\nimport { FuncDefs } from '../gfunc';\n\nexport type GraphiteQueryEditorState = {\n  /**\n   * Extra segment with plus button when tags are rendered\n   */\n  addTagSegments: GraphiteSegment[];\n\n  supportsTags: boolean;\n  paused: boolean;\n  removeTagValue: string;\n\n  datasource: GraphiteDatasource;\n\n  uiSegmentSrv: any;\n  templateSrv: TemplateSrv;\n  panelCtrl: any;\n\n  target: { target: string; textEditor: boolean };\n\n  funcDefs: FuncDefs | null;\n\n  segments: GraphiteSegment[];\n  queryModel: GraphiteQuery;\n\n  error: Error | null;\n\n  tagsAutoCompleteErrorShown: boolean;\n  metricAutoCompleteErrorShown: boolean;\n};\n\nconst reducer = async (action: Action, state: GraphiteQueryEditorState): Promise<GraphiteQueryEditorState> => {\n  state = { ...state };\n\n  if (actions.init.match(action)) {\n    const deps = action.payload;\n    deps.target.target = deps.target.target || '';\n\n    await deps.datasource.waitForFuncDefsLoaded();\n\n    state = {\n      ...state,\n      ...deps,\n      queryModel: new GraphiteQuery(deps.datasource, deps.target, getTemplateSrv()),\n      supportsTags: deps.datasource.supportsTags,\n      paused: false,\n      removeTagValue: '-- remove tag --',\n      funcDefs: deps.datasource.funcDefs,\n    };\n\n    await buildSegments(state, false);\n  }\n  if (actions.segmentValueChanged.match(action)) {\n    const { segment, index: segmentIndex } = action.payload;\n\n    state.error = null;\n    state.queryModel.updateSegmentValue(segment, segmentIndex);\n\n    if (state.queryModel.functions.length > 0 && state.queryModel.functions[0].def.fake) {\n      state.queryModel.functions = [];\n    }\n\n    if (segment.type === 'tag') {\n      const tag = removeTagPrefix(segment.value);\n      pause(state);\n      await addSeriesByTagFunc(state, tag);\n      return state;\n    }\n\n    if (segment.expandable) {\n      await checkOtherSegments(state, segmentIndex + 1);\n      setSegmentFocus(state, segmentIndex + 1);\n      handleTargetChanged(state);\n    } else {\n      spliceSegments(state, segmentIndex + 1);\n    }\n\n    setSegmentFocus(state, segmentIndex + 1);\n    handleTargetChanged(state);\n  }\n  if (actions.tagChanged.match(action)) {\n    const { tag, index: tagIndex } = action.payload;\n    state.queryModel.updateTag(tag, tagIndex);\n    handleTargetChanged(state);\n  }\n  if (actions.addNewTag.match(action)) {\n    const segment = action.payload.segment;\n    const newTagKey = segment.value;\n    const newTag = { key: newTagKey, operator: '=' as GraphiteTagOperator, value: '' };\n    state.queryModel.addTag(newTag);\n    handleTargetChanged(state);\n    fixTagSegments(state);\n  }\n  if (actions.unpause.match(action)) {\n    state.paused = false;\n    state.panelCtrl.refresh();\n  }\n  if (actions.addFunction.match(action)) {\n    const newFunc = state.datasource.createFuncInstance(action.payload.name, {\n      withDefaultParams: true,\n    });\n    newFunc.added = true;\n    state.queryModel.addFunction(newFunc);\n    smartlyHandleNewAliasByNode(state, newFunc);\n\n    if (state.segments.length === 1 && state.segments[0].fake) {\n      emptySegments(state);\n    }\n\n    if (!newFunc.params.length && newFunc.added) {\n      handleTargetChanged(state);\n    }\n\n    if (newFunc.def.name === 'seriesByTag') {\n      await parseTarget(state);\n    }\n  }\n  if (actions.removeFunction.match(action)) {\n    state.queryModel.removeFunction(action.payload.func);\n    handleTargetChanged(state);\n  }\n  if (actions.moveFunction.match(action)) {\n    const { func, offset } = action.payload;\n    state.queryModel.moveFunction(func, offset);\n    handleTargetChanged(state);\n  }\n  if (actions.updateFunctionParam.match(action)) {\n    const { func, index, value } = action.payload;\n    func.updateParam(value, index);\n    handleTargetChanged(state);\n  }\n  if (actions.updateQuery.match(action)) {\n    state.target.target = action.payload.query;\n    handleTargetChanged(state);\n  }\n  if (actions.runQuery.match(action)) {\n    // handleTargetChanged() builds target from segments/tags/functions only,\n    // it doesn't handle refresh when target is change explicitly\n    state.panelCtrl.refresh();\n  }\n  if (actions.toggleEditorMode.match(action)) {\n    state.target.textEditor = !state.target.textEditor;\n    await parseTarget(state);\n  }\n\n  return { ...state };\n};\n\nexport const createStore = (\n  onChange: (state: GraphiteQueryEditorState) => void\n): [GraphiteActionDispatcher, GraphiteQueryEditorState] => {\n  let state = {} as GraphiteQueryEditorState;\n\n  const dispatch = async (action: Action) => {\n    state = await reducer(action, state);\n    onChange(state);\n  };\n\n  return [dispatch, state];\n};\n","import GraphiteQuery from './graphite_query';\nimport { QueryCtrl } from 'app/plugins/sdk';\nimport { auto } from 'angular';\nimport { TemplateSrv } from '@grafana/runtime';\nimport { actions } from './state/actions';\nimport { getAltSegments, getTagOperators, getTags, getTagsAsSegments, getTagValues } from './state/providers';\nimport { createStore, GraphiteQueryEditorState } from './state/store';\nimport {\n  AngularDropdownOptions,\n  GraphiteActionDispatcher,\n  GraphiteQueryEditorAngularDependencies,\n  GraphiteSegment,\n  GraphiteTag,\n} from './types';\nimport { ChangeEvent } from 'react';\n\n/**\n * @deprecated Moved to state/store\n *\n * Note: methods marked with WIP are kept for easier diffing with previous changes. They will be removed when\n * GraphiteQueryCtrl is replaced with a react component.\n */\nexport class GraphiteQueryCtrl extends QueryCtrl {\n  static templateUrl = 'partials/query.editor.html';\n\n  declare queryModel: GraphiteQuery;\n  segments: any[] = [];\n  addTagSegments: any[] = [];\n  declare removeTagValue: string;\n  supportsTags = false;\n  paused = false;\n\n  private state: GraphiteQueryEditorState;\n  private readonly dispatch: GraphiteActionDispatcher;\n\n  /** @ngInject */\n  constructor(\n    $scope: any,\n    $injector: auto.IInjectorService,\n    private uiSegmentSrv: any,\n    private templateSrv: TemplateSrv\n  ) {\n    super($scope, $injector);\n\n    // This controller will be removed once it's root partial (query.editor.html) renders only React components.\n    // All component will be wrapped in ReactQueryEditor receiving DataSourceApi in QueryRow.renderQueryEditor\n    // The init() action will be removed and the store will be created in ReactQueryEditor. Note that properties\n    // passed to React component in QueryRow.renderQueryEditor are different than properties passed to Angular editor\n    // and will be mapped/provided in a way described below:\n    const deps = {\n      // WIP: to be removed. It's not passed to ReactQueryEditor but it's used only to:\n      // - get refId of the query (refId be passed in query property),\n      // - and to refresh changes (this will be handled by onChange passed to ReactQueryEditor)\n      // - it's needed to get other targets to interpolate the query (this will be added in QueryRow)\n      panelCtrl: this.panelCtrl,\n\n      // WIP: to be replaced with query property passed to ReactQueryEditor\n      target: this.target,\n\n      // WIP: same object will be passed to ReactQueryEditor\n      datasource: this.datasource,\n\n      // This is used to create view models for Angular <metric-segment> component (view models are MetricSegment objects)\n      // It will be simplified to produce data needed by React <SegmentAsync/> component\n      uiSegmentSrv: this.uiSegmentSrv,\n\n      // WIP: will be replaced with:\n      // import { getTemplateSrv } from 'app/features/templating/template_srv';\n      templateSrv: this.templateSrv,\n    };\n\n    const [dispatch, state] = createStore((state) => {\n      this.state = state;\n      // HACK: inefficient but not invoked frequently. It's needed to inform angular watcher about state changes\n      // for state shared between React/AngularJS. Actions invoked from React component will not mark the scope\n      // as dirty and the view won't be updated. It has to happen manually on each state change.\n      this.$scope.$digest();\n    });\n\n    this.state = state;\n    this.dispatch = dispatch;\n\n    this.dispatch(actions.init(deps as GraphiteQueryEditorAngularDependencies));\n  }\n\n  parseTarget() {\n    // WIP: moved to state/helpers (the same name)\n  }\n\n  async toggleEditorMode() {\n    await this.dispatch(actions.toggleEditorMode());\n  }\n\n  buildSegments(modifyLastSegment = true) {\n    // WIP: moved to state/helpers (the same name)\n  }\n\n  addSelectMetricSegment() {\n    // WIP: moved to state/helpers (the same name)\n  }\n\n  checkOtherSegments(fromIndex: number, modifyLastSegment = true) {\n    // WIP: moved to state/helpers (the same name)\n  }\n\n  setSegmentFocus(segmentIndex: any) {\n    // WIP: moved to state/helpers (the same name)\n  }\n\n  /**\n   * Get list of options for an empty segment or a segment with metric when it's clicked/opened.\n   *\n   * This is used for new segments and segments with metrics selected.\n   */\n  async getAltSegments(index: number, text: string): Promise<GraphiteSegment[]> {\n    return await getAltSegments(this.state, index, text);\n  }\n\n  addAltTagSegments(prefix: string, altSegments: any[]) {\n    // WIP: moved to state/providers (the same name)\n  }\n\n  removeTaggedEntry(altSegments: any[]) {\n    // WIP: moved to state/providers (the same name)\n  }\n\n  /**\n   * Apply changes to a given metric segment\n   */\n  async segmentValueChanged(segment: GraphiteSegment, index: number) {\n    await this.dispatch(actions.segmentValueChanged({ segment, index }));\n  }\n\n  spliceSegments(index: any) {\n    // WIP: moved to state/helpers (the same name)\n  }\n\n  emptySegments() {\n    // WIP: moved to state/helpers (the same name)\n  }\n\n  async targetTextChanged(event: ChangeEvent<HTMLInputElement>) {\n    // WIP: removed, handled by GraphiteTextEditor\n  }\n\n  updateModelTarget() {\n    // WIP: moved to state/helpers as handleTargetChanged()\n  }\n\n  async addFunction(name: string) {\n    await this.dispatch(actions.addFunction({ name }));\n  }\n\n  removeFunction(func: any) {\n    // WIP: converted to \"removeFunction\" action  and handled in state/store reducer\n    // It's now dispatched in func_editor\n  }\n\n  moveFunction(func: any, offset: any) {\n    // WIP: converted to \"moveFunction\" action and handled in state/store reducer\n    // It's now dispatched in func_editor\n  }\n\n  addSeriesByTagFunc(tag: string) {\n    // WIP: moved to state/helpers (the same name)\n    // It's now dispatched in func_editor\n  }\n\n  smartlyHandleNewAliasByNode(func: { def: { name: string }; params: number[]; added: boolean }) {\n    // WIP: moved to state/helpers (the same name)\n  }\n\n  getAllTags() {\n    // WIP: removed. It was not used.\n  }\n\n  /**\n   * Get list of tags for editing exiting tag with <gf-form-dropdown>\n   */\n  async getTags(index: number, query: string): Promise<AngularDropdownOptions[]> {\n    return await getTags(this.state, index, query);\n  }\n\n  /**\n   * Get tag list when adding a new tag with <metric-segment>\n   */\n  async getTagsAsSegments(query: string): Promise<GraphiteSegment[]> {\n    return await getTagsAsSegments(this.state, query);\n  }\n\n  /**\n   * Get list of available tag operators\n   */\n  getTagOperators(): AngularDropdownOptions[] {\n    return getTagOperators();\n  }\n\n  getAllTagValues(tag: { key: any }) {\n    // WIP: removed. It was not used.\n  }\n\n  /**\n   * Get list of available tag values\n   */\n  async getTagValues(tag: GraphiteTag, index: number, query: string): Promise<AngularDropdownOptions[]> {\n    return await getTagValues(this.state, tag, index, query);\n  }\n\n  /**\n   * Apply changes when a tag is changed\n   */\n  async tagChanged(tag: GraphiteTag, index: number) {\n    await this.dispatch(actions.tagChanged({ tag, index }));\n  }\n\n  async addNewTag(segment: GraphiteSegment) {\n    await this.dispatch(actions.addNewTag({ segment }));\n  }\n\n  removeTag(index: any) {\n    // WIP: removed. It was not used.\n    // Tags are removed by selecting the segment called \"-- remove tag --\"\n  }\n\n  fixTagSegments() {\n    // WIP: moved to state/helpers (the same name)\n  }\n\n  showDelimiter(index: number) {\n    // WIP: removed. It was not used because of broken syntax in the template. The logic has been moved directly to the template\n  }\n\n  pause() {\n    // WIP: moved to state/helpers (the same name)\n  }\n\n  async unpause() {\n    await this.dispatch(actions.unpause());\n  }\n\n  getCollapsedText() {\n    // WIP: removed. It was not used.\n  }\n\n  handleTagsAutoCompleteError(error: Error): void {\n    // WIP: moved to state/helpers (the same name)\n  }\n\n  handleMetricsAutoCompleteError(error: Error): void {\n    // WIP: moved to state/helpers (the same name)\n  }\n}\n\n// WIP: moved to state/providers (the same names)\n// function mapToDropdownOptions(results: any[]) {}\n// function removeTagPrefix(value: string): string {}\n","import { Alert } from '@grafana/ui';\nimport React from 'react';\n\ntype Props = {\n  onDismiss: () => void;\n};\n\nexport default function MappingsHelp(props: Props): JSX.Element {\n  return (\n    <Alert severity=\"info\" title=\"How to map Graphite metrics to labels?\" onRemove={props.onDismiss}>\n      <p>Mappings are currently supported only between Graphite and Loki queries.</p>\n      <p>\n        When you switch your data source from Graphite to Loki, your queries are mapped according to the mappings\n        defined in the example below. To define a mapping, write the full path of the metric and replace nodes you want\n        to map to label with the label name in parentheses. The value of the label is extracted from your Graphite query\n        when you switch data sources.\n      </p>\n      <p>\n        All tags are automatically mapped to labels regardless of the mapping configuration. Graphite matching patterns\n        (using &#123;&#125;) are converted to Loki&apos;s regular expressions matching patterns. When you use functions\n        in your queries, the metrics, and tags are extracted to match them with defined mappings.\n      </p>\n      <p>\n        Example: for a mapping = <code>servers.(cluster).(server).*</code>:\n      </p>\n      <table>\n        <thead>\n          <tr>\n            <th>Graphite query</th>\n            <th>Mapped to Loki query</th>\n          </tr>\n        </thead>\n        <tbody>\n          <tr>\n            <td>\n              <code>\n                alias(servers.<u>west</u>.<u>001</u>.cpu,1,2)\n              </code>\n            </td>\n            <td>\n              <code>\n                &#123;cluster=&quot;<u>west</u>&quot;, server=&quot;<u>001</u>&quot;&#125;\n              </code>\n            </td>\n          </tr>\n          <tr>\n            <td>\n              <code>\n                alias(servers.*.<u>&#123;001,002&#125;</u>.*,1,2)\n              </code>\n            </td>\n            <td>\n              <code>\n                &#123;server=~&quot;<u>(001|002)</u>&quot;&#125;\n              </code>\n            </td>\n          </tr>\n          <tr>\n            <td>\n              <code>interpolate(seriesByTag(&apos;foo=bar&apos;, &apos;server=002&apos;), inf))</code>\n            </td>\n            <td>\n              <code>&#123;foo=&quot;bar&quot;, server=&quot;002&quot;&#125;</code>\n            </td>\n          </tr>\n        </tbody>\n      </table>\n    </Alert>\n  );\n}\n","import React, { ChangeEvent, useState } from 'react';\nimport { Button, Icon, InlineField, InlineFieldRow, Input } from '@grafana/ui';\nimport MappingsHelp from './MappingsHelp';\n\ntype Props = {\n  mappings: string[];\n  onChange: (mappings: string[]) => void;\n  onDismiss: () => void;\n  onRestoreHelp: () => void;\n  showHelp: boolean;\n};\n\nexport const MappingsConfiguration = (props: Props): JSX.Element => {\n  const [mappings, setMappings] = useState(props.mappings || []);\n\n  return (\n    <div>\n      <h3 className=\"page-heading\">Label mappings</h3>\n      {!props.showHelp && (\n        <p>\n          <Button variant=\"link\" onClick={props.onRestoreHelp}>\n            Learn how label mappings work\n          </Button>\n        </p>\n      )}\n      {props.showHelp && <MappingsHelp onDismiss={props.onDismiss} />}\n\n      <div className=\"gf-form-group\">\n        {mappings.map((mapping, i) => (\n          <InlineFieldRow key={i}>\n            <InlineField label={`Mapping (${i + 1})`}>\n              <Input\n                width={50}\n                onChange={(changeEvent: ChangeEvent<HTMLInputElement>) => {\n                  let newMappings = mappings.concat();\n                  newMappings[i] = changeEvent.target.value;\n                  setMappings(newMappings);\n                }}\n                onBlur={() => {\n                  props.onChange(mappings);\n                }}\n                placeholder=\"e.g. test.metric.(labelName).*\"\n                value={mapping}\n              />\n            </InlineField>\n            <Button\n              type=\"button\"\n              aria-label=\"Remove header\"\n              variant=\"secondary\"\n              size=\"xs\"\n              onClick={(_) => {\n                let newMappings = mappings.concat();\n                newMappings.splice(i, 1);\n                setMappings(newMappings);\n                props.onChange(newMappings);\n              }}\n            >\n              <Icon name=\"trash-alt\" />\n            </Button>\n          </InlineFieldRow>\n        ))}\n        <Button\n          variant=\"secondary\"\n          icon=\"plus\"\n          type=\"button\"\n          onClick={() => {\n            setMappings([...mappings, '']);\n          }}\n        >\n          Add label mapping\n        </Button>\n      </div>\n    </div>\n  );\n};\n","import { GraphiteLokiMapping } from '../types';\n\n/**\n * Converts a simple string used in LokiLogsMappings component (e.g. \"servers.(name).*\")\n * to data model saved in data source configuration.\n */\nexport function fromString(text: string): GraphiteLokiMapping {\n  return {\n    matchers: text.split('.').map((metricNode) => {\n      if (metricNode.startsWith('(') && metricNode.endsWith(')')) {\n        return {\n          value: '*',\n          labelName: metricNode.slice(1, -1),\n        };\n      } else {\n        return { value: metricNode };\n      }\n    }),\n  };\n}\n\n/**\n * Coverts configuration stored in data source configuration into a string displayed in LokiLogsMappings component.\n */\nexport function toString(mapping: GraphiteLokiMapping): string {\n  return mapping.matchers\n    .map((matcher) => {\n      return matcher.labelName ? `(${matcher.labelName})` : `${matcher.value}`;\n    })\n    .join('.');\n}\n","import React, { PureComponent } from 'react';\nimport { Alert, DataSourceHttpSettings, InlineFormLabel, LegacyForms } from '@grafana/ui';\nconst { Select, Switch } = LegacyForms;\nimport {\n  DataSourcePluginOptionsEditorProps,\n  updateDatasourcePluginJsonDataOption,\n  onUpdateDatasourceJsonDataOptionSelect,\n  onUpdateDatasourceJsonDataOptionChecked,\n} from '@grafana/data';\nimport { GraphiteOptions, GraphiteType } from '../types';\nimport { DEFAULT_GRAPHITE_VERSION, GRAPHITE_VERSIONS } from '../versions';\nimport { MappingsConfiguration } from './MappingsConfiguration';\nimport { fromString, toString } from './parseLokiLabelMappings';\nimport store from 'app/core/store';\n\nexport const SHOW_MAPPINGS_HELP_KEY = 'grafana.datasources.graphite.config.showMappingsHelp';\n\nconst graphiteVersions = GRAPHITE_VERSIONS.map((version) => ({ label: `${version}.x`, value: version }));\n\nconst graphiteTypes = Object.entries(GraphiteType).map(([label, value]) => ({\n  label,\n  value,\n}));\n\nexport type Props = DataSourcePluginOptionsEditorProps<GraphiteOptions>;\n\ntype State = {\n  showMappingsHelp: boolean;\n};\n\nexport class ConfigEditor extends PureComponent<Props, State> {\n  constructor(props: Props) {\n    super(props);\n    this.state = {\n      showMappingsHelp: store.getObject(SHOW_MAPPINGS_HELP_KEY, true),\n    };\n  }\n\n  renderTypeHelp = () => {\n    return (\n      <p>\n        There are different types of Graphite compatible backends. Here you can specify the type you are using. If you\n        are using{' '}\n        <a href=\"https://github.com/grafana/metrictank\" className=\"pointer\" target=\"_blank\" rel=\"noreferrer\">\n          Metrictank\n        </a>{' '}\n        then select that here. This will enable Metrictank specific features like query processing meta data. Metrictank\n        is a multi-tenant timeseries engine for Graphite and friends.\n      </p>\n    );\n  };\n\n  componentDidMount() {\n    updateDatasourcePluginJsonDataOption(this.props, 'graphiteVersion', this.currentGraphiteVersion);\n  }\n\n  render() {\n    const { options, onOptionsChange } = this.props;\n\n    const currentVersion = graphiteVersions.find((item) => item.value === this.currentGraphiteVersion);\n\n    return (\n      <>\n        {options.access === 'direct' && (\n          <Alert title=\"Deprecation Notice\" severity=\"warning\">\n            This data source uses browser access mode. This mode is deprecated and will be removed in the future. Please\n            use server access mode instead.\n          </Alert>\n        )}\n        <DataSourceHttpSettings\n          defaultUrl=\"http://localhost:8080\"\n          dataSourceConfig={options}\n          onChange={onOptionsChange}\n        />\n        <h3 className=\"page-heading\">Graphite details</h3>\n        <div className=\"gf-form-group\">\n          <div className=\"gf-form-inline\">\n            <div className=\"gf-form\">\n              <InlineFormLabel tooltip=\"This option controls what functions are available in the Graphite query editor.\">\n                Version\n              </InlineFormLabel>\n              <Select\n                menuShouldPortal\n                value={currentVersion}\n                options={graphiteVersions}\n                width={8}\n                onChange={onUpdateDatasourceJsonDataOptionSelect(this.props, 'graphiteVersion')}\n              />\n            </div>\n          </div>\n          <div className=\"gf-form-inline\">\n            <div className=\"gf-form\">\n              <InlineFormLabel tooltip={this.renderTypeHelp}>Type</InlineFormLabel>\n              <Select\n                menuShouldPortal\n                options={graphiteTypes}\n                value={graphiteTypes.find((type) => type.value === options.jsonData.graphiteType)}\n                width={8}\n                onChange={onUpdateDatasourceJsonDataOptionSelect(this.props, 'graphiteType')}\n              />\n            </div>\n          </div>\n          {options.jsonData.graphiteType === GraphiteType.Metrictank && (\n            <div className=\"gf-form-inline\">\n              <div className=\"gf-form\">\n                <Switch\n                  label=\"Rollup indicator\"\n                  labelClass={'width-10'}\n                  tooltip=\"Shows up as an info icon in panel headers when data is aggregated\"\n                  checked={!!options.jsonData.rollupIndicatorEnabled}\n                  onChange={onUpdateDatasourceJsonDataOptionChecked(this.props, 'rollupIndicatorEnabled')}\n                />\n              </div>\n            </div>\n          )}\n        </div>\n        <MappingsConfiguration\n          mappings={(options.jsonData.importConfiguration?.loki?.mappings || []).map(toString)}\n          showHelp={this.state.showMappingsHelp}\n          onDismiss={() => {\n            this.setState({ showMappingsHelp: false });\n            store.setObject(SHOW_MAPPINGS_HELP_KEY, false);\n          }}\n          onRestoreHelp={() => {\n            this.setState({ showMappingsHelp: true });\n            store.setObject(SHOW_MAPPINGS_HELP_KEY, true);\n          }}\n          onChange={(mappings) => {\n            onOptionsChange({\n              ...options,\n              jsonData: {\n                ...options.jsonData,\n                importConfiguration: {\n                  ...options.jsonData.importConfiguration,\n                  loki: {\n                    mappings: mappings.map(fromString),\n                  },\n                },\n              },\n            });\n          }}\n        />\n      </>\n    );\n  }\n\n  private get currentGraphiteVersion() {\n    return this.props.options.jsonData.graphiteVersion || DEFAULT_GRAPHITE_VERSION;\n  }\n}\n","import { css, cx } from '@emotion/css';\nimport React, { PureComponent } from 'react';\nimport { MetadataInspectorProps, rangeUtil } from '@grafana/data';\nimport { GraphiteDatasource } from './datasource';\nimport { GraphiteQuery, GraphiteOptions, MetricTankSeriesMeta } from './types';\nimport { parseSchemaRetentions, getRollupNotice, getRuntimeConsolidationNotice } from './meta';\nimport { stylesFactory } from '@grafana/ui';\nimport { config } from 'app/core/config';\n\nexport type Props = MetadataInspectorProps<GraphiteDatasource, GraphiteQuery, GraphiteOptions>;\n\nexport interface State {\n  index: number;\n}\n\nexport class MetricTankMetaInspector extends PureComponent<Props, State> {\n  renderMeta(meta: MetricTankSeriesMeta, key: string) {\n    const styles = getStyles();\n    const buckets = parseSchemaRetentions(meta['schema-retentions']);\n    const rollupNotice = getRollupNotice([meta]);\n    const runtimeNotice = getRuntimeConsolidationNotice([meta]);\n    const normFunc = (meta['consolidator-normfetch'] ?? '').replace('Consolidator', '');\n\n    const totalSeconds = buckets.reduce(\n      (acc, bucket) => acc + (bucket.retention ? rangeUtil.intervalToSeconds(bucket.retention) : 0),\n      0\n    );\n\n    return (\n      <div className={styles.metaItem} key={key}>\n        <div className={styles.metaItemHeader}>\n          Schema: {meta['schema-name']}\n          <div className=\"small muted\">Series count: {meta.count}</div>\n        </div>\n        <div className={styles.metaItemBody}>\n          <div className={styles.step}>\n            <div className={styles.stepHeading}>Step 1: Fetch</div>\n            <div className={styles.stepDescription}>\n              First data is fetched, either from raw data archive or a rollup archive\n            </div>\n\n            {rollupNotice && <p>{rollupNotice.text}</p>}\n            {!rollupNotice && <p>No rollup archive was used</p>}\n\n            <div>\n              {buckets.map((bucket, index) => {\n                const bucketLength = bucket.retention ? rangeUtil.intervalToSeconds(bucket.retention) : 0;\n                const lengthPercent = (bucketLength / totalSeconds) * 100;\n                const isActive = index === meta['archive-read'];\n\n                return (\n                  <div key={bucket.retention} className={styles.bucket}>\n                    <div className={styles.bucketInterval}>{bucket.interval}</div>\n                    <div\n                      className={cx(styles.bucketRetention, { [styles.bucketRetentionActive]: isActive })}\n                      style={{ flexGrow: lengthPercent }}\n                    />\n                    <div style={{ flexGrow: 100 - lengthPercent }}>{bucket.retention}</div>\n                  </div>\n                );\n              })}\n            </div>\n          </div>\n\n          <div className={styles.step}>\n            <div className={styles.stepHeading}>Step 2: Normalization</div>\n            <div className={styles.stepDescription}>\n              Normalization happens when series with different intervals between points are combined.\n            </div>\n\n            {meta['aggnum-norm'] > 1 && <p>Normalization did occur using {normFunc}</p>}\n            {meta['aggnum-norm'] === 1 && <p>No normalization was needed</p>}\n          </div>\n\n          <div className={styles.step}>\n            <div className={styles.stepHeading}>Step 3: Runtime consolidation</div>\n            <div className={styles.stepDescription}>\n              If there are too many data points at this point Metrictank will consolidate them down to below max data\n              points (set in queries tab).\n            </div>\n\n            {runtimeNotice && <p>{runtimeNotice.text}</p>}\n            {!runtimeNotice && <p>No runtime consolidation</p>}\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  render() {\n    const { data } = this.props;\n\n    // away to dedupe them\n    const seriesMetas: Record<string, MetricTankSeriesMeta> = {};\n\n    for (const series of data) {\n      if (series.meta && series.meta.custom) {\n        for (const metaItem of series.meta.custom.seriesMetaList as MetricTankSeriesMeta[]) {\n          // key is to dedupe as many series will have identitical meta\n          const key = `${JSON.stringify(metaItem)}`;\n\n          if (seriesMetas[key]) {\n            seriesMetas[key].count += metaItem.count;\n          } else {\n            seriesMetas[key] = metaItem;\n          }\n        }\n      }\n    }\n\n    if (Object.keys(seriesMetas).length === 0) {\n      return <div>No response meta data</div>;\n    }\n\n    return (\n      <div>\n        <h2 className=\"page-heading\">Metrictank Lineage</h2>\n        {Object.keys(seriesMetas).map((key) => this.renderMeta(seriesMetas[key], key))}\n      </div>\n    );\n  }\n}\n\nconst getStyles = stylesFactory(() => {\n  const { theme } = config;\n  const borderColor = theme.isDark ? theme.palette.gray25 : theme.palette.gray85;\n  const background = theme.isDark ? theme.palette.dark1 : theme.palette.white;\n  const headerBg = theme.isDark ? theme.palette.gray15 : theme.palette.gray85;\n\n  return {\n    metaItem: css`\n      background: ${background};\n      border: 1px solid ${borderColor};\n      margin-bottom: ${theme.spacing.md};\n    `,\n    metaItemHeader: css`\n      background: ${headerBg};\n      padding: ${theme.spacing.xs} ${theme.spacing.md};\n      font-size: ${theme.typography.size.md};\n      display: flex;\n      justify-content: space-between;\n    `,\n    metaItemBody: css`\n      padding: ${theme.spacing.md};\n    `,\n    stepHeading: css`\n      font-size: ${theme.typography.size.md};\n    `,\n    stepDescription: css`\n      font-size: ${theme.typography.size.sm};\n      color: ${theme.colors.textWeak};\n      margin-bottom: ${theme.spacing.sm};\n    `,\n    step: css`\n      margin-bottom: ${theme.spacing.lg};\n\n      &:last-child {\n        margin-bottom: 0;\n      }\n    `,\n    bucket: css`\n      display: flex;\n      margin-bottom: ${theme.spacing.sm};\n      border-radius: ${theme.border.radius.md};\n    `,\n    bucketInterval: css`\n      flex-grow: 0;\n      width: 60px;\n    `,\n    bucketRetention: css`\n      background: linear-gradient(0deg, ${theme.palette.blue85}, ${theme.palette.blue95});\n      text-align: center;\n      color: ${theme.palette.white};\n      margin-right: ${theme.spacing.md};\n      border-radius: ${theme.border.radius.md};\n    `,\n    bucketRetentionActive: css`\n      background: linear-gradient(0deg, ${theme.palette.greenBase}, ${theme.palette.greenShade});\n    `,\n  };\n});\n","import { GraphiteDatasource } from './datasource';\nimport { GraphiteQueryCtrl } from './query_ctrl';\nimport { DataSourcePlugin } from '@grafana/data';\nimport { ConfigEditor } from './configuration/ConfigEditor';\nimport { MetricTankMetaInspector } from './MetricTankMetaInspector';\n\nclass AnnotationsQueryCtrl {\n  static templateUrl = 'partials/annotations.editor.html';\n}\n\nexport const plugin = new DataSourcePlugin(GraphiteDatasource)\n  .setQueryCtrl(GraphiteQueryCtrl)\n  .setConfigEditor(ConfigEditor)\n  .setMetadataInspector(MetricTankMetaInspector)\n  .setAnnotationQueryCtrl(AnnotationsQueryCtrl);\n"],"sourceRoot":""}