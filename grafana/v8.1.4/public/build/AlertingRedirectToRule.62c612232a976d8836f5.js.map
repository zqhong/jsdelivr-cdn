{"version":3,"sources":["webpack:///./public/app/features/alerting/unified/hooks/useCombinedRuleNamespaces.ts","webpack:///./public/app/features/alerting/unified/RedirectToRuleViewer.tsx","webpack:///./public/app/features/alerting/unified/hooks/useCombinedRule.ts","webpack:///./public/app/features/alerting/unified/components/rule-viewer/RuleViewerLayout.tsx"],"names":["useCombinedRuleNamespaces","rulesSourceName","promRulesResponses","useUnifiedAlertingSelector","state","promRules","rulerRulesResponses","rulerRules","cache","useRef","rulesSources","useMemo","rulesSource","getRulesSourceByName","Error","getAllRulesSources","map","isCloudRulesSource","name","result","cached","current","namespaces","Object","entries","forEach","namespaceName","groups","namespace","group","combinedGroup","rules","rule","isAlertingRulerRule","alert","query","expr","labels","annotations","rulerRule","isRecordingRulerRule","record","grafana_alert","title","rulerRuleToCombinedRule","addRulerGroupsToCombinedNamespace","find","g","push","existingRule","isGrafanaRulesSource","promRule","isCombinedRuleEqualToPromRule","getExistingRuleInGroup","isAlertingRule","promRuleToCombinedRule","addPromGroupsToCombinedNamespace","values","flatMap","sort","a","b","localeCompare","flat","combinedRule","checkQuery","JSON","stringify","hashQuery","length","substr","replace","split","join","pageTitle","RedirectToRuleViewer","props","sourceName","match","params","styles","useStyles2","getStyles","error","loading","dispatched","useCombinedRulesMatching","className","errorMessage","message","stack","Array","isArray","text","to","createViewLink","param","index","heading","href","Meta","separator","Tags","theme","css","colors","secondary","spacing","withErrorBoundary","style","useCombinedRule","identifier","ruleSourceName","requestState","useCombinedRulesLoader","combinedRules","id","ruleId","ruleName","dispatch","useDispatch","promRuleRequests","promRuleRequest","getRequestState","rulerRuleRequests","rulerRuleRequest","useEffect","fetchPromRulesAction","fetchRulerRulesAction","isRulerNotSupportedResponse","undefined","slice","initialAsyncRequestState","RuleViewerLayout","wrapInContent","children","getPageStyles","pageIcon","onGoBack","locationService","content","RuleViewerLayoutContent","padding","getContentStyles","wrapper","breakpoints","xxl","background","primary","border","weak","shape","borderRadius"],"mappings":"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","file":"AlertingRedirectToRule.62c612232a976d8836f5.js","sourcesContent":["import {\n  CombinedRule,\n  CombinedRuleGroup,\n  CombinedRuleNamespace,\n  Rule,\n  RuleGroup,\n  RuleNamespace,\n  RulesSource,\n} from 'app/types/unified-alerting';\nimport { RulerRuleDTO, RulerRuleGroupDTO, RulerRulesConfigDTO } from 'app/types/unified-alerting-dto';\nimport { useMemo, useRef } from 'react';\nimport {\n  getAllRulesSources,\n  getRulesSourceByName,\n  isCloudRulesSource,\n  isGrafanaRulesSource,\n} from '../utils/datasource';\nimport { isAlertingRule, isAlertingRulerRule, isRecordingRulerRule } from '../utils/rules';\nimport { useUnifiedAlertingSelector } from './useUnifiedAlertingSelector';\n\ninterface CacheValue {\n  promRules?: RuleNamespace[];\n  rulerRules?: RulerRulesConfigDTO | null;\n  result: CombinedRuleNamespace[];\n}\n\n// this little monster combines prometheus rules and ruler rules to produce a unified data structure\n// can limit to a single rules source\nexport function useCombinedRuleNamespaces(rulesSourceName?: string): CombinedRuleNamespace[] {\n  const promRulesResponses = useUnifiedAlertingSelector((state) => state.promRules);\n  const rulerRulesResponses = useUnifiedAlertingSelector((state) => state.rulerRules);\n\n  // cache results per rules source, so we only recalculate those for which results have actually changed\n  const cache = useRef<Record<string, CacheValue>>({});\n\n  const rulesSources = useMemo((): RulesSource[] => {\n    if (rulesSourceName) {\n      const rulesSource = getRulesSourceByName(rulesSourceName);\n      if (!rulesSource) {\n        throw new Error(`Unknown rules source: ${rulesSourceName}`);\n      }\n      return [rulesSource];\n    }\n    return getAllRulesSources();\n  }, [rulesSourceName]);\n\n  return useMemo(\n    () =>\n      rulesSources\n        .map((rulesSource): CombinedRuleNamespace[] => {\n          const rulesSourceName = isCloudRulesSource(rulesSource) ? rulesSource.name : rulesSource;\n          const promRules = promRulesResponses[rulesSourceName]?.result;\n          const rulerRules = rulerRulesResponses[rulesSourceName]?.result;\n\n          const cached = cache.current[rulesSourceName];\n          if (cached && cached.promRules === promRules && cached.rulerRules === rulerRules) {\n            return cached.result;\n          }\n          const namespaces: Record<string, CombinedRuleNamespace> = {};\n\n          // first get all the ruler rules in\n          Object.entries(rulerRules || {}).forEach(([namespaceName, groups]) => {\n            const namespace: CombinedRuleNamespace = {\n              rulesSource,\n              name: namespaceName,\n              groups: [],\n            };\n            namespaces[namespaceName] = namespace;\n            addRulerGroupsToCombinedNamespace(namespace, groups);\n          });\n\n          // then correlate with prometheus rules\n          promRules?.forEach(({ name: namespaceName, groups }) => {\n            const ns = (namespaces[namespaceName] = namespaces[namespaceName] || {\n              rulesSource,\n              name: namespaceName,\n              groups: [],\n            });\n\n            addPromGroupsToCombinedNamespace(ns, groups);\n          });\n\n          const result = Object.values(namespaces);\n          if (isGrafanaRulesSource(rulesSource)) {\n            // merge all groups in case of grafana managed, essentially treating namespaces (folders) as gorups\n            result.forEach((namespace) => {\n              namespace.groups = [\n                {\n                  name: 'default',\n                  rules: namespace.groups.flatMap((g) => g.rules).sort((a, b) => a.name.localeCompare(b.name)),\n                },\n              ];\n            });\n          }\n          cache.current[rulesSourceName] = { promRules, rulerRules, result };\n          return result;\n        })\n        .flat(),\n    [promRulesResponses, rulerRulesResponses, rulesSources]\n  );\n}\n\nfunction addRulerGroupsToCombinedNamespace(namespace: CombinedRuleNamespace, groups: RulerRuleGroupDTO[]): void {\n  namespace.groups = groups.map((group) => {\n    const combinedGroup: CombinedRuleGroup = {\n      name: group.name,\n      rules: [],\n    };\n    combinedGroup.rules = group.rules.map((rule) => rulerRuleToCombinedRule(rule, namespace, combinedGroup));\n    return combinedGroup;\n  });\n}\n\nfunction addPromGroupsToCombinedNamespace(namespace: CombinedRuleNamespace, groups: RuleGroup[]): void {\n  groups.forEach((group) => {\n    let combinedGroup = namespace.groups.find((g) => g.name === group.name);\n    if (!combinedGroup) {\n      combinedGroup = {\n        name: group.name,\n        rules: [],\n      };\n      namespace.groups.push(combinedGroup);\n    }\n\n    (group.rules ?? []).forEach((rule) => {\n      const existingRule = getExistingRuleInGroup(rule, combinedGroup!, namespace.rulesSource);\n      if (existingRule) {\n        existingRule.promRule = rule;\n      } else {\n        combinedGroup!.rules.push(promRuleToCombinedRule(rule, namespace, combinedGroup!));\n      }\n    });\n  });\n}\n\nfunction promRuleToCombinedRule(rule: Rule, namespace: CombinedRuleNamespace, group: CombinedRuleGroup): CombinedRule {\n  return {\n    name: rule.name,\n    query: rule.query,\n    labels: rule.labels || {},\n    annotations: isAlertingRule(rule) ? rule.annotations || {} : {},\n    promRule: rule,\n    namespace: namespace,\n    group,\n  };\n}\n\nfunction rulerRuleToCombinedRule(\n  rule: RulerRuleDTO,\n  namespace: CombinedRuleNamespace,\n  group: CombinedRuleGroup\n): CombinedRule {\n  return isAlertingRulerRule(rule)\n    ? {\n        name: rule.alert,\n        query: rule.expr,\n        labels: rule.labels || {},\n        annotations: rule.annotations || {},\n        rulerRule: rule,\n        namespace,\n        group,\n      }\n    : isRecordingRulerRule(rule)\n    ? {\n        name: rule.record,\n        query: rule.expr,\n        labels: rule.labels || {},\n        annotations: {},\n        rulerRule: rule,\n        namespace,\n        group,\n      }\n    : {\n        name: rule.grafana_alert.title,\n        query: '',\n        labels: rule.labels || {},\n        annotations: rule.annotations || {},\n        rulerRule: rule,\n        namespace,\n        group,\n      };\n}\n\n// find existing rule in group that matches the given prom rule\nfunction getExistingRuleInGroup(\n  rule: Rule,\n  group: CombinedRuleGroup,\n  rulesSource: RulesSource\n): CombinedRule | undefined {\n  if (isGrafanaRulesSource(rulesSource)) {\n    // assume grafana groups have only the one rule. check name anyway because paranoid\n    return group!.rules.find((existingRule) => existingRule.name === rule.name);\n  }\n  return (\n    // try finding a rule that matches name, labels, annotations and query\n    group!.rules.find(\n      (existingRule) => !existingRule.promRule && isCombinedRuleEqualToPromRule(existingRule, rule, true)\n    ) ??\n    // if that fails, try finding a rule that only matches name, labels and annotations.\n    // loki & prom can sometimes modify the query so it doesnt match, eg `2 > 1` becomes `1`\n    group!.rules.find(\n      (existingRule) => !existingRule.promRule && isCombinedRuleEqualToPromRule(existingRule, rule, false)\n    )\n  );\n}\n\nfunction isCombinedRuleEqualToPromRule(combinedRule: CombinedRule, rule: Rule, checkQuery = true): boolean {\n  if (combinedRule.name === rule.name) {\n    return (\n      JSON.stringify([\n        checkQuery ? hashQuery(combinedRule.query) : '',\n        combinedRule.labels,\n        combinedRule.annotations,\n      ]) ===\n      JSON.stringify([\n        checkQuery ? hashQuery(rule.query) : '',\n        rule.labels || {},\n        isAlertingRule(rule) ? rule.annotations || {} : {},\n      ])\n    );\n  }\n  return false;\n}\n\n// there can be slight differences in how prom & ruler render a query, this will hash them accounting for the differences\nfunction hashQuery(query: string) {\n  // one of them might be wrapped in parens\n  if (query.length > 1 && query[0] === '(' && query[query.length - 1] === ')') {\n    query = query.substr(1, query.length - 2);\n  }\n  // whitespace could be added or removed\n  query = query.replace(/\\s|\\n/g, '');\n  // labels matchers can be reordered, so sort the enitre string, esentially comparing just the character counts\n  return query.split('').sort().join('');\n}\n","import React from 'react';\nimport { Redirect } from 'react-router-dom';\nimport { css } from '@emotion/css';\nimport { GrafanaTheme2 } from '@grafana/data';\nimport { Alert, Card, Icon, LoadingPlaceholder, useStyles2, withErrorBoundary } from '@grafana/ui';\nimport { GrafanaRouteComponentProps } from 'app/core/navigation/types';\nimport { useCombinedRulesMatching } from './hooks/useCombinedRule';\nimport { createViewLink } from './utils/misc';\nimport { getRulesSourceByName } from './utils/datasource';\nimport { RuleViewerLayout } from './components/rule-viewer/RuleViewerLayout';\nimport { AlertLabels } from './components/AlertLabels';\n\ntype RedirectToRuleViewerProps = GrafanaRouteComponentProps<{ name?: string; sourceName?: string }>;\nconst pageTitle = 'Alerting / Find rule';\n\nexport function RedirectToRuleViewer(props: RedirectToRuleViewerProps): JSX.Element | null {\n  const { name, sourceName } = props.match.params;\n  const styles = useStyles2(getStyles);\n  const { error, loading, result: rules, dispatched } = useCombinedRulesMatching(name, sourceName);\n\n  if (error) {\n    return (\n      <RuleViewerLayout title={pageTitle}>\n        <Alert title={`Failed to load rules from ${sourceName}`}>\n          <details className={styles.errorMessage}>\n            {error.message}\n            <br />\n            {!!error?.stack && error.stack}\n          </details>\n        </Alert>\n      </RuleViewerLayout>\n    );\n  }\n\n  if (loading || !dispatched || !Array.isArray(rules)) {\n    return (\n      <RuleViewerLayout title={pageTitle}>\n        <LoadingPlaceholder text=\"Loading rule...\" />\n      </RuleViewerLayout>\n    );\n  }\n\n  if (!name || !sourceName) {\n    return <Redirect to=\"/notfound\" />;\n  }\n\n  const rulesSource = getRulesSourceByName(sourceName);\n\n  if (!rulesSource) {\n    return (\n      <RuleViewerLayout title={pageTitle}>\n        <Alert title=\"Could not view rule\">\n          <details className={styles.errorMessage}>{`Could not find data source with name: ${sourceName}.`}</details>\n        </Alert>\n      </RuleViewerLayout>\n    );\n  }\n\n  if (rules.length === 1) {\n    const [rule] = rules;\n    return <Redirect to={createViewLink(rulesSource, rule, '/alerting/list')} />;\n  }\n\n  return (\n    <RuleViewerLayout title={pageTitle}>\n      <div>\n        Several rules in <span className={styles.param}>{sourceName}</span> matched the name{' '}\n        <span className={styles.param}>{name}</span>, please select the rule you want to view.\n      </div>\n      <div className={styles.rules}>\n        {rules.map((rule, index) => {\n          return (\n            <Card\n              key={`${rule.name}-${index}`}\n              heading={rule.name}\n              href={createViewLink(rulesSource, rule, '/alerting/list')}\n            >\n              <Card.Meta separator={''}>\n                <Icon name=\"folder\" />\n                <span className={styles.namespace}>{`${rule.namespace.name} / ${rule.group.name}`}</span>\n              </Card.Meta>\n              <Card.Tags>\n                <AlertLabels labels={rule.labels} />\n              </Card.Tags>\n            </Card>\n          );\n        })}\n      </div>\n    </RuleViewerLayout>\n  );\n}\n\nfunction getStyles(theme: GrafanaTheme2) {\n  return {\n    param: css`\n      font-style: italic;\n      color: ${theme.colors.text.secondary};\n    `,\n    rules: css`\n      margin-top: ${theme.spacing(2)};\n    `,\n    namespace: css`\n      margin-left: ${theme.spacing(1)};\n    `,\n    errorMessage: css`\n      white-space: pre-wrap;\n    `,\n  };\n}\n\nexport default withErrorBoundary(RedirectToRuleViewer, { style: 'page' });\n","import { useEffect, useMemo } from 'react';\nimport { useDispatch } from 'react-redux';\nimport { CombinedRule, RuleIdentifier, RuleNamespace } from 'app/types/unified-alerting';\nimport { AsyncRequestMapSlice, AsyncRequestState, initialAsyncRequestState } from '../utils/redux';\nimport { useCombinedRuleNamespaces } from './useCombinedRuleNamespaces';\nimport { useUnifiedAlertingSelector } from './useUnifiedAlertingSelector';\nimport { fetchPromRulesAction, fetchRulerRulesAction } from '../state/actions';\nimport { RulerRulesConfigDTO } from 'app/types/unified-alerting-dto';\nimport * as ruleId from '../utils/rule-id';\nimport { isRulerNotSupportedResponse } from '../utils/rules';\n\nexport function useCombinedRule(\n  identifier: RuleIdentifier | undefined,\n  ruleSourceName: string | undefined\n): AsyncRequestState<CombinedRule> {\n  const requestState = useCombinedRulesLoader(ruleSourceName);\n  const combinedRules = useCombinedRuleNamespaces(ruleSourceName);\n\n  const rule = useMemo(() => {\n    if (!identifier || !ruleSourceName || combinedRules.length === 0) {\n      return;\n    }\n\n    for (const namespace of combinedRules) {\n      for (const group of namespace.groups) {\n        for (const rule of group.rules) {\n          const id = ruleId.fromCombinedRule(ruleSourceName, rule);\n\n          if (ruleId.equal(id, identifier)) {\n            return rule;\n          }\n        }\n      }\n    }\n\n    return;\n  }, [identifier, ruleSourceName, combinedRules]);\n\n  return {\n    ...requestState,\n    result: rule,\n  };\n}\n\nexport function useCombinedRulesMatching(\n  ruleName: string | undefined,\n  ruleSourceName: string | undefined\n): AsyncRequestState<CombinedRule[]> {\n  const requestState = useCombinedRulesLoader(ruleSourceName);\n  const combinedRules = useCombinedRuleNamespaces(ruleSourceName);\n\n  const rules = useMemo(() => {\n    if (!ruleName || !ruleSourceName || combinedRules.length === 0) {\n      return [];\n    }\n\n    const rules: CombinedRule[] = [];\n\n    for (const namespace of combinedRules) {\n      for (const group of namespace.groups) {\n        for (const rule of group.rules) {\n          if (rule.name === ruleName) {\n            rules.push(rule);\n          }\n        }\n      }\n    }\n\n    return rules;\n  }, [ruleName, ruleSourceName, combinedRules]);\n\n  return {\n    ...requestState,\n    result: rules,\n  };\n}\n\nfunction useCombinedRulesLoader(ruleSourceName: string | undefined): AsyncRequestState<void> {\n  const dispatch = useDispatch();\n  const promRuleRequests = useUnifiedAlertingSelector((state) => state.promRules);\n  const promRuleRequest = getRequestState(ruleSourceName, promRuleRequests);\n  const rulerRuleRequests = useUnifiedAlertingSelector((state) => state.rulerRules);\n  const rulerRuleRequest = getRequestState(ruleSourceName, rulerRuleRequests);\n\n  useEffect(() => {\n    if (!ruleSourceName) {\n      return;\n    }\n\n    dispatch(fetchPromRulesAction(ruleSourceName));\n    dispatch(fetchRulerRulesAction(ruleSourceName));\n  }, [dispatch, ruleSourceName]);\n\n  return {\n    loading: promRuleRequest.loading || rulerRuleRequest.loading,\n    error: promRuleRequest.error ?? isRulerNotSupportedResponse(rulerRuleRequest) ? undefined : rulerRuleRequest.error,\n    dispatched: promRuleRequest.dispatched && rulerRuleRequest.dispatched,\n  };\n}\n\nfunction getRequestState(\n  ruleSourceName: string | undefined,\n  slice: AsyncRequestMapSlice<RulerRulesConfigDTO | RuleNamespace[] | null>\n): AsyncRequestState<RulerRulesConfigDTO | RuleNamespace[] | null> {\n  if (!ruleSourceName) {\n    return initialAsyncRequestState;\n  }\n\n  const state = slice[ruleSourceName];\n\n  if (!state) {\n    return initialAsyncRequestState;\n  }\n\n  return state;\n}\n","import React from 'react';\nimport { css } from '@emotion/css';\nimport { GrafanaTheme2 } from '@grafana/data';\nimport { locationService } from '@grafana/runtime';\nimport { PageToolbar, useStyles2 } from '@grafana/ui';\nimport { Page } from 'app/core/components/Page/Page';\n\ntype Props = {\n  children: React.ReactNode | React.ReactNode[];\n  title: string;\n  wrapInContent?: boolean;\n};\n\nexport function RuleViewerLayout(props: Props): JSX.Element | null {\n  const { wrapInContent = true, children, title } = props;\n  const styles = useStyles2(getPageStyles);\n\n  return (\n    <Page>\n      <PageToolbar title={title} pageIcon=\"bell\" onGoBack={() => locationService.push('/alerting/list')} />\n      <div className={styles.content}>{wrapInContent ? <RuleViewerLayoutContent {...props} /> : children}</div>\n    </Page>\n  );\n}\n\ntype ContentProps = {\n  children: React.ReactNode | React.ReactNode[];\n  padding?: number;\n};\n\nexport function RuleViewerLayoutContent({ children, padding = 2 }: ContentProps): JSX.Element | null {\n  const styles = useStyles2(getContentStyles(padding));\n  return <div className={styles.wrapper}>{children}</div>;\n}\n\nconst getPageStyles = (theme: GrafanaTheme2) => {\n  return {\n    content: css`\n      margin: ${theme.spacing(0, 2, 2)};\n      max-width: ${theme.breakpoints.values.xxl}px;\n    `,\n  };\n};\n\nconst getContentStyles = (padding: number) => (theme: GrafanaTheme2) => {\n  return {\n    wrapper: css`\n      background: ${theme.colors.background.primary};\n      border: 1px solid ${theme.colors.border.weak};\n      border-radius: ${theme.shape.borderRadius()};\n      padding: ${theme.spacing(padding)};\n    `,\n  };\n};\n"],"sourceRoot":""}